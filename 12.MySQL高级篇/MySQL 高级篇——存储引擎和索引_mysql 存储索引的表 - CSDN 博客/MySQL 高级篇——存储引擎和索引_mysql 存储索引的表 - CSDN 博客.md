---
url: https://blog.csdn.net/qq_40991313/article/details/130308116
title: MySQL 高级篇——存储引擎和索引_mysql 存储索引的表 - CSDN 博客
date: 2025-02-20 13:50:15
tag: 
summary: 
---
 **导航：**

[【Java 笔记 + 踩坑汇总】Java 基础 + JavaWeb+SSM+SpringBoot+SpringCloud + 瑞吉外卖 / 谷粒商城 / 学成在线 + 设计模式 + 面试题汇总 + 性能调优 / 架构设计 + 源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?spm=1001.2014.3001.5501 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[一、存储引擎](#t0) 

[1.1、查看、设置存储引擎的命令](#t1)

[1.2、InnoDB 引擎](#t2)

[1.2.1、介绍](#t3)

[1.2.2、优势](#t4)

[1.2.3、InnoDB 事务的 ACID 特性](#t5)

[1.2.4、InnoDB 架构](#t6)

[1.3、MyISAM 引擎](#t7) 

[1.3.1、MyISAM 引擎介绍](#t8) 

[1.3.2、InnoDB 对比 MyISAM](#t9)

[1.4、其他引擎](#t10)

[二、索引](#t11)

[2.1、介绍](#t12) 

[2.2、B + 树](#t13)

[2.2.1、B + 树介绍](#t14)

[2.2.2、演示 innoDB 的 B + 树聚簇索引，存储数据和目录](#t15)

[2.3、innoDB 的索引方案](#t16)

[2.3.1、聚簇索引](#t17)

[2.3.2、非聚簇索引（又称辅助索引、二级索引）](#t18)

[2.3.3、聚簇索引和非聚簇索引区别](#t19)

[2.3.4、联合索引](#t20)

[2.4、MyISAM 的索引方案](#t21)

[2.5、MyISAM 与 InnoDB 对比](#t22)

[2.6、索引的代价](#t23)

[2.7、Hash 结构](#t24)

[2.7.1、Hash 结构介绍](#t25)

[2.7.2、innoDB 自适应的哈希索引](#t26)

[2.7.3、Hash 索引与 B+ 树索引的区别](#t27)

[2.8、B 树](#t28)

[2.8.1、介绍](#t29) 

[2.8.2、B+ 树和 B 树的差异](#t30)

[2.9、红黑树](#t31)

[三、innoDB 数据存储结构](#t32)

[3.1、页](#t33)

[3.1.1、页：数据库的基本存储单位](#t34)

[3.1.2、数据页的大小](#t35)

[3.1.3、页结构](#t36)

[3.2、行、页、区、段、表空间的关系](#t37)

[3.3、innoDB 行格式](#t38)

[3.3.1、四种行格式](#t39)

[3.3.2、指定行格式的命令](#t40)

## 一、存储引擎 

### 1.1、查看、设置存储引擎的命令

查看 mysql 提供什么存储引擎：

```
CREATE TABLE 表名(
建表语句;
) ENGINE = 存储引擎名称;
```

![](<assets/1740030616315.png>)

查看默认的存储引擎： 

```
CREATE TABLE index_demo(
 c1 INT,
 c2 INT,
 c3 CHAR(1),
 PRIMARY KEY(c1)
 ) ROW_FORMAT = Compact;
```

或者：

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
 
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

创建表时指定存储引擎:

```
CREATE TABLE record_test_table (
 
    col1 VARCHAR(8),
 
    col2 VARCHAR(8) NOT NULL,
 
    col3 CHAR(8),
 
    col4 VARCHAR(8)
 
 ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

 修改表的存储引擎

```
INSERT INTO record_test_table(col1, col2, col3, col4) 
 
VALUES
 
('zhangsan', 'lisi', 'wangwu', 'songhk'), 
 
('tong', 'chen', NULL, NULL);
```

### 1.2、InnoDB 引擎

#### 1.2.1、介绍

**InnoDB：**支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。

**InnoDB** 索引文件在数据库中存放的对应表的磁盘文件有 *.frm，*.ibd 结尾的两个文件；

*   frm 文件是存放的表结构，表的定义信息；
*   *.ibd 文件是存放着表中的数据、索引信息；

**特点：** 

*   MySQL 从 3.23.34a 开始就包含 InnoDB 存储引擎。大于等于 5.5 之后，**默认采用 InnoDB 引擎**。
*   InnoDB 是 MySQL 的默认事务型引擎，它被设计用来**处理大量的短期 (short-lived) 事务**。可以确保事务的完整提交 (Commit) 和回滚(Rollback)。
*   除了增加和查询外，还需要更新、删除操作，那么，应优先选择 InnoDB 存储引擎。
*   除非有非常特别的原因需要使用其他的存储引擎，否则应该**优先考虑 InnoDB 引擎**。
*   InnoDB 是**为处理巨大数据量的最大性能设计**。
*   在以前的版本中，字典数据以元数据文件、非事务表等来存储。现在这些元数据文件被删除了。比如： .frm ， .par ， .trn ， .isl ， .db.opt 等都在 MySQL8.0 中不存在了。
*   表名. frm 存储表结构（MySQL8.0 时，合并在表名. ibd 中）；表名. ibd 存储数据和索引
*   InnoDB 增删改性能更优；MyISAM 查询性能更优。
*   MyISAM 只缓存索引，不缓存真实数据；InnoDB **不仅缓存索引还要缓存真实数据**， 对内存要求较高，而且**内存大小对性能有决定性的影响**。

#### 1.2.2、优势

InnoDB 存储引擎在实际应用中拥有诸多优势，比如**操作便利**、提高了**数据库的性能、维护成本低**等。如果由于硬件或软件的原因导致服务器崩溃，那么在重启服务器之后不需要进行额外的操作。InnoDB **崩溃恢复功能**自动将之前提交的内容定型，然后撤销没有提交的进程，重启之后继续从崩溃点开始执行。

InnoDB 存储引擎在主内存中维护**缓冲池**，高频率使用的数据将在内存中直接被处理。这种缓存方式应用于多种信息，加速了处理进程。

在专用服务器上，物理内存中高达 80% 的部分被应用于缓冲池。如果需要将数据插入不同的表中，可以设置**外键**加强数据的完整性。更新或者删除数据，关联数据将会被自动更新或删除。如果试图将数据插入从表，但在主表中没有对应的数据，插入的数据将被自动移除。如果磁盘或内存中的数据出现崩溃，在使用脏数据之前，校验和机制会发出警告。当每个表的主键都设置合理时，与这些列有关的操作会被自动优化。插入、更新和删除操作通过做改变缓冲自动机制进行优化。InnoDB 不仅支持当前读写，也会缓冲改变的数据到数据流磁盘。

InnoDB 的性能优势不只存在于长时运行查询的**大型表**。在同一列多次被查询时，自适应**哈希索引**会**提高查询的速度**。使用 InnoDB 可以压缩表和相关的索引，可以在不影响性能和可用性的情况下创建或删除索引。对于大型文本和 BLOB 数据，使用动态行形式，这种存储布局更高效。通过查询 INFORMATION_SCHEMA 库中的表可以监控存储引擎的内部工作。在同一个语句中，InnoDB 表可以与其他存储引擎表混用。即使有些操作系统限制文件大小为 2GB，InnoDB 仍然可以处理。当处理**大数据量**时，InnoDB 兼顾 CPU，以达到**最大性能**。 

#### 1.2.3、InnoDB 事务的 ACID 特性

![](<assets/1740030616656.png>)

隔离性：事务之间互相隔离。

持久性：一旦事务成功，数据一定会落入数据库。

ACID 模型是一系列**数据库设计规则**，这些规则着重**强调可靠性**，而可靠性对于商业数据和任务关键型应用非常重要。MySQL 包含类似 InnoDB 存储引擎的组件，与 ACID 模型紧密相连，这样出现意外时，数据不会崩溃，结果不会失真。如果依赖 ACID 模型，可以不使用一致性检查和崩溃恢复机制。如果拥有额外的软件保护，极可靠的硬件或者应用可以容忍一小部分的数据丢失和不一致，可以将 MySQL 设置调整为只依赖部分 ACID 特性，以达到更高的性能。

下面讲解 InnoDB 存储引擎与 ACID 模型相同作用的四个方面：

**1. 原子方面** ACID 的原子方面主要涉及 InnoDB 事务，与 MySQL 相关的特性主要包括：

*   自动提交设置。
*   COMMIT 语句。
*   ROLLBACK 语句。
*   操作 INFORMATION_SCHEMA 库中的表数据。

**2. 一致性方面** ACID 模型的一致性主要涉及保护数据不崩溃的内部 InnoDB 处理过程，与 MySQL 相关的特性主要包括：

*   InnoDB 双写缓存。
*   InnoDB 崩溃恢复。

**3. 隔离方面** 隔离是应用于事务的级别，与 MySQL 相关的特性主要包括：

*   自动提交设置。
*   SET ISOLATION LEVEL 语句。
*   InnoDB 锁的低级别信息。

**4. 持久性方面** ACID 模型的持久性主要涉及与硬件配置相互影响的 MySQL 软件特性。由于硬件复杂多样化，耐久性方面没有具体的规则可循。与 MySQL 相关的特性有：

*   InnoDB 双写缓存，通过 innodb_doublewrite 配置项配置。
*   配置项 innodb_flush_log_at_trx_commit。
*   配置项 sync_binlog。
*   配置项 innodb_file_per_table。
*   存储设备的写入缓存。
*   存储设备的备用电池缓存。
*   运行 MySQL 的操作系统。
*   持续的电力供应。
*   备份策略。
*   对分布式或托管的应用，最主要的在于硬件设备的地点以及网络情况。

#### 1.2.4、InnoDB 架构

1. 缓冲池 缓冲池是主内存中的一部分空间，用来缓存已使用的表和索引数据。缓冲池使得经常被使用的数据能够直接在内存中获得，从而提高速度。

2. 更改缓存 更改缓存是一个特殊的数据结构，当受影响的索引页不在缓存中时，更改缓存会缓存辅助索引页的更改。索引页被其他读取操作时会加载到缓存池，缓存的更改内容就会被合并。不同于集群索引，辅助索引并非独一无二的。当系统大部分闲置时，清除操作会定期运行，将更新的索引页刷入磁盘。更新缓存合并期间，可能会大大降低查询的性能。在内存中，更新缓存占用一部分 InnoDB 缓冲池。在磁盘中，更新缓存是系统表空间的一部分。更新缓存的数据类型由 innodb_change_buffering 配置项管理。

3. 自适应哈希索引 自适应哈希索引将负载和足够的内存结合起来，使得 InnoDB 像内存数据库一样运行，不需要降低事务上的性能或可靠性。这个特性通过 innodb_adaptive_hash_index 选项配置，或者通过 --skip-innodb_adaptive_hash_index 命令行在服务启动时关闭。

4. 重做日志缓存 重做日志缓存存放要放入重做日志的数据。重做日志缓存大小通过 innodb_log_buffer_size 配置项配置。重做日志缓存会定期地将日志文件刷入磁盘。大型的重做日志缓存使得大型事务能够正常运行而不需要写入磁盘。

5. 系统表空间 系统表空间包括 InnoDB 数据字典、双写缓存、更新缓存和撤销日志，同时也包括表和索引数据。多表共享，系统表空间被视为共享表空间。

6. 双写缓存 双写缓存位于系统表空间中，用于写入从缓存池刷新的数据页。只有在刷新并写入双写缓存后，InnoDB 才会将数据页写入合适的位置。

7. 撤销日志 撤销日志是一系列与事务相关的撤销记录的集合，包含如何撤销事务最近的更改。如果其他事务要查询原始数据，可以从撤销日志记录中追溯未更改的数据。撤销日志存在于撤销日志片段中，这些片段包含于回滚片段中。

8. 每个表一个文件的表空间 每个表一个文件的表空间是指每个单独的表空间创建在自身的数据文件中，而不是系统表空间中。这个功能通过 innodb_file_per_table 配置项开启。每个表空间由一个单独的. ibd 数据文件代表，该文件默认被创建在数据库目录中。

9. 通用表空间 使用 CREATE TABLESPACE 语法创建共享的 InnoDB 表空间。通用表空间可以创建在 MySQL 数据目录之外能够管理多个表并支持所有行格式的表。

10. 撤销表空间 撤销表空间由一个或多个包含撤销日志的文件组成。撤销表空间的数量由 innodb_undo_tablespaces 配置项配置。

11. 临时表空间 用户创建的临时表空间和基于磁盘的内部临时表都创建于临时表空间。innodb_temp_data_file_path 配置项定义了相关的路径、名称、大小和属性。如果该值为空，默认会在 innodb_data_home_dir 变量指定的目录下创建一个自动扩展的数据文件。

12. 重做日志 重做日志是基于磁盘的数据结构，在崩溃恢复期间使用，用来纠正数据。正常操作期间，重做日志会将请求数据进行编码，这些请求会改变 InnoDB 表数据。遇到意外崩溃后，未完成的更改会自动在初始化期间重新进行。

### 1.3、MyISAM 引擎 

#### 1.3.1、MyISAM 引擎介绍 

**MyISAM：**不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时 InnoDB 要维护 MVCC 一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。

MyISAM 索引文件在数据库中存放的对应表的磁盘文件有 *.frm，*.MYD，*.MYI 结尾的三个文件；

*   frm 文件是存放的表结构，表的定义信息；
*   MYD 文件是存放着表中的数据；
*   MYI 文件存放着表的索引信息；

**MyISAM 特点：**

*   MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数 (GIS) 等，但 MyISAM **不支持事务、行级锁、外键**，有一个毫无疑问的缺陷就是**崩溃后无法安全恢复**。
*   5.5 之前默认的存储引擎
*   优势是**访问的速度快**，对事务完整性没有要求或者以 SELECT、INSERT 为主的应用
*   针对**数据统计有额外的常数存储**。故而 count(*) 的查询效率很高
*   表名. frm 存储表结构；表名. MYD 存储数据 (MYData)；表名. MYI 存储索引 (MYIndex)
*   应用场景：**只读应用或者以读为主的业务**

#### 1.3.2、InnoDB 对比 MyISAM

**InnoDB：**支持外键和事务，行锁适合高并发，缓存索引和数据，内存要求高（因为要缓存索引和记录），适合存大数据量，增删改性能更优（行级锁高并发），耗费磁盘（因为有多个非聚簇索引，索引可能比记录空间还大）。

**MyISAM：**不支持外键和事务，表锁不适合高并发，缓存索引和数据地址，内存要求低（因为不用缓存记录），查询性能更优（因为查询时 InnoDB 要维护 MVCC 一致，而且多缓存了记录），节省磁盘（因为磁盘不存完整记录）。

<table border="1" cellspacing="0"><tbody><tr><td><p><strong><span>对比</span></strong></p></td><td><p><strong><span>InnoDB</span></strong></p></td><td><p><strong><span>MyISAM</span></strong></p></td></tr><tr><td><p><span>特点</span></p></td><td><p><span>支持外键和事务</span></p></td><td><p><span>不支持外键和事务</span></p></td></tr><tr><td><p><span>行表锁</span></p></td><td><p><span>行锁，操作时只锁某一行，不对其它行有影响， 适合高并发的操作</span></p></td><td><p><span>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</span></p></td></tr><tr><td><p><span>缓存</span></p></td><td><p><span>缓存索引和数据，对内存要求较高，而且内存大小对性能有决定性的影响</span></p></td><td><p><span>只缓存索引，不缓存真实数据</span></p></td></tr><tr><td><p><span>关注点</span></p></td><td><p><span>事务：并发写、事务、更大资源</span></p></td><td><p><span>性能：节省资源、消耗少、简单业务、查询快</span></p></td></tr><tr><td><p><span>默认使用</span></p></td><td>5.5 及其之后</td><td><p>5.5 之前</p></td></tr></tbody></table>

### 1.4、其他引擎

*   Archive 引擎：用于数据存档。非常适合存储大量的独立的，作为历史记录的数据，因为它们不经常被读取。它 拥有高效的插入速度，但其对查询的支持相对较差。
*   Blackhole 引擎：丢弃写操作，读操作会返回空内容
*   CSV 引擎：存储数据时，以逗号分隔各个数据项
*   Memory 引擎：置于内存的表。将所有数据存储在 RAM 中，以便在需要快速查找非关键数据的环境中进行快速访问，以前被称为 HEAP 引擎。
*   Federated 引擎：访问远程表。提供连接单独的 MySQL 服务器，从多个物理服务器创建一个逻辑数据库的能力，非常适合分布式或数据集市环境。
*   Merge 引擎：管理多个 MyISAM 表构成的表集合
*   NDB 引擎：MySQL 集群专用存储引擎。高冗余的存储引擎，用多台数据机器联合提供服务以提高整体性能和安全性。适合数据量大，安全和性能要求高的应用。

## 二、索引

### 2.1、介绍 

MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL **高效获取数据**的数据结构。

索引是一种**用于快速查询的排好序的数据结构**。

索引的本质：索引是**数据结构**。你可以简单理解为 “**排好序**的快速查找数据结构”，满足特定查找算法。这些数据结构以某种方式指向数据， 这样就可以在这些数据结构的基础上实现高级查找算法。

索引是在**存储引擎中实现**的，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。**innoDB** 存储引擎的索引是 **B + 树**。同时，存储引擎可以定义每个表的 最大索引数和最大索引长度。所有存储引擎支持每个表至少 16 个索引，总索引长度至少为 256 字节。有些存储引擎支持更多的索引数和更大的索引长度。

**优点：** 

（1）类似大学图书馆建书目索引，**提高数据检索的效率**，降低数据库的 IO 成本，**减少磁盘 I/O 次数**，这也是创建索引最主要的原因。

（2）通过创建**唯一索引**，可以保证数据库表中每一行数据的唯一性。

（3）在实现数据的参考完整性方面，可以**加速表和表之间的连接**。换句话说，对于有依赖关系的子表和父表**联合查询**时，可以提高查询速度。

（4）在使用**分组和排序**子句进行数据查询时，可以**显著提高查询速度**，因为索引是 “排好序的”，减少查询中分组和排序的时间，降低了 CPU 的消耗。

**缺点**

增加索引也有许多不利的方面，主要表现在如下几个方面：

（1）创建索引和维护索引要耗费时间，并且随着数据量的增加，所**耗费的时间**也会增加。

（2）索引需要**占磁盘空间**，除了**数据表**占数据空间之外，**每一个索引**还要占一定的物理空间， 存储在磁盘上，如果有大量的索引，索引文件就可能比数据文件更快达到最大文件尺寸。

（3）虽然索引大大提高了查询速度，同时却会**降低更新表的速度**。当对表中的数据进行**增加、删除和修改的时候**，**索引**也要动态地**维护**，这样就降低了数据的维护速度。

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

### 2.2、B + 树

#### 2.2.1、B + 树介绍

B + 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B + 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B + 树元素自底向上插入，最底层是 0 层，这与二叉树恰好相反。 

**m 阶 B + 树有如下特征:** 

1.  每个非叶节点关键字个数和孩子个数相等；
2.  根结点关键字个数 2 到 m，非跟结点关键字个数⌈m/2⌉到 m；
3.  所有叶子在同一层；

 **B + 树结构：**

![](<assets/1740030616742.png>)

数的层数越低，IO 次数越少，查询越快。 

InnoDB 的 B + 树索引的注意事项：

1. 根页面位置万年不动  
2. 内节点中目录项记录的唯一性  
3. 一个页面最少存储 2 条记录 

真实一个数据页可以存 100 条记录， 一个目录页能存 1000 条数据；4 层 B + 树能存一千万条数据，我们用到的 B + 树都不会超过 4 层，每个页内部可以用二分查找更快查找。

InnoDB 非聚簇索引情况：

InnoDB **页的大小为 16KB**，一般表的**主键**类型为 INT(占用 4 个字节) 或 **BIGINT** (占用 **8 个字节**)，**指针类型**也一般为 4 或 **8 个字节**，也就是说一个页 (B+Tree 中的一个节点) 中大概存储 **16KB/(8B+8B)=1K 个键值** (因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个**深度为 3** 的 B+Tree 索引可以维护 10^3*10^3*10^3= **1 亿条记录** (这里假定一个数据页也存储 10A3 条行记录数据了)

实际情况中每个节点可能不能填充满，因此在数据库中，**B+Tree 的高度一般都在** **2~4 层**。MySQL 的 lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 **1~3 次磁盘 IO 操作**（根节点被缓存，不算 IO 次数）。

**数据页大小：**

MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。

InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 `innodb_page_size` 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。

#### 2.2.2、演示 innoDB 的 B + 树聚簇索引，存储数据和目录

每条记录是 Compact 行格式：

```
CREATE TABLE index_demo(
 c1 INT,
 c2 INT,
 c3 CHAR(1),
 PRIMARY KEY(c1)
 ) ROW_FORMAT = Compact;
```

![](<assets/1740030616973.png>)

**演示：**假设一个数据页只能存三条数据，一个目录页只能存四条数据，下面是存储状态： 

**单个目录（两层 B + 树）：** 

![](<assets/1740030617257.png>)

 **大目录嵌套多个小目录（3 层 B + 树）：**

![](<assets/1740030617498.png>)

### 2.3、innoDB 的索引方案

#### 2.3.1、聚簇索引

聚族索引并不是一种单独的索引类型，而是一种**数据存储方式** (基于主键映射目录和排序的 B + 树，所有的**用户记录**都存储在了**叶子节点**)，也就是所谓的**索引即数据**（因为**记录**就**存**在 B + 树**叶节点**），数据即索引。 

![](<assets/1740030617606.png>)

**特点：**

1. 使用记录**主键值的大小**进行各层之间的映射、层内的排序，这包括三个方面的含义：

*   **页内的记录**是按照主键的大小顺序排成一个**单向链表**。
*   各个存放用户**记录**的**页**也是**根据**页中用户记录的**主键大小**顺序排成一个**双向链表**。
*   存放**目录**项记录的页分为不同的层次，在同一层次中的**页**也是根据页中目录项记录的**主键大小**顺序排成一个**双向链表**。

2. B + 树的**叶子节点**存储的是**完整的用户记录**。

所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）。

**优点：**

*   **数据访问更**快，因为聚簇索引将索引和数据保存在**同一个 B + 树**中，因此从聚簇索引中获取数据比非聚簇索引更快
*   聚簇索引对于**主键的排序查找和范围查找**速度非常**快**
*   按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以**节省**了大量的 **io** 操作。

**缺点：**

*   **插入速度严重依赖于插入顺序**，按照主键的**顺序插入是最快**的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个**自增**的 ID 列为**主键**
*   **更新主键的代价很高**，因为将会导致被更新的行移动。因此，对于 InnoDB 表，我们一般定义**主键为不可更新**
*   二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据

#### 2.3.2、非聚簇索引（又称辅助索引、二级索引）

聚簇索引基于主键映射目录和页内页间排序，查询条件为主键时才有用。

想**查第二列**时，就得新创建一个 B + 树，也就是**非聚簇索引 B + 树**，它基于非主键列映射目录和排序，叶节点存非主键字段的值和主键字段的值。通过第二列查到了主键值，再**回表**（回到聚簇索引的表）根据主键值查完整记录。

非聚簇索引是一种**数据存储方式** (基于**非主键字段**映射目录和排序的 B + 树，**叶节点存非主键字段的值和主键字段的值**)。

**注意：innoDB 主键建议使用自增策略，从 0 开始。因为：**

*   innoDB 的主键不建议过长，因为每个二级索引都要存主键，主键过长会耗费磁盘空间和性能（每个数据页只能 16KB，主键空间占多会导致每页存记录个数变少，导致 B + 树层级变深）；
*   B + 树插入速度严重依赖于插入顺序，非单调主键会使 B + 树频繁分裂调整为自增顺序，性能变差。

实际中，一个 MySQL 表会有一个聚簇索引用于查主键或者回表，有多个非聚簇索引（辅助索引、二级索引）用于查非主键字段。

![](<assets/1740030617691.png>)

**为什么非聚簇索引 B + 树的叶节点不存完整记录，还要回表多此一举呢？**

如果表中有 100 列，那就需要 99 个非聚簇索引，要是都存完整记录，那就太浪费磁盘空间了。

#### 2.3.3、聚簇索引和非聚簇索引区别

1.  **叶节点：聚簇索引**的 **叶子节点** 存储的就是我们的 **数据记录**，**非聚簇索引**的**叶子节点**存储的是 **数据位置** 。非聚簇索引不会影响数据表的物理存储顺序。
2.  **数量：一个表**只能有**一个聚簇索引**，因为只能有一种排序存储的方式，但可以有**多个非聚簇索引**，也就是多个索引目录提供数据检索。
3.  **效率：**使用**聚簇索引**的时候，数据的**查询效率高** ，但如果对数据进行**插入，删除，更新**等操作，效率会比非聚簇索引**低**。因为聚簇索引存的完整记录，移动起来慢；

#### 2.3.4、联合索引

我们也可以同时以多个列的大小作为排序规则，也就是同时为**多个列建立非聚簇索引**。

比方说我们想让 B + 树按照 c2 和 c3 列的大小进行排序，这个包含两层含义：

*   每个目录记录包括 c2 字段、c3 字段、页码，每个用户记录包括 c2 字段、c3 字段、主键；
*   先把各个记录和页按照 **c2 列进行排序；**
*   在记录的 **c2 列相同**的情况下，采用 **c3 列进行排序**

![](<assets/1740030617913.png>)

**注意：**

以 c2 和 c3 列的大小为排序规则建立的 B + 树称为联合索引，**本质上**也是一个**非聚簇索引**。它的意思与分别为 c2 和 c3 列分别建立索引的表述是不同的，不同点如下：

*   建立**联合索引**只会建立如上图一样的 **1 棵 B + 树**。
*   为 c2 和 c3 列**分别建立索引**会分别以 c2 和 c3 列的大小为排序规则建立 **2 棵 B + 树**。

### 2.4、MyISAM 的索引方案

MyISAM 引擎使用 B+Tree 作为索引结构，**叶子节点**的 data 域**存**放的是待查询字段和数据记录的**地址**。

MyISAM 引擎没有二级索引，只有聚簇索引。

![](<assets/1740030618146.png>)

### 2.5、MyISAM 与 InnoDB 对比

MyISAM 的索引方式都是 “非聚簇” 的，与 InnoDB 包含 1 个聚簇索引是不同的。

**① 查找次数：**在 **InnoDB** 存储引擎中，我们只需要根据主键值对聚簇索引进行**一次查找**就能找到对应的记录，而在 **MyISAM** 中却需要进行一次**回表**操作，意味着 MyISAM 中建立的索引相当于全部都是二级索引。

**② 是否 “索引即数据”：**InnoDB 的数据文件本身就是索引文件，而 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。

**③ 叶节点 data 域存储内容：**InnoDB 的非聚簇索引 data 域存储相应记录主键的值，而 MyISAM 索引记录的是待查询字段和地址。换句话说，InnoDB 的所有非聚簇索引都引用主键作为 data 域。

**④ 查询速度：MyISAM** 的**回表**操作是十分**快速**的，因为是拿着地址偏移量直接到文件中取数据的，反观 InnoDB 是通过获取主键之后再回表去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问。

**⑤ 是否必须有主键：**InnoDB 要求表必须有主键（ MyISAM 可以没有）。如果没有显式指定，则 MySQL 系统会自动选择一个可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整型。 

![](<assets/1740030618381.png>)

### 2.6、索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

**空间上的代价**

每建立一个索引都要为它建立一棵 B + 树，每一棵 B + 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B + 树由**许多数据页**组成，那就是很大的一片**存储空间**。

**时间上的代价**

每次对表中的数据进行**增、删、改**操作时，都需要去**修改各个 B + 树索引**。而且我们讲过，B + 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位， 页面分裂、页面回收等操作来维护好节点和记录的排序。如果  
我们建了许多索引，每个索引对应的 B + 树都要进行相关的维护操作，会给性能拖后腿。

### 2.7、Hash 结构

#### 2.7.1、Hash 结构介绍

哈希表 + 链地址法处理冲突 + 链表长度大于 8 时转为红黑树；

![](<assets/1740030618689.png>)

Hash 本身是一个函数，又被称为散列函数，它可以帮助我们大幅提升检索数据的效率 Hash 算法是通过某种确定性的算法 (比如 MD5、SHA1、SHA2、SHA3) 将输入转变为输出。相同的输入永远可以得到相同的输出，假设输入内容有微小偏差，在输出中通常会有不同的结果。

**优点：**增删改查时间复杂度 O（1），从效率上来看，比 B + 树快；

**缺点：**范围查找效率差，退化成 O（n）；排序效率极慢，数据存储没有顺序；每个节点是联合所有字段计算哈希值，无法对单独一个字段索引；不建议重复值多的情况使用，冲突时要不断比较整理链地址或红黑树耗费时间；

#### 2.7.2、**innoDB 自适应的哈希索引**

**innoDB** 不支持哈希索引，但支持**自适应的哈希索引**。如果某个数据**经常被访问**，当满足一定条件的时候，就会将这个**数据页的地址存放到 Hash 表**中。这样下次查询的时候，就可以**直接找到**这个页面的所在位置。这样让 B+ 树也具备了 Hash 索引的优点。

![](<assets/1740030618996.png>)

#### **2.7.3、Hash 索引与 B+ 树索引的区别**

1、Hash 索引**不能进行范围查询**，而 B+ 树可以。这是因为 Hash 索引指向的数据是**无序的**，而 B+ 的叶子节点是个有序的链表。

2、Hash 索引 **不支持联合索引的最左侧原则** (即联合索引的部分索引无法使用)，而 B+ 树可以。对于联合索引来说，Hash 索引在计算 Hash 值的时候是将**索引键合并**后再一起**计算 Hash 值**，所以不会针对每个索引单独计算 Hash 值。因此如果用到联合索引的一个或者几个索引时，联合索引无法被利用。

3、Hash 索**不支持 ORDER BY 排序**，因为 Hash 索引指向的数据是**无序的**，因此无法起到排序优化的作用，而 B+ 树索引数据是有序的，可以起到对该字段 ORDER BY 排序优化的作用。同理，我们也无法用 Hash 索引进行 模糊查询，而 B+ 使用 LKE 进行模糊查询的时候，LIKE 后面后模糊查询 (比如 % 结尾) 的话就可

### 2.8、B 树

#### 2.8.1、介绍 

B 树的英文是 Balance Tree，也就是 **多路平衡查找树**。简写为 B-Tree (注意横杠表示这两个单词连起来的意思，不是减号)。它的高度远小于平衡二叉树的高度，毕竟是多叉不是二叉。

B 树作为多路平衡查找树，它的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶。每个磁盘块中包括了**关键字和子节点的指针**。如果一个磁盘块中包括了 **x 个关键字**，那么**指针数就是 x+1**（例如节点有 17 和 35 两个关键字，它的三个子节点主键值范围分别是小于 17、17~35 之间、大于 35）。对于一个 100 阶的 B 树来说，如果有 3 层的话最多可以存储约 100 万的索引数据。

![](<assets/1740030619262.png>)

**小结：**

1.B 树在插入和删除节点的时候如果导致树不平衡，就通过**自动调整节点**的位置来保持树的**自平衡.**

2. 关键字集合分布在整棵树中, 即**叶子节点和非叶子节点都存放数据**。搜索有可能在非叶子节点结束

3. 其搜索性能等价于在关键字全集内做一次二分查找。 

#### **2.8.2、B+ 树和 B 树的差异**

1. 非叶节点的关键字数量：k 阶树，B + 树非叶节点有 k 个值、k 个孩子，B 树非叶节点有 k-1 个值、k 个孩子；

2. 记录存储位置：B + 树记录全存在叶节点，B 树记录存在所有节点；

3. 非叶节点功能：B + 树非叶节点存索引，B 树非叶节点存记录；

4. 叶子结点之间关系：B + 树所有叶子节点构成一个有序双向链表；B 树叶节点之间没指针，只是有序；

B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。

但 B 树和 B + 树各有自己的应用场景，不能说 B + 树完全比 B 树好，反之亦然。

**B + 树中间结点不直接存储数据，好处：**

查询效率更高（比 B 树矮胖），IO 次数也少，更稳定，查询范围也更大。

**为了减少 IO，索引树会一次性加载吗？**

不会，会逐一加载数据页，先加载大目录页、再加载小目录页、再加载记录页。 

1.  数据库索引是存储在磁盘上的，如果数据量很大，必然导致索引的大小也会很大，**超过几个 G**。
2.  当我们利用索引查询时候，是不可能将全部几个 G 的索引都加载进内存的，我们能做的只能是: **逐一加载每一个磁盘页**，因为磁盘页对应着索引树的节点。

**B + 树的存储能力如何? 为何说一般查找行记录，最多只需 1~3 次磁盘 IO**

**lnnoDB** 存储引擎中**页**的大小为 **16KB**，一般表的主键类型为 INT(占用 4 个字节) 或 **BIGINT (占用 8 个字节)**，指针类型也一般为 4 或 8 个字节，也就是说一个页 (B+Tree 中的一个节点) 中大概存储 16KB/(8B+8B)=1K 个键值 (因为是估值，为方便计算，这里的 K 取值为 10^3。也就是说一个**深度为 3** 的 B+Tree 索引可以维护 10^3*10^3*10^3= **1 亿条记录** (这里假定一个数据页也存储 10A3 条行记录数据了)

实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 lnnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多**只需要 1~3 次磁盘 IO 操作**（根节点被缓存，不算 IO 次数）

### 2.9、红黑树

**数据库为什么不用红黑树而用 B + 树？** 

因为 B + 树是多叉，红黑树是二叉，B + 树更矮胖，查询性能更高，IO 次数更少。

**红黑树：** 近似平衡二叉树**，**左右子树高差有可能大于 1，查找效率略低于平衡二叉树，但增删效率高于平衡二叉树，适合频繁插入删除。

*   结点非黑即红；
*   根结点是黑色，叶节点是黑色空节点（常省略）；
*   任何相邻节点不能同时为红色；
*   从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点；
*   查询性能稳定 O(logN)，高度最高 2log(n+1)；

![](<assets/1740030619488.png>)

## 三、innoDB 数据存储结构

### 3.1、页

#### 3.1.1、页：数据库的基本存储单位

页是**磁盘与内存交互基本单位**。

InnoDB 将数据划分为若千个页，InnoDB 中页的大小**默认为 16KB**

以页作为磁盘和内存之间交互的基本单位，也就是**一次最少**从磁盘中读取 **16KB 的内容**到内存中，一次最少把内存中的 16KB 内容刷新到磁盘中。也就是说，在数据库中，不论读一行，还是读多行，都是将这些**行所在的页进行加载**。

也就是说，**数据库**管理存储空间的**基本单位是页** (Page) ，数据库 I/0 操作的最小单位是页。一个页中可以存储多个行记录。

记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取 (也就是一次 /0 操作) 只能处理一行数据，效率会非常低。

![](<assets/1740030619731.png>)

#### 3.1.2、**数据页的大小**

MyISAM 的数据页大小是固定的，是 1KB，也就是说，MyISAM 存储引擎的数据都是以 1KB 的块进行管理的。

InnoDB 存储引擎的数据页大小是可调的，默认是 16KB。在 MySQL 5.7 版本之前，InnoDB 的数据页大小默认是 8KB。可以通过参数 innodb_page_size 来设置 InnoDB 的数据页大小，取值范围是 4KB、8KB、16KB 和 32KB。

#### 3.1.3、**页结构**

页 a、页 b、页 c... 页 n 这些页可以 **不在物理结构上相连**，只要通过**双向表**相关联即可。每个数据页中的**记录**会按照主键值从小到大的顺序组成一个**单向链表** ，每个数据页都会为存储在它里边的记录生成一个**页目录**，在通过主键**查找某条记录**的时候可以在页目录中**使用二分法**（有序表可以用二分法）快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。

不同的数据库管理系统 (简称 DBMS) 的页大小不同。比如在 MySQL 的 nnoDB 存储引擎中，默认页的大小是 16KB。**查看页大小:**

```
show variables like '%innodb_page_size%' 
```

**页的内部结构：**

页如果按类型划分的话，常见的有 **数据页** (保存 B+ 树节点)、**系统页**、**Undo 页**和 **事务数据页** 等。数据页是我们最常使用的页。

数据页的 16KB 大小的**存储空间**被划分为七个部分，分别是文件头 (File Header)、页头 (Page Header)、最大最小记录 (Infimum+supremum) 、用户记录 (User Records) 、空闲空间 (Free Space)、页目录 (PageDirectory) 和文件尾 (File Tailer) 。

页结构的示意图如下所示:

![](<assets/1740030620042.png>)

这 7 个部分作用分别如下，我们简单梳理如下表所示 

![](<assets/1740030620429.png>)

我们可以把这 7 个结构分成 3 个部分：

第 1 部分: File Header (文件头部) 和 File Trailer(文件尾部)

第 2 部分: User Records (用户记录)、最大最小记录、Free Space(空闲空间)

第 3 部分: Page Directory (页目录)、Page Header(页面头部) 

### 3.2、行、页、区、段、表空间的关系

另外在数据库中，还存在着**区** (Extent)、**段** (Segment) 和**表空间** (Tablespace) 的概念。

行、页、区、段、表空间的关系如下图所示:

![](<assets/1740030620731.png>)

**区** (Extent) 是比页大一级的存储结构，在 innoDB 存储引擎中，**一个区会分配 64 个连续的页**。因为 nnoDB 中的页大小默认是 16KB，所以一个区的大小是 64*16KB= **1MB**。

**段** (Segment) **由一个或多个区组成**，区在文件系统是一个**连续分配的空间** (在 innoDB 中是连续的 64 个页) 不过在段中不要求区与区之间是相邻的。段是数据库中的**分配单位** ，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

**表空间** (Tablespace) 是一个**逻辑容器**，表空间**存储的对象是段**，在一个表空间中可以有一个或多个段，但是一个段只能属干一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为 **系统表空间、用户表空间、撤销表空间、 临时表空间** 等。 

### 3.3、innoDB 行格式

#### 3.3.1、四种行格式

我们平时的数据以行为单位来向表中插入数据，这些**记录**在磁盘上的**存放方式**也被称为**行格式**（也叫记录格式）。

InnoDB 存储引擎设计了 4 种不同类型的行格式，分别是 **Compact、Redundant、Dynamic、Compressed** 行格式。

**Compact** 

在 MySQL 5.1 版本中，默认设置为 Compact 行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。

![](<assets/1740030620959.png>)

![](<assets/1740030621238.png>)

**Dynamic**

在 MySQL 8.0 中，默认行格式就是 Dynamic。

Dynamic、Compressed 行格式和 Compact 行格式挺像，只不过在处理行溢出数据时有分歧：

*   Compressed 和 Dynamic 两种记录格式对于存放在 BLOB 中的数据采用了完全的行溢出的方式。如图，在数据页中只存放 20 个字节的指针（溢出页的地址），实际的数据都存放在 Off Page（溢出页）中。

*   Compact 和 Redundant 两种格式会在记录的真实数据处存储一部分数据（存放 768 个前缀字节）。

**Compressed** 

Compressed 行记录格式的另一个功能就是，存储在其中的行数据会以 zlib 的算法进行压缩，因此对于 BLOB、TEXT、VARCHAR 这类大长度类型的数据能够进行非常有效的存储。

![](<assets/1740030621332.png>)

**Redundant** 

Redundant 是 MySQL 5.0 版本之前 InnoDB 的行记录存储方式，MySQL 5.0 支持 Redundant 是为了兼容之前版本的页格式。 

![](<assets/1740030621556.png>)

从上图可以看到，不同于 Compact 行记录格式，Redundant 行格式的首部是一个字段长度偏移列表，同样是按照列的顺序逆序放置的。

#### 3.3.2、**指定行格式的**命令

**查看 MySQL8 的默认行格式：**

```
SELECT @@innodb_default_row_format;
```

也可以使用如下语法查看具体表使用的行格式：

```
SHOW TABLE STATUS like '表名'\G
```

**在创建或修改表的语句中指定行格式：**

```
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
 
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

举例：

```
CREATE TABLE record_test_table (
 
    col1 VARCHAR(8),
 
    col2 VARCHAR(8) NOT NULL,
 
    col3 CHAR(8),
 
    col4 VARCHAR(8)
 
 ) CHARSET=ascii ROW_FORMAT=COMPACT;
```

向表中插入两条记录：

```
INSERT INTO record_test_table(col1, col2, col3, col4) 
 
VALUES
 
('zhangsan', 'lisi', 'wangwu', 'songhk'), 
 
('tong', 'chen', NULL, NULL);
```