---
url: https://blog.csdn.net/qq_40991313/article/details/130352271
title: MySQL 高级篇——索引的创建与设计原则_《mysql 高级篇》六、索引的创建与设计原则 - CSDN 博客
date: 2025-02-20 13:50:17
tag: 
summary: 
---
**导航：**

[【Java 笔记 + 踩坑汇总】Java 基础 + JavaWeb+SSM+SpringBoot+SpringCloud + 瑞吉外卖 / 谷粒商城 / 学成在线 + 设计模式 + 面试题汇总 + 性能调优 / 架构设计 + 源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?spm=1001.2014.3001.5501 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[一、索引的分类与使用](#t0)

[1.1 索引的分类](#t1)

[1.1.1. 普通索引](#t2)

[1.1.2. 唯一索引](#t3)

[1.1.3. 主键索引（唯一非空）](#t4)

[1.1.4. 单列索引](#t5)

[1.1.5. 多列 (组合、联合) 索引](#t6)

[1.1.6. 全文索引](#t7)

[1.1.7. 空间索引（不常用）](#t8)

[1.2 创建表的时候创建索引](#t9)

[1.2.1 约束字段会隐式自动创建索引](#t10)

[1.2.1 显式、创建表的时候创建索引](#t11)

[1.3 在已经存在的表上创建索引](#t12)

[1.4 删除索引](#t13)

[1.5 查看索引](#t14)

[二、MySQL8.0 索引新特性](#t15)

[2.1 支持降序索引](#t16)

[2.2 隐藏索引](#t17)

[三、索引的设计原则](#t18)

[3.1 适合创建索引的情况](#t19)

[3.1.1 简洁版](#t20) 

[3.1.2 详细版](#t21)

[3.2 不适合创建索引的情况](#t22)

## 一、索引的分类与使用

### 1.1 索引的分类

MySQL 的索引包括普通索引、唯一性索引、全文索引、单列索引、多列索引和空间索引等。

从**功能逻辑**上说，索引主要有 4 种，分别是**普通索引、唯一索引、主键索引、全文索引**。

按照**物理实现方式**，索引可以分为 2 种：**聚簇索引和非聚簇索引**。

按照作用**字段个数**进行划分，分成**单列索引和联合索引**。

#### **1.1.1. 普通索引**

在创建普通索引时，**不附加任何限制条件**，只是用于提高查询效率。这类索引可以创建在**任何数据类型**中，其值是否唯一和非空，要由字段本身的完整性约束条件决定。

建立索引以后，可以通过索引进行查询。例如，在表 student 的字段 name 上建立一个普通索引，查询记录时就可以根据该索引进行查询。

#### **1.1.2. 唯一索引**

使用 UNIQUE 参数可以设置索引为唯一性索引，在创建唯一性索引时，限制该**索引的值**必须是**唯一**的，但**允许有多个空值**。在一张数据表里可以有多个唯一索引。

例如，在表 student 的字段 emai1 中创建唯一性索引，那么字段 email 的值就必须是唯一的。通过唯一性索引可以更快速地确定某条记录。

**唯一约束和唯一索引的区别：**

*   唯一约束和唯一索引，都可以实现列数据的唯一，列值可以有 null。
*   **唯一约束自动创建不独立的唯一索引：**创建唯一约束，会自动创建一个同名的唯一索引，该索引**不能单独删除**，删除约束会自动删除索引。唯一约束是通过唯一索引来实现数据的唯一。
*   创建一个唯一索引，这个索引就是独立，可以单独删除。
*   如果一个列上想有约束和索引，且两者可以单独的删除。可以先建唯一索引，再建同名的唯一约束。
*   **外键必须是唯一约束：**如果表的一个字段，要作为另外一个表的外键，这个字段必须有唯一约束（或是主键），如果只是有唯一索引，就会报错。

#### **1.1.3. 主键索引（唯一非空）**

主键索引就是一种特殊的唯一性索引，在**唯一**索引的基础上增加了**不为空**的约束，也就是 NOTNULL+UNIQUE，**一张表最多只有一个主键索引**。

这是由主键索引的物理实现方式决定的，因为数据存储在文件中只能按照一种顺序进行存储。

#### **1.1.4. 单列索引**

在表中的**单个字段**上创建**索引**。单列索引**只根据该字段**进行索引。单列索引可以是普通索引，也可以是唯一性索引，还可以是全文索引。只要保证该索引只对应一个字段即可。一个表可以有多个单列索引。

#### **1.1.5. 多列 (组合、联合) 索引**

多列索引是在表的**多个字段组合**上创建一个索引。该索引指向创建时对应的多个字段，可以通过这几个字段进行查询，但是只有查询条件中使用了这些字段中的第一个字段时才会被使用。例如，在表中的字段 id、name 和 gender 上建立一个多列索引 idx_id_name_gender，只有在查询条件中使用了字段 id 时该索引才会被使用。使用组合索引时**遵循最左前缀集合**。

**最左前缀集合：**指的是由多个列组成的联合索引，在查询时只会使用最左边的几个列进行索引查询。具体来说，如果一个联合索引包含了列 A、B 和 C 三列，那么 MySQL 只能使用 A、A+B 或者 A+B+C 这三种方式进行查询。而不能仅仅使用 B 或者 C 列进行查询。

#### **1.1.6. 全文索引**

全文索引 (也称全文检索) 是目前搜索引擎使用的一种关键技术。它能够利用 **[分词术]** 等多种算法智能**分析**出文本文字中**关键词的频率和重要性**，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。全文索引非常**适合大型数据集**，对于小的数据集，它的用处比较小。

使用**参数 FULLTEXT** 可以设置索引为全文索引。在定义索引的列上支持值的全文查找，**允许**在这些索引列中插入**重复值和空值**。全文索引只能创建在 CHAR、VARCHAR 或 TEXT 类型及其系列类型的字段上，查询数据量较大的字符串类型的字段时，使用全文索引可以提高查询速度。例如，表 student 的字段 information 是 TEXT 类型该字段包含了很多文字信息。在字段 information 上建立全文索引后，可以提高查询字段 information 的速度.

全文索引典型的有两种类型: **自然语言的全文索引和布尔全文索引**

自然语言搜索引擎将计算每一个文档对象和查询的**相关度**。这里，相关度是基于匹配的关键词的个数，以及关键词在文档中出现的次数。在整个索引中**出现次数越少**的词语，匹配时的**相关度就越高**。相反，非常常见的单词将不会被搜索，如果一个词语的在超过 50% 的记录中都出现了，那么自然语言的搜索将不会搜索这类词语。

MySQL 数据库从 3.23.23 版开始支持全文索引，但 MySQL5.6.4 以前只有 Myisam 支持，5.6.4 版本以后 innodb 才支持，但是官方版本不支持中文分词，需要第三方分词插件。在 **5.7.6 版本**，MySQL 内置了 **ngram 全文解析器**，用来**支持亚洲语种的分词**。测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。

随着大数据时代的到来，关系型数据库应对全文索引的需求已力不从心，逐渐被 solrElasticSearch 等专门的搜索引擎所替代。

#### **1.1.7. 空间索引（不常用）**

使用**参数 SPATIAL** 可以设置索引为空间索引。空间索引只能建立在**空间数据类型**上，这样可以提高系统获取空间数据的效率。MySQL 中的空间数据类型包括 GEOMETRY、POINT、LINESTRING 和 POLYGON 等。目前**只有 MyISAM 存储引擎支持空间检索**，而且**索引的字段不能为空值**。对于初学者来说，这类索引**很少会用到**。

**小结：不同的存储引擎支持的索引类型也不一样**

InnoDB：支持 B-tree、Full-text 等索引，不支持 Hash 索引；MyISAM：支持 B-tree、Full-text 等索引，不支持 Hash 索引；Memory：支持 B-tree、Hash 等索引，不支持 Full-text 索引 NDB：支持 Hash 索引，不支持 B-tree、Full-text 等索引；Archive：不支持 B-tree、Hash、Full-text 等索引；

### 1.2 创建表的时候创建索引

MySQL 支持多种方法在单个或多个列上创建索引: 在**创建表**的定义语句 **CREATE TABLE** 中指定索引列，使用 **ALTER TABLE** 语句在**存在的表上创建索引**，或者使用 **CREATE INDEX** 语句在已**存在的表上添加索引**。

#### 1.2.1 约束字段会隐式自动创建索引

使用 CREATE TABLE 创建表时，除了可以定义列的数据类型外，还可以定义**主键约束、外键约束或者唯一性约束**而不论创建哪种约束，在定义**约束的同时相当于**在指定列上**创建**了一个**索引**。

例如下面部门员工表的主键、唯一字段都**隐式的**创建了索引： 

```
CREATE TABLE dept(
    dept_id INT PRIMARY KEY AUTO_INCREMENT,    #主键会自动创建主键索引
    dept_name VARCHAR(20)
);
CREATE TABLE emp(
    emp_id INT PRIMARY KEY AUTO_INCREMENT,
    emp_name VARCHAR(20) UNIQUE,    #唯一约束会自动创建唯一索引
    dept_id INT,
    CONSTRAINT emp_dept_id_fk FOREIGN KEY(dept_id) REFERENCES dept(dept_id)
);
```

#### 1.2.1 显式、创建表的时候创建索引

```
CREATE TABLE 表名 [字段名 字段类型]
[UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY] [索引名] (字段名 [length]) [ASC |
DESC]
```

*   **UNIQUE 、FULLTEXT 和 SPATIAL 为可选参数**，分别表示唯一索引、全文索引和空间索引；
*   **INDEX 与 KEY 为同义词**，两者的作用相同，用来指定创建索引；
*   index_name 指定索引的名称，为可选参数，如果不指定，那么 MySQL 默认 col_name 为索引名；
*   col_name 为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；
*   **length** 为可选参数，表示**索引的长度**，只有字符串类型的字段才能指定索引长度；
*   **ASC 或 DESC** 指定**升序或者降序的索引值存储**。

**1. 创建普通索引**

在 book 表中的 year_publication 字段上建立普通索引，SQL 语句如下：

```
CREATE TABLE book(
    book_id INT ,
    book_name VARCHAR(100),
    authors VARCHAR(100),
    info VARCHAR(100) ,
    comment VARCHAR(100),
    year_publication YEAR,    #被索引的字段
    INDEX(year_publication)    #普通索引，不附加任何限制条件；不指定索引名，那么默认字段名为索引名；
);
```

**2. 创建唯一索引**

```
CREATE TABLE test1(
id INT NOT NULL,    #被索引的字段
name varchar(30) NOT NULL,    
UNIQUE INDEX uk_idx_id(id)    #索引的值必须是唯一的，但允许有空值。
);
```

**3. 主键索引** 

设定为主键后数据库会自动建立索引，innodb 为聚簇索引，语法：

随表一起建索引：

```
CREATE TABLE student (
id INT(10) UNSIGNED AUTO_INCREMENT ,    #被索引字段
student_no VARCHAR(200),
student_name VARCHAR(200),
PRIMARY KEY(id)    #主键索引，唯一不为空
);
```

删除主键索引：

```
ALTER TABLE student
drop PRIMARY KEY ;
```

修改主键索引：必须先删除掉 (drop) 原索引，再新建 (add) 索引

**4. 创建单列索引**

```
CREATE TABLE test2(
id INT NOT NULL,
name CHAR(50) NULL,
INDEX single_idx_name(name(20))
);
```

**5. 创建组合索引**

在表中的 id、name 和 age 字段上建立组合索引 

```
CREATE TABLE test3(
id INT(11) NOT NULL,
name CHAR(30) NOT NULL,
age INT(11) NOT NULL,
info VARCHAR(255),
INDEX multi_idx(id,name,age)
);
```

**6. 创建全文索引**

在表中的 info 字段上建立全文索引

```
CREATE TABLE test4(
id INT NOT NULL,
name CHAR(30) NOT NULL,
age INT NOT NULL,
info VARCHAR(255),
FULLTEXT INDEX futxt_idx_info(info)
) ENGINE=MyISAM;    #在MySQL5.7及之后版本中可以不指定最后的ENGINE了，因为在此版本中InnoDB支持全文索引。
```

给 title 和 body 字段添加全文索引

```
CREATE TABLE articles (
id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
title VARCHAR (200),
body TEXT,
FULLTEXT index (title, body)
) ENGINE = INNODB ;
```

**演示全文索引查询：**

```
CREATE TABLE `papers` (
`id` int(10) unsigned NOT NULL AUTO_INCREMENT,
`title` varchar(200) DEFAULT NULL,
`content` text,
PRIMARY KEY (`id`),
FULLTEXT KEY `title` (`title`,`content`)
) ENGINE=MyISAM DEFAULT CHARSET=utf8;
```

全文索引用 match+against 方式查询：

```
ALTER TABLE table_name ADD [UNIQUE | FULLTEXT | SPATIAL] [INDEX | KEY]
[index_name] (col_name[length],...) [ASC | DESC]
```

回顾 like 方式的的查询：

```
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (col_name[length],...) [ASC | DESC]
```

**注意点**

1. 使用全文索引前，搞清楚版本支持情况；  
2. 全文索引比 like + % 快 N 倍，但是可能存在精度问题；  
3. 如果需要全文索引的是大量数据，建议先添加数据，再创建索引。

### 1.3 在已经存在的表上创建索引

在已经存在的表中创建索引可以使用 **ALTER TABLE** 语句或者 **CREATE INDEX** 语句。

**方法一：** 使用 **ALTER TABLE** 语句创建索引 ALTER TABLE 语句创建索引的基本语法如下：

```
CREATE INDEX idx_age_classid_name ON student(age,classId,name);
SHOW INDEX FROM student;
```

**方法二（推荐）：**使用 **CREATE INDEX** 创建索引 CREATE INDEX 语句可以在已经存在的表上添加索引，在 MySQL 中，CREATE INDEX **被映射到一个 ALTER TABLE 语句上**，基本语法结构为：

```
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

**示例：**在学生表上，给年纪、班级字段创建联合索引

```
create table shop(address varchar(120) not null);
alter table shop add index(address(12));
```

### 1.4 删除索引

1. 使用 ALTER TABLE 删除索引 ALTER TABLE 删除索引的基本语法格式如下：

```
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10))
);
```

 2. 使用 DROP INDEX 语句删除索引 DROP INDEX 删除索引的基本语法格式如下：

```
CREATE TABLE repeat_index_demo (
    col1 INT PRIMARY KEY,
    col2 INT,
    UNIQUE uk_idx_c1 (col1),
    INDEX idx_c1 (col1)
);
```

**提示**

删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成  
索引的所有列都被删除，则整个索引将被删除。

### 1.5 查看索引

```
SHOW INDEX FROM student;
```

 只有主键索引：

![](<assets/1740030617617.png>)

创建联合索引并查看：

```
CREATE INDEX idx_age_classid_name ON student(age,classId,name);
SHOW INDEX FROM student;
```

![](<assets/1740030617804.png>)

## 二、MySQL8.0 索引新特性

### 2.1 支持降序索引

创建降序的外键索引：

```
CREATE TABLE ts1(a int,b int,index idx_a_b(a,b desc));
```

在 MySQL 8.0 版本中查看数据表 ts1 的结构，可以发现是降序，结果如下：

![](<assets/1740030618011.png>)

 在 MySQL 5.7 版本中查看数据表 ts1 的结构，索引仍然是默认的升序，结果如下：

![](<assets/1740030618299.png>)

### 2.2 隐藏索引

在 **MySQL 5.7 版本及之前**，只能通过**显式**的方式**删除索引**。此时，如果发现**删除索引后出现错误**，又**只能**通过**显式创建索引**的方式**将删除的索引创建回来**。如果数据表中的数据量非常大，或者数据表本身比较大，这种操作就会消耗系统过多的资源，操作成本非常高。

将待删除的索引设置为隐藏索引，mysql 确认删除索引后不会出错后再彻底删除索引。

从 MySQL 8.x 开始支持**隐藏索引**（invisible indexes） ，只需要将**待删除的索引设置为隐藏索引**，使**查询优化器不再使用这个索引**（即使使用 force index（强制使用索引），优化器也不会使用该索引），确认将索引设置为隐藏索引后系统不受任何影响，就可以**彻底删除索引**。这种通过**先将索引设置为隐藏索引，再删除索引**的方式就是软删除。

```
ALTER TABLE tablename ALTER INDEX index_name INVISIBLE; #切换成隐藏索引
ALTER TABLE tablename ALTER INDEX index_name VISIBLE; #切换成非隐藏索引
```

## 三、索引的设计原则

### 3.1 适合创建索引的情况

#### 3.1.1 简洁版 

1.  唯一特性的字段，适合创建索引
2.  频繁作为 where 条件的字段，适合创建索引
3.  经常分组或排序查询的字段，适合创建索引
4.  增改语句的查询条件字段，适合创建索引
5.  DISTINCT 字段，适合创建索引
6.  多表连接时，连接表数量别超过 3 张，where 字段和连接字段，适合创建索引
7.  数据范围越小的字段，越适合创建索引
8.  很长的 varchar 字段，适合创建前缀索引
9.  区分度高的字段，适合作为索引
10.  联合索引，将频繁查询的列放到左侧
11.  多个字段都要创建索引时，联合索引优于单值索引
12.  单张表索引数建议别超过 6 个

#### 3.1.2 详细版

**1. 唯一特性的字段，适合创建索引**

业务上具有唯一特性（例如唯一约束、主键约束）的字段，**即使是组合字段**，也必须建成唯一索引。（来源：Alibaba）

说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但**提高查找速度**是明显的。

**2. 频繁作为 where 条件的字段，适合创建索引**

某个字段在 SELECT 语句的 **WHERE 条件**中经常被使用到，那么就需要给这个字段创建索引了。尤其是在**数据量大**的情况下，创建普通索引就可以**大幅提升**数据查询的**效率**。

**3. 经常分组或排序查询的字段，适合创建索引**

本身索引就已经排好序了，而且 B + 树叶节点一起组成双向链表，很适合范围查询。很适合建立索引。

索引就是让数据按照某种顺序进行存储或检索，因此当我们使用 **GROUP BY** 对数据进行分组查询，或者使用 **ORDER BY** 对数据进行排序的时候，就需要对分组或者排序的字段进行索引。

如果待**排序的列有多个**，那么可以在这些列上建立**联合索引**。

**4. 增改语句的查询条件字段，适合创建索引**

 UPDATE、DELETE 的 WHERE 条件列。对数据按照某个条件进行**查询后**再进行 **UPDATE 或 DELETE** 的操作，如果对 WHERE 字段创建了索引，就能大幅提升效率。原理是因为我们需要先根据 WHERE 条件列检索出来这条记录，然后再对它进行更新或删除。如果进行更新的时候，更新的字段是非索引字段，提升的效率会更明显，这是因为非索引字段更新不需要对索引进行维护。

**5.DISTINCT 字段，适合创建索引**

有时候我们需要对某个字段进行**去重**，使用 **DISTINCT**，那么对这个字段创建索引，也会提升查询效率。因为索引会对数据按照某种顺序进行排序，**排序后再去重**会快很多。

```
SELECT DISTINCT 字段列表 FROM 表名;
```

**6. 多表连接时，连接表数量别超过 3 张，where 字段和连接字段适合创建索引**

首先， **连接表的数量**尽量不要超过 3 张，因为每增加一张表就相当于增加了一次嵌套的循环，数量级增长会非常快，严重影响查询的效率。

其次， 对 **WHERE 条件创建索引**，因为 WHERE 才是对数据条件的过滤。如果在数据量非常大的情况下，没有 WHERE 条件过滤是非常可怕的。

最后， 对用于**连接的字段创建索引**，并且该字段在多张表中的类型必须一致。比如 course_id 在 student_info 表和 course 表中都为 int(11) 类型，而不能一个为 int 另一个为 varchar 类型。

**7. 数据范围越小的字段，越适合创建索引**

我们这里所说的类型大小指的就是该类型表示的**数据范围的大小**。

我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TINYINT、MEDIUMINT、INT、BIGINT 等，它们占用的存储空间依次递增，能表示的整数范围当然也是依次递增。如果我们想要对某个整数列建立索引的话，在表示的整数范围允许的情况下，**尽量让索引列使用较小的类型**，比如我们**能使用 INT 就不要使用 BIGINT**，能使用 MEDIUMINT 就不要使用 INT。这是因为:

**数据类型越小，**在查询时进行的**比较操作越快**

数据类型越小，索引占用的**存储空间就越少**，在一个数据页内就可以放下更多的记录，从而**减少磁盘 I/0** 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

这个建议对于表的**主键**来说**更加适用**，因为不仅是聚簇索引中会存储主键值，其他所有的**二级索引**的节点处都会**存储一份记录的主键值**，如果主键使用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/0。

 **8. 很长的 varchar 字段，适合创建前缀索引**

假设我们的**字符串很长**，那存储一个**字符串**就需要**占用**很大的**存储空间**。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B + 树中有这么两个问题:

B + 树索引中的记录需要把该列的完整字符串存储起来，更费时。而且字符串越长，在索引中占用的存储空间越大；

如果 B + 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。我们可以通过**截取字符串区分度高的前缀子串建立索引**，这个就叫**前缀索引**。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值。既节约空间，又减少了符串的比较时间，还大体能解决排序的问题。

**计算区分度度：**

```
count(distinct left(列名, 索引长度))/count(*)
```

left() 函数用于取字符串前缀。 

**案例：**

创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引

```
create table shop(address varchar(120) not null);
alter table shop add index(address(12));
```

问题是，截取多少呢？截取得多了，达不到节省索引存储空间的目的；截取得少了，重复内容太多，字段的散列度 (选择性) 会降低。

**计算不同的长度的区分性，通过区分度判断**  
完整字段在全部数据中的选择度：

```
select count(distinct address) / count(*) from shop;
```

通过不同长度去计算，与全表的选择性对比： 

```
count(distinct left(列名, 索引长度))/count(*)
```

**索引列前缀对排序的影响：**Alibaba《Java 开发手册》

【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，**根据实际文本区分度决定索引长度**。

说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*) 的区分度来确定。

**9. 区分度高的字段，适合作为索引**

**10. 联合索引，将频繁查询的列放到左侧**

这样也可以较少的建立一些索引。同时，由于 "最左前缀原则"，可以增加联合索引的使用率。

**11. 多个字段都要创建索引时，联合索引优于单值索引**

**12. 单张表索引数建议别超过 6 个**

在实际工作中，我们也需要注意平衡，索引的数目不是越多越好。我们需要限制每张表上的索引数量，建议单张表索引数量不超过 6 个。原因:

**-** 每个索引都需要**占用磁盘空间**，索引越多，需要的磁盘空间就越大

**-** 索引会**影响 INSERT、DELETE、UPDATE 等语句的性能**，因为表中的数据更改的同时，索引也会进行调整和更新，会造成负担。

**-** 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，会**增加 MySQL 优化器生成执行计划时间**，降低查询性能.

### 3.2 不适合创建索引的情况

**1. 在 where 中使用不到的字段，不要设置索引**

**2. 数据量小的表，不要设置索引**

在数据表中的数据行数比较少的情况下，比如不到 1000 行，是不需要创建索引的。

**3. 有大量重复数据的列上，不要设置索引**

当数据重复度大，比如**高于 10%** 的时候，也不需要对这个字段使用索引。 

例如 100 万数据量的学生表，只有 10 个男生，其他都是女生，性别字段就别设置索引。  

**4. 经常更新的表，不要创建过多索引**

第一层含义: **频繁更新的字段**不一定要创建索引。因为**更新数据**的时候，也**需要更新索引**，如果索引太多，在更新索引的时候也会造成**负担**，从而影响效率。

第二层含义: 避免对**经常更新的表**创建过多的索引，并且索引中的列尽可能少。此时，虽然提高了查询速度，同时却会**降低更新表的速度**。 

**5. 不建议用无序的值作为索引**

例如身份证、UUID(在索引比较时需要转为 ASCII，并且插入时可能造成页分裂)、MD5、HASH、无序长字符串等。

**6. 删除很少使用的索引**

表中的数据被大量更新，或者数据的使用方式被改变后，原有的**一些索引**可能**不再需要**。数据库管理员应当定期找出这些索引，将它们**删除**，从而**减少索引对更新操作的影响**。

**7. 不要定义冗余或重复的索引**

冗余索引示例：个人信息表，**联合索引最左边字段不需再创建索引**

```
CREATE TABLE person_info(
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name(10), birthday, phone_number),
    KEY idx_name (name(10))
);
```

我们知道，通过 idx_name_birthday_phone_number **联合索引**就可以对 **name 列进行快速搜索**，再创建一个**专门针对 name 列的索引就算是一个冗余索引**，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。

重复索引示例：

另一种情况，我们可能会对**某个列重复建立索引**，比方说这样：

```
CREATE TABLE repeat_index_demo (
    col1 INT PRIMARY KEY,
    col2 INT,
    UNIQUE uk_idx_c1 (col1),
    INDEX idx_c1 (col1)
);
```

我们看到，col1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是**主键本身就会生成聚簇索引**，所以定义的唯一索引和普通索引是重复的，这种情况要避免。