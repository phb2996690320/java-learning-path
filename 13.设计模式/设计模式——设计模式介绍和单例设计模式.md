>  **导航：** 
> 
> [【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?spm=1001.2014.3001.5501 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**  

[一、设计模式概述和分类](#f11cfb62)

[1.1 设计模式介绍](#3a40d984)

[1.2 设计模式分类](#c92d9d06)

[二、创建型设计模式-单例模式](#e146dbe8)

[2.1 介绍](#61a3ec66)

[2.2 八种单例模式的创建方式](#bbb7c144)

[2.2.1 饿汉式（静态常量）](#f65b0328)

[2.2.2 饿汉式（静态代码块）](#1a38ddb7)

[2.2.3 懒汉式（线程不安全）](#bbf7c195)

[2.2.4 懒汉式（线程安全，同步方法）](#348239e4)

[2.2.5 懒汉式（线程不安全，同步代码块）](#36fe8fa9)

[2.2.6 双重检查（推荐，线程安全、懒加载）](#286e0123)

[2.2.7 静态内部类（推荐）](#279d5de9)

[2.2.8 枚举（推荐）](#396a1512)

[2.2.9 JDK 源码里单例模式分析](#c4e6772a)

--

## 一、设计模式概述和分类

### 1.1 设计模式介绍

-   1）设计模式是程序员在面对同类软件工程设计问题所总结出来的有用的经验。模式不是代码，而是**某类问题的通用解决方案**，设计模式（Design pattern）代表了最佳实践。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的

-   2）设计模式的本质提高软件的**维护性、通用性和扩展性**，并降低软件的复杂度

-   3）《设计模式》是经典的书，作者是 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides Design（俗称“四人组GOF”）

-   4）设计模式并不局限于某种语言，Java、PHP、C++ 都有设计模式

### 1.2 设计模式分类

在设计模式中，通常分为三类设计模式，分别是创建型模式、结构型模式和行为型模式。

-   **创建型模式**（Creational Patterns）：主要**用于对象的创建**，包括多个不同的模式，如工厂方法模式、抽象工厂模式、建造者模式、单例模式和原型模式等。这些模式都有助于降低系统耦合度，并提高代码的可重用性和可扩展性。
    
-   **结构型模式**（Structural Patterns）：主要**用于描述对象之间的组合关系**，包括多个不同的模式，如“代理模式”、“适配器模式”、“桥接模式”、“装饰者模式”、“外观模式”、“享元模式”和“组合模式”等。这些模式可以帮助我们更好地设计程序结构，提高代码的灵活性和可维护性。
    
-   **行为型模式**（Behavioral Patterns）：主要**用于描述对象之间的通信和责任分配**，包括多个不同的模式，如“策略模式”、“模板方法模式”、“观察者模式”、“迭代器模式”、“职责链模式”、“命令模式”、“访问者模式”、“备忘录模式”和“解释器模式”等。这些模式通常用于实现不同的算法、流程和通信方式，以实现系统的更高灵活性和可维护性。
    

设计模式分三种类型

-   **创建型模式**：**单例模式、**抽象工厂模式、原型模式、**建造者模式、工厂模式**

-   **结构型模式**：**适配器模式、**桥接模式、**装饰模式**、组合模式、外观模式、享元模式、**代理模式**

-   **行为型模式**：**模版方法模式**、命令模式、访问者模式、**迭代器模式、观察者模式、**中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、**策略模式、职责链模式**（责任链模式）

> 注意：不同的书籍上对分类和名称略有差别

## 二、创建型设计模式-单例模式

### 2.1 介绍

所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对**某个类只能存在一个对象实例**，并且**该类只提供一个取得其对象实例的方法**（静态方法）

> 比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。SessionFactory 并不是轻量级的，一般情况下，**一个项目通常只需要一个 SessionFactory** 就够，这是就会使用到单例模式

**优点：**

-   节省资源：单例模式实例只有一个，可以**避免重复创建对象**，从而节省了资源，提高了系统性能。
-   管理全局变量：单例模式可以用于管理全局状态和变量，方便在整个系统中**共享数据**。
-   简化系统架构：使用单例模式可以简化系统架构，减少类的数量和接口的复杂度。

**缺点：**

1.  可能引发并发问题：单例模式在多线程中使用时，需要保证线程安全，否则可能会引发并发问题。
2.  可能增加系统复杂性：过度使用单例模式可能会增加系统复杂性，导致代码难以维护。
3.  难以调试：由于单例模式全局共享状态，可能会导致调试过程中的问题难以定位和测试。

 **注意事项和使用场景**

-   1）单例模式保证了系统内存中该类只存在一个对象，**节省了系统资源**，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能

-   2）当想实例化一个单例类的时候，必须要记住**使用相应的获取对象的方法**，而不是使用 new

-   3）单例模式使用的场景：需要**频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多但又经常用到的对象**（即：重量级对象）、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）

### 2.2 八种单例模式的创建方式

-   **1）饿汉式（静态常量）：线程安全，没用到会浪费内存。**

-   **2）饿汉式（静态代码块）：线程安全，没用到会浪费内存。**

-   3）懒汉式（线程不安全）：懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。不要用这种方式。

-   4）懒汉式（线程安全，同步方法）：线程安全，但效率低（每次获取实例都要加锁），不推荐。

-   5）懒汉式（线程不安全，同步代码块）：线程不安全，不要用这种方式。

-   **6）双重检查**

-   **7）静态内部类**

-   **8）枚举**

#### 2.2.1 饿汉式（静态常量）

线程安全，没用到会浪费内存。

**步骤：**

1.  构造器私有化（防止外部 new）
2.  **类的内部创建私有静态常对象**
3.  向外暴露一个静态的公共方法 getInstance

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部创建对象
    private static final Singleton instance = new Singleton();

    // 3、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return instance;
    }
}
```

**优缺点**

-   **优点：**这种写法比较简单，就是在**类装载的时候就完成实例化**（类变量在JVM类加载的准备、初始化阶段会赋值）。**避免了线程同步问题**

-   **缺点：**在类装载的时候就完成实例化，**没有达到 Lazy Loading 的效果**。如果从始至终从未使用过这个实例，则会造成**内存的浪费。**

-   这种方式基于 classloder 机制避免了多线程的同步问题。不过，instance 在类装载时就实例化，在单例模式中大多数都是调用getlnstance 方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 就没有达到 Lazy loading 的效果

-   结论：**这种单例模式可用，可能造成内存浪费**

#### 2.2.2 饿汉式（静态代码块）

线程安全，没用到会浪费内存。

**步骤：**

1.  构造器私有化
2.  类的内部声明私有静态对象引用
3.  **在静态代码块中实例化对象**
4.  向外暴露一个静态的公共方法

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、在静态代码块中创建对象
    static {
        instance = new Singleton();
    }

    // 4、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return instance;
    }
}
```

**优缺点**

-   1）这种方式和上面静态常量的方式其实类似，只不过**将类实例化的过程放在了静态代码块中**，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。**优缺点和上面是一样的。**

-   2）结论：这种单例模式可用，但是可能造成内存浪费

#### 2.2.3 懒汉式（线程不安全）

懒加载，线程不安全。即用到时候再实例化，多线程时可能创建多个实例。不要用这种方式。

**步骤：**

1.  构造器私有化
2.  类的内部创建私有静态对象引用
3.  **向外暴露一个公共静态方法，当使用到该方法时，才去创建 instance**

```java
// 1、构造器私有化
private Singleton() {
}

// 2、类的内部声明对象
private static Singleton instance;

// 3、向外暴露一个静态的公共方法，当使用到该方法时，才去创建 instance
public static Singleton getInstance() {
    if (instance == null) {
        instance = new Singleton();
    }
    return instance;
}
```

**优缺点**

-   1）起到了 **Lazy Loading** 的效果，但是只能在单线程下使用

-   2）如果在**多线程**下，一个线程进入了判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便**会产生多个实例**

-   3）结论：在实际开发中，**不要使用这种方式**

#### 2.2.4 懒汉式（线程安全，同步方法）

线程安全，但效率低（每次获取实例都要加锁），不推荐。

-   1）构造器私有化

-   2）类的内部创建对象

-   3）向外暴露一个公共静态**synchronized**方法，当使用到该方法时，才去创建 instance

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题
    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

**优缺点**

-   1）解决了线程不安全问题

-   2）**效率太低了**，每个线程在想获得类的实例时候，执行`getlnstance()`方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接`return`就行了。方法进行同步效率太低

-   3）结论：在实际开发中，**不推荐使用这种方式**

#### 2.2.5 懒汉式（线程不安全，同步代码块）

线程不安全，不要用这种方式。

-   1）构造器私有化

-   2）类的内部创建对象

-   3）向外暴露一个静态的公共方法，加入同步处理的代码块

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象
    private static Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码，解决线程安全问题
    public static Singleton getInstance() {
        if (instance == null) {    //可能有多个线程同时通过检查，多次执行下面代码，产生多个实例
//类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例
            synchronized (Singleton.class) {
                instance = new Singleton();
            }
        }
        return instance;
    }
}
```

**优缺点**

-   1）这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块

-   2）但是这种同步并不能起到线程同步的作用。跟第3种实现方式遇到的情形一致，假如一个线程进入了判断语句块，还未来得及往下执行，**另一个线程也通过了这个判断语句**，这时便会产生多个实例

-   3）结论：在实际开发中，**不能使用这种方式**

#### 2.2.6 双重检查（推荐，线程安全、懒加载）

1.  构造器私有化
2.  类的内部创建对象引用，同时用**volatile关键字**修饰
3.  向外暴露一个静态的公共方法，**加入同步处理的代码块，并进行双重判断**，解决线程安全问题

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、类的内部声明对象，同时用`volatile`关键字修饰，为了保证可见性。
//原子性、可见性（修改立即更新到内存）、有序性
    private static volatile Singleton instance;

    // 3、向外暴露一个静态的公共方法，加入同步处理的代码块，并进行双重判断，解决线程安全问题
    public static Singleton getInstance() {
        if (instance == null) {    //第一次检查，可能有多个线程同时通过检查
//类级别的锁对象，锁对象是全局的，对该类的所有实例均有效。回顾锁对象是this时仅限于锁当前实例
            synchronized (Singleton.class) {    
                if (instance == null) {   //第二次检查，只会有1个线程通过检查并创建实例
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**优缺点**

-   1）Double-Check 概念是多线程开发中常使用到的，我们进行了**两次检查**，这样就可以保证线程安全了

-   2）这样实例化代码只用执行一次，后面再次访问时直接 return 实例化对象，也避免的反复进行方法同步

-   3）**线程安全；延迟加载；效率较高**

-   4）结论：在实际开发中，**推荐使用**这种单例设计模式

#### 2.2.7 静态内部类（推荐）

线程安全、延迟加载、效率高，推荐使用。 

**步骤：** 

-   1）构造器私有化

-   2）定义一个**静态内部类**，内部定义当前类的静态属性

-   3）向外暴露一个静态的公共方法

> **知识加油站：**
> 
> 1.  类的加载机制是延迟加载的，也就是说，只有在需要使用到某个类时才会进行加载。
> 2.  类加载过程中会加载其所有静态成员到内存中，包括静态变量、静态成员方法和静态内部类。
> 3.  类加载包括加载、链接（验证、准备（为类变量分配内存并赋零值）、解析）、初始化（类变量赋初值、执行静态语句块）。

```java
public class Singleton {
    // 1、构造器私有化
    private Singleton() {
    }

    // 2、定义一个静态内部类，内部定义当前类的静态属性
    private static class SingletonInstance {
        private static final Singleton instance = new Singleton();
    }

    // 3、向外暴露一个静态的公共方法
    public static Singleton getInstance() {
        return SingletonInstance.instance;
    }
}
```

**优缺点**

-   1）这种方式采用了类装载的机制，来保证初始化实例时只有一个线程

-   2）静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用`getlnstance`方法，才会装载Singletonlnstance 类，从而完成 Singleton 的实例化。

-   3）类的静态属性只会在第一次加载类的时候初始化，**JVM**帮助我们保证了**线程的安全性**，在类进行初始化时，别的线程是无法进入的

-   4）优点：避免了线程不安全，利用静态内部类特点实现**延迟加载，效率高**

-   5）结论：**推荐使用**

#### 2.2.8 枚举（推荐）

推荐，线程安全，延迟加载。

```java
public enum Singleton {
    INSTANCE;

    public void sayHello() {
        System.out.println("Hello World");
    }
}
```

```java
public class SingletonTest {
    public static void main(String[] args){
        Singleton instance = Singleton.INSTANCE;
        Singleton instance2 = Singleton.INSTANCE;
        System,out,println(instance == instance2);    //true
        System,out.println(instance.hashCode());
        System.out.println(instance2.hashCode());
    }
    public enum Singleton {
        INSTANCE;

        public void sayHello() {
            System.out.println("Hello World");
        }
    }
}
```

**优缺点**

-   1）这借助 JDK1.5 中添加的枚举来实现单例模式。不仅能**避免多线程同步问题**，而且还能防止反序列化重新创建新的对象

-   2）这种方式是 Effective Java 作者 Josh Bloch 提倡的方式

-   3）结论：**推荐使用**

#### 2.2.9 JDK 源码里单例模式分析

JDK中 **java.lang.Runtime** 就是经典的单例模式：

**饿汉式（静态变量）**，一定会用到所以不用怕内存浪费

![](https://i-blog.csdnimg.cn/blog_migrate/96c56e04ea795859ed2eeefc4d0cd643.png)