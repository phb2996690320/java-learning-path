---
url: https://blog.csdn.net/D_boj/article/details/132192272
title: 学习笔记：黑马程序员 Java - 基础篇（第一部分）-CSDN 博客
date: 2025-02-20 09:33:32
tag: 
summary: 
---
**Java 语言入门到精通章节**

1.  [学习笔记：Java - 基础篇（第一部分）_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132192272)
2.  [学习笔记：Java - 中级篇（第二部分）_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132224349)
3.  [学习笔记：Java - 高级篇（第三部分）_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132241235)
4.  [学习笔记：Java - 进阶篇（一）（第四部分）_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132257791)
5.  [学习笔记：Java - 进阶篇（二）（第五部分）_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132257812)
6.  [学习笔记：Java8 新特性_ljtxy.love 的博客 - CSDN 博客](https://blog.csdn.net/D_boj/article/details/132257818)

#### 文章目录

*   [1. 概述](#1_11)
*   *   [1.1 定义](#11_30)
    *   [1.2 特点](#12_40)
    *   [1.3 三大版本](#13_60)
    *   *   [1.3.1JavaSE 标准版](#131JavaSE_64)
        *   [1.3.2JavaME 微型版](#132JavaME_68)
        *   [1.3.3JavaEE 企业版](#133JavaEE_72)
    *   [1.3JDK 安装](#13JDK_79)
    *   *   [1.3.1 概述](#131_81)
        *   [1.3.2 基本用例](#132_94)
*   [2. 基本用例 - HelloWorld](#2HelloWorld_154)
*   [3. 基础语法](#3_210)
*   *   [3.1 注释](#31_268)
    *   *   [3.1.1 概述](#311_270)
        *   [3.1.2 分类](#312_274)
    *   [3.2 关键字](#32_314)
    *   *   [3.2.1 概述](#321_316)
        *   [3.2.2 分类](#322_320)
        *   [3.2.3 基本用例 - 关键字演示](#323_337)
    *   [3.3 字面量](#33_354)
    *   *   [3.3.1 概述](#331_356)
        *   [3.3.2 分类](#332_360)
        *   [3.3.3 基本用例](#333_373)
    *   [3.4 变量](#34_396)
    *   *   [3.4.1 概述](#341_398)
        *   [3.4.2 格式](#342_402)
        *   [3.4.3 基本用例 - 变量演示](#343_422)
    *   [3.5 数据类型](#35_452)
    *   *   [3.5.1 概述](#351_454)
        *   [3.5.2 分类](#352_458)
        *   [3.5.3 基本数据类型](#353_463)
        *   [3.5.4 引用数据类型](#354_529)
        *   [3.5.5 基本数据类型和引用数据类型区别](#355_538)
        *   [3.5.6 常用的数据类型](#356_572)
    *   [3.6 标识符](#36_614)
    *   *   [3.6.1 硬性要求](#361_618)
        *   [3.6.2 软性建议](#362_627)
        *   [3.6.3 阿里巴巴命名规范细节](#363_645)
    *   [3.7 权限修饰符](#37_659)
    *   *   [3.7.1 概述](#371_661)
        *   [3.7.2 权限访问能力](#372_676)
        *   [3.7.3 权限使用规则](#373_701)
    *   [3.8 包](#38_712)
    *   *   [3.8.1 概述](#381_714)
        *   [3.8.2 导包](#382_737)
*   [4.IDEA 开发工具](#4IDEA_765)
*   *   [4.1 概述](#41_786)
    *   [4.2 安装](#42_794)
    *   [4.3 目录层级结构](#43_843)
    *   *   [3.4.1 概述](#341_854)
        *   [4.3.2 项目、工程（project）](#432project_865)
        *   [4.3.2 模块（module）](#432module_869)
        *   [4.3.3 包（package）](#433package_876)
        *   [4.3.4 类（class）](#434class_885)
    *   [4.4 常用配置](#44_887)
    *   [4.5 类的相关操作](#45_897)
    *   [4.6 模块的相关操作](#46_905)
    *   [4.7 项目的相关操作](#47_914)
    *   [4.8 插件管理](#48_974)
*   [5. 运算符和表达式](#5_982)
*   *   [5.0 概述](#50_1122)
    *   *   [5.0.1 定义](#501_1124)
        *   [5.0.2 运算符](#502_1128)
        *   [5.0.3 表达式](#503_1138)
    *   [5.1 算术运算符](#51_1152)
    *   *   [5.1.1 概述](#511_1154)
        *   *   [5.1.1.1 定义](#5111_1156)
            *   [5.1.1.2 分类](#5112_1160)
            *   [5.1.1.3 特点](#5113_1166)
        *   [5.1.2 基本用例 - 运算符演示](#512_1172)
        *   [5.1.3 案例 - 数值拆分](#513_1198)
    *   [5.2 自增自减运算符](#52_1238)
    *   *   [5.2.1 概述](#521_1240)
        *   *   [5.2.1.1 定义](#5211_1242)
            *   [5.2.1.2 分类](#5212_1246)
            *   [5.2.1.3 特点](#5213_1264)
        *   [5.2.2 基本用例 - 自增自减演示](#522_1273)
    *   [5.3 赋值运算符](#53_1284)
    *   *   [5.3.1 概述](#531_1286)
        *   [5.3.2 基本用例 - 赋值运算符演示](#532_1290)
    *   [5.4 扩展赋值运算符](#54_1311)
    *   *   [4.4.1 概述](#441_1313)
        *   *   [4.4.1.1](#4411_1315)
            *   [5.4.1.2 分类](#5412_1319)
            *   [4.5.1.3 特点](#4513_1323)
        *   [5.4.2 基本用例 - 扩展运算符演示](#542_1327)
    *   [5.5 关系运算符](#55_1363)
    *   *   [5.5.1 定义](#551_1365)
        *   [5.5.2 分类](#552_1369)
    *   [5.6 逻辑运算符](#56_1385)
    *   *   [5.6.1 概述](#561_1387)
        *   *   [5.6.1.1 定义](#5611_1389)
            *   [5.6.1.2& 和 | 的使用](#5612____1393)
        *   [5.6.2 基本用例 - 逻辑运算符演示](#562_1403)
        *   [5.6.3 应用场景](#563_1421)
        *   *   [5.6.3.1 场景举例](#5631_1423)
            *   [5.6.3.2^（异或）的使用](#5632_1449)
            *   [5.6.3.3!（取反）的使用](#5633_1465)
    *   [5.7 短路逻辑运算符](#57_1485)
    *   *   [5.7.1 概述](#571_1487)
        *   *   [5.7.1.1 定义](#5711_1489)
            *   [5.7.1.2 分类](#5712_1493)
        *   [5.7.2 应用场景](#572_1510)
        *   *   [5.7.2.1 场景](#5721_1512)
            *   [5.7.2.2 总结](#5722_1550)
            *   [5.7.2.3 建议](#5723_1556)
    *   [5.8 三元运算符](#58_1560)
    *   *   [5.8.1 概述](#581_1562)
        *   *   [5.8.1.1 定义](#5811_1564)
            *   [5.8.1.2 格式](#5812_1568)
        *   [5.8.2 基本用例 - 三元运算符演示](#582_1582)
    *   [5.9 运算符的优先级](#59_1604)
    *   [5.10 隐式转换](#510_1608)
    *   *   [5.10.1 定义](#5101_1610)
        *   [5.10.2 提升规则](#5102_1614)
        *   [5.10.3 取值范围关系](#5103_1619)
    *   [5.11 强制转换](#511_1623)
    *   *   [5.11.1 概念](#5111_1625)
        *   *   [5.11.1.1 定义](#51111_1627)
            *   [5.11.1.2 格式](#51112_1631)
        *   [5.11.2 基本用例 - 轻质转换演示](#5112_1635)
    *   [5.12 中字符的 + 操作](#512_1651)
    *   *   [5.12.1 概念](#5121_1653)
        *   [5.12.2 基本用例 - 字符 + 演示](#5122_1657)
    *   [5.13 位移运算符](#513_1673)
*   [6. 控制语句](#6_1683)
*   *   [6.1 概述](#61_1727)
    *   *   [6.1.1 定义](#611_1729)
        *   [6.1.2 分类](#612_1733)
    *   [6.1 流程控制语句](#61_1737)
    *   *   [6.1.1 概述](#611_1739)
        *   *   [6.1.1.1 定义](#6111_1741)
            *   [6.1.1.2 分类](#6112_1745)
        *   [6.1.1 顺序结构](#611_1754)
        *   *   [6.1.1.1 定义](#6111_1756)
            *   [6.1.1.2 执行流程图](#6112_1760)
        *   [6.1.2 判断结构 --f 语句](#612f_1764)
        *   [6.1.3 选择结构 --switch 语句](#613switch_1882)
        *   [6.1.4 循环结构](#614_1941)
        *   *   [6.1.4.1for 循环结构（掌握）](#6141for_1943)
            *   [6.1.4.2while 循环](#6142while_2001)
            *   [6.1.4.3do...while 循环](#6143dowhile_2013)
            *   [6.1.4.4 三种格式的区别](#6144_2031)
            *   [6.1.4.4 无限循环](#6144_2041)
    *   [6.2 条件控制语句](#62_2092)
    *   *   [6.2.1break](#621break_2097)
        *   [6.2.2continue](#622continue_2114)
*   [7. 数组](#7_2136)
*   *   [7.1 概述](#71_2256)
    *   *   [7.1.1 定义](#711_2258)
        *   [7.1.2 建议](#712_2266)
    *   [7.2 数组定义](#72_2276)
    *   *   [7.2.1 格式一](#721_2278)
        *   [7.2.2 格式二](#722_2286)
    *   [7.3 数组的静态初始化](#73_2312)
    *   [7.4 数组的动态初始化](#74_2338)
    *   [7.5 地址值](#75_2347)
    *   [7.6 索引](#76_2374)
    *   *   [7.6.1 定义](#761_2376)
        *   [7.6.2 特点](#762_2380)
    *   [7.7 数组元素访问](#77_2386)
    *   *   [7.7.1 作用](#771_2388)
        *   [7.7.2 基本用例 - 数组访问演示](#772_2395)
    *   [7.8 数组的遍历](#78_2425)
    *   *   [7.8.1 遍历](#781_2427)
        *   [7.8.2 基本用例 - 数组遍历演示](#782_2431)
    *   [7.9 数组两种初始化方式的区别](#79_2442)
    *   *   [7.9.1 静态初始化](#791_2444)
        *   [7.9.2 动态初始化](#792_2454)
        *   [7.9.3 应用场景](#793_2464)
        *   [7.9.4 数组常见问题](#794_2484)
*   [8. 代码块](#8_2507)
*   *   [8.1 局部代码块](#81_2532)
    *   [8.2 构造代码块](#82_2549)
    *   [8.3 静态代码块（重点）](#83_2558)
*   [9. 关键字](#9_2579)
*   *   [9.1this 关键字](#91this_2583)
    *   [9.2static 关键字](#92static_2623)
    *   *   [9.2.1 概述](#921_2730)
        *   [9.2.1 静态变量及其访问](#921_2734)
        *   *   [9.2.1.1 概述](#9211_2736)
            *   [9.2.1.2 基本用例 - static 关键字使用](#9212static_2740)
            *   [9.2.1.3 访问](#9213_2751)
        *   [9.2.2 实例变量及其访问](#922_2763)
        *   *   [9.2.2.1 概述](#9221_2765)
            *   [9.2.2.2 基本用例 - 实例变量使用](#9222_2769)
            *   [9.2.2.3 访问](#9223_2778)
        *   [9.2.3 静态方法及其访问](#923_2793)
        *   *   [9.2.3.1 概述](#9231_2795)
            *   [9.2.3.2 基本用例](#9232_2801)
            *   [9.2.3.2 访问](#9232_2813)
        *   [9.2.4 实例方法及其访问](#924_2823)
        *   *   [9.2.4.1 概述](#9241_2825)
            *   [9.2.4.2 基本用例 - 实例方法使用](#9242_2833)
            *   [9.2.4.3 访问](#9243_2856)
        *   [9.2.5Static 内存图（重点）](#925Static_2879)
        *   [9.2.6Static 修饰成员变量和成员方法](#926Static_2916)
        *   [9.2.7 工具类常用 Static](#927Static_2920)
        *   [9.2.8Static 弊端](#928Static_2932)
    *   [9.3final 关键字](#93final_2942)
    *   *   [9.3.1 概述](#931_2985)
        *   [9.3.2 修饰变量](#932_3000)
        *   *   [9.3.2.1 局部变量（重点）](#9321_3002)
            *   [9.3.2.2 成员变量（重点）](#9322_3026)
        *   [9.3.3 修饰方法](#933_3063)
        *   *   [9.3.3.1 概述](#9331_3065)
            *   [9.3.3.2 基本用例 - 修饰方法演示](#9332_3069)
        *   [9.3.4 修饰类](#934_3097)
        *   *   [9.3.4.1 概述](#9341_3099)
            *   [9.3.4.2 基本用例 - 修饰类使用](#9342_3103)
    *   [9.4private 关键字](#94private_3118)
    *   *   [9.4.1 概述](#941_3125)
        *   [9.4.2 基本用例 - private 关键字使用](#942private_3138)
        *   [9.4.3 案例 - private 的使用](#943private_3183)
    *   [9.5this 关键字](#95this_3240)
    *   [9.6super 关键字](#96super_3293)
    *   *   [9.6.1 概述](#961_3332)
        *   [9.6.3 基本用例 - super 关键字使用](#963super_3379)
        *   [9.6.4 内存图](#964_3436)
        *   [9.6.5this( ) 基本用例](#965this__3444)
*   [知识加油篇](#_3516)
*   *   [1.Java 内存模型](#1Java_3518)
    *   [2.Idea 快捷键](#2Idea_3533)
    *   *   [2.1 查看接口实现类](#21_3535)
        *   [2.2 图标小细节](#22_3545)
    *   [3.int 和 Integer 区别](#3int_Integer__3557)
    *   [4.String 和 Character 区别](#4String_Character__3565)
    *   [5. 基本数据类型和引用数据类型的区别](#5_3573)

## 1. 概述

笔记小结：

1.  定义：Java 是一种**高级语言**。它被设计为一种通用的、**面向对象**的编程语言，具有**跨平台性**和**可移植性**
2.  特点：简单易学、**面向对象**编程、平台无关性、安全性、高性能、多线程支持、开源免费
3.  跨平台原理：针对于不同的操作系统，Java 提供了**不同的虚拟机**，对于不同的操作系统，安装不同的虚拟机
4.  三大版本：
    *   JavaSE：SE 即标准版，包含了 Java 核心类库，主要用来开**发桌面应用**
    *   JavaME：ME 即微型版，包含了 SE 中部分类库，又有自己扩展部分，主要用来做**移动类嵌入式**开发
    *   JavaEE：EE 即企业版，包含 SE，又有扩展部分（Servlet，JDBC 等），主要用来开发分布式网络程序
5.  JRE、JVM、JDK：
    *   **JVM**（Java Virtual Machine），Java 虚拟机
    *   **JRE**（Java Runtime Environment），Java **运行环境**，包含了 JVM 和 Java 的核心类库（Java API）
    *   **JDK**（Java Development Kit）称为 Java 开发工具，包含了 JRE 和开发工具
6.  下载和安装
7.  目录介绍
8.  环境变量配置

### 1.1 定义

​ Java 是一种广泛使用的**计算机编程语言**，由 Sun Microsystems（后来被 Oracle 收购）在 1995 年推出。它被设计为一种通用的、面向对象的编程语言，具有跨平台性和可移植性

补充：

*   语言：人与人交流沟通的表达方式
    
*   计算机语言：人与计算机之间进行信息交流沟通的**一种特殊语言**
    

### 1.2 特点

1.  简单易学：Java 采用类似于 C++ 的语法，但它去除了一些容易导致错误的复杂特性，使得它更加简单易学。
2.  **面向对象**编程：Java 是一种完全面向对象编程语言，这意味着所有的程序元素都是对象，通过对象之间的交互实现程序的逻辑。
3.  **跨平台**性：Java 程序在不同平台上可以运行，这是因为 Java 程序通过 JVM（Java 虚拟机）来运行，JVM 能够在不同平台上执行相同的 Java 代码。
4.  **安全**性：Java 是一种安全性较高的编程语言，因为它具有内置的安全机制，如内存管理、异常处理和访问控制。
5.  **高性能**：尽管 Java 是一种解释型语言，但它可以通过 JIT（即时编译）技术提高性能。
6.  **多线程**支持：Java 提供了内置的多线程支持，使得程序员可以很方便地编写多线程程序。
7.  开源免费：Java 是一种开源免费的编程语言，可以通过许多渠道获得它的开发工具和运行环境。

**Java 语言跨平台的原理**

*   操作系统本身其实是不认识 Java 语言的。
*   但是针对于不同的操作系统，Java 提供了**不同的虚拟机**。

![](<assets/1740015212956.png>)

![](<assets/1740015213219.png>)

### 1.3 三大版本

​ JavaSE、JavaME、JavaEE

#### 1.3.1JavaSE 标准版

​ JavaSE(Java Platform, Standard Edition)，Java 语言的（标准版)，用于**桌面应用的开发**，是其他两个版本的基础。

#### 1.3.2JavaME 微型版

​ JavaME(Java Platform, Micro Edition)，Java 语言的小型版，用于嵌入式消费类**电子设备**或者**小型移动设备**的开发。（嵌入式，电视机，微波炉，电视机等），其中最为主要的还是小型移动设备的开发（手机）。渐渐的没落了，已经被安卓和 IOS 给替代了。但是，安卓也是可以用 Java 来开发的。

#### 1.3.3JavaEE 企业版

​ JavaEE（Java Platform, Enterprise Edition）用于 **Web 方向**的网站开发。（主要从事**后台**服务器的开发）在服务器领域，Java 是当之无愧的龙头老大。

![](<assets/1740015213506.png>)

### 1.3JDK 安装

#### 1.3.1 概述

*   **JVM**（Java Virtual Machine），Java 虚拟机
*   **JRE**（Java Runtime Environment），Java **运行环境**，包含了 JVM 和 Java 的核心类库（Java API）
*   **JDK**（Java Development Kit）称为 Java 开发工具，包含了 JRE 和开发工具

![](<assets/1740015213749.png>)

说明：

​ 当我们开发时，我们**只需安装 JDK** 即可，它包含了 java 的运行环境和虚拟机。当我们只运行时只需要**装 JRE** 即可

#### 1.3.2 基本用例

说明：

通过官方网站获取 JDK，网址：[Java Downloads | Oracle 中国](https://www.oracle.com/cn/java/technologies/downloads/)

注意：

*   安装路径不要有中文，不要有空格等一些特殊的符号。
*   以后跟开发相关的所有软件建议都安装在同一个文件夹中，方便管理。

步骤一：下载 JDK  

![](<assets/1740015214005.png>)

补充：安装目录

![](<assets/1740015214292.png>)

*   以上是 JDK17 的安装目录，以下是 JDK 的目录解释

<table><thead><tr><th>目录名称</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>该路径下存放了 JDK 的<strong>各种工具</strong>命令。javac 和 java 就放在这个目录。</td></tr><tr><td>conf</td><td>该路径下存放了 JDK 的相关<strong>配置</strong>文件。</td></tr><tr><td>include</td><td>该路径下存放了一些平台特定的<strong>头文件</strong>。</td></tr><tr><td>jmods</td><td>该路径下存放了 JDK 的<strong>各种模块</strong>。</td></tr><tr><td>legal</td><td>该路径下存放了 JDK 各模块的<strong>授权文档</strong>。</td></tr><tr><td>lib</td><td>该路径下存放了 JDK 工具的一些补充<strong> JAR 包</strong>。</td></tr></tbody></table>

步骤二：环境变量配置

说明：

​ 开发 Java 程序，需要使用 JDK 提供的开发工具（比如 javac.exe、java.exe 等命令），而这些工具在 JDK 的安装目录的 bin 目录下，如果不配置环境变量，那么这些命令只可以在 bin 目录下使用，而我们想要在任意目录下都能使用，所以就要**配置环境变量**

1. 配置`JAVA_HOME`环境

![](<assets/1740015214547.png>)

2. 配置`PATH`环境

![](<assets/1740015214852.png>)

补充：

*   **JAVA_HOME**：告诉操作系统 JDK 安装在了哪个位置（未来其他技术要通过这个找 JDK）
*   **Path**：告诉操作系统 JDK 提供的 javac(编译)、java(执行) 命令安装到了哪个位置

步骤三：演示

*   新建 cmd 命名窗口，输入`java --version`

![](<assets/1740015215225.png>)

说明：

​ 此处可以看到 JDK 的版本为 17

## 2. 基本用例 - HelloWorld

笔记小结：

​ Java 程序开发运行流程需要三个步骤：**编写**程序，**编译**程序，**运行**程序

说明：

​ 通过`HelloWorld`程序演示 Java 流程基本执行流程

步骤一：创建 Java 程序

*   新建`HelloWorld.class`文件，并编写

```
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!"); 
    }
}

```

步骤二：编译 Java 程序

说明：

​ `javac` 是 Java 编译器的命令行工具，用于将 Java 源代码文件（以 `.java` 扩展名结尾）编译成 Java 字节码文件（以 `.class` 扩展名结尾）。Java 字节码文件可以在 Java 虚拟机（JVM）上运行。

*   打开命令行窗口执行`javac`命令

```
javac HelloWorld.java

```

说明：结果

![](<assets/1740015215517.png>)

步骤三：执行字节码文件

*   打开命令行窗口执行当前目录下`java`命令

```
java HelloWorld

```

说明：结果

![](<assets/1740015215797.png>)

注意：

​ 运行 class 文件时，不需要加`.class`后缀

## 3. 基础语法

笔记小结：

1.  **注释**：单行注释、多行注释、文档注释
    
2.  关键字：
    
    *   定义：被 Java 赋予了**特定含义**的英文单词
    *   class、static、……
3.  字面量：
    
    *   定义：**数据**在程序中的书写格式
    *   666、”MySoul“、……
4.  变量：
    
    *   定义：临时**存储数据**的容器
    *   int a = 16;、double b = 10.1;、……
    *   注意：Java 中变量需要有变量类型、变量名以及**分号结束**
5.  数据类型：
    
    *   **基本**数据类型：byte、short、int、long、float、double、char 和 boolean
    *   **引用**数据类型：字符串、数组、类和接口、……
    *   **区别**：
        1.  基本数据类型存储在**栈**中，而引用数据类型存储在**堆**中
        2.  基本数据类型的变量之间是**相互独立**的，而引用数据类型的变量之间**可**能**共享**同一个对象
6.  标识符：
    
    *   定义：标识符是用来**命名**变量、方法、类、接口等程序元素的名称
    *   注意：
        1.  必须由数字、字母、** 下划线_、美元符号 $** 组成。
        2.  数字不能开头
        3.  不能是关键字
        4.  区分大小写的
    *   阿里巴巴命名规范细节
7.  权限修饰符：
    
    *   定义：权限修饰符是 Java 中的一种关键字，用于**控制**类、方法和变量的**访问权限**
    *   权限范围：`private`<`默认/空着不写`<`protected`<`public`
8.  包：
    
    *   定义：包是一种用于组织和管理 Java 类的机制
        
    *   命名规范：
        
        ```
        路径名.路径名.xxx.xxx
        // 例如：com.itheima.oa
        
        ```
        
    *   导包：不是在 java.lang 包下，都需要导包。因为 Java 开发环境，默认为 lang 包
        

### 3.1 注释

#### 3.1.1 概述

​ 注释是对代码的解释和说明文字

#### 3.1.2 分类

Java 中的注释分为三种：

*   单行注释：

```
// 这是单行注释文字

```

*   多行注释：

```
/*
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/

```

注意：

​ 多行注释不能嵌套使用！

*   文档注释（暂时用不到）

```
/**
这是多行注释文字
这是多行注释文字
这是多行注释文字
*/

```

说明：使用的技巧

*   如果我们要对代码进行解释，那么就可以使用注释
*   当注释的内容比较少，一行就写完了，可以用单行注释
*   如果注释的内容比较多，需要写在多行，那么可以使用多行注释

### 3.2 关键字

#### 3.2.1 概述

​ Java 关键字就是被 Java 赋予了特定含义的英文单词。当我们在代码中写了关键字之后，程序在运行的时候，就知道要做什么事情了。

#### 3.2.2 分类

Java 关键字是编程语言中预定义的具有特殊含义的词汇，这些关键字用于控制程序的结构、流程和行为

注意

关键字很多，不用刻意去记

1.  **修饰符关键字**：`public`、`protected`、`private`、`static`、`final`、`abstract`
2.  **访问控制关键字**：`public`、`protected`、`private`、`default`（默认）
3.  **类、接口和包关键字**：、`class`、`interface`、`enum`、`package`、`import`、`extends`、`implements`
4.  **方法关键字**：`void`、`return`、`this`、`super`
5.  **流程控制关键字**：`if`、`else`、`switch`、`case`、`default`、`while`、`do`、`for`、`break`、`continue`、`return`
6.  **异常处理关键字**：`try`、`catch`、`finally`、`throw`、`throws`
7.  **逻辑关键字**：`true`、`false`、`null`
8.  **其他关键字**：`new`、`instanceof`、`synchronized`、`transient`、`volatile`、`assert`

#### 3.2.3 基本用例 - 关键字演示

*   `Class`类此关键字表示定义一个类

```
public class HelloWorld{
    
}

```

说明：

*   解释：class 表示定义类
    
*   类名：HelloWorld
    
*   HelloWorld 后面的大括号表示这个类的范围
    

### 3.3 字面量

#### 3.3.1 概述

​ Java 字面量是程序中直接使用的常量值，它表示各种数据类型的固定值。字面量可以是整数、浮点数、字符、字符串等数据类型的常量值，它们在代码中直接出现，不需要进行计算或转换。

#### 3.3.2 分类

1.  **整数字面量**：表示整数值，可以使用十进制、八进制（以 0 开头）和十六进制（以 0x 或 0X 开头）表示法。例如：`42`, `012`, `0xFF`。
2.  **浮点数字面量**：表示浮点数值，包括普通的浮点数和科学计数法表示。例如：`3.14`, `2.0e-5`。
3.  **字符字面量**：表示单个字符，使用单引号括起来。例如：`'A'`, `'1'`, `'@'`。
4.  **字符串字面量**：表示一个字符串，使用双引号括起来。例如：`"Hello, World!"`, `"Java"`。
5.  **布尔字面量**：表示布尔值，只有两个取值：`true` 和 `false`。
6.  **null 字面量**：表示空引用，用于表示对象引用不指向任何有效的对象。
7.  **转义序列**：一些特殊的字符序列，以反斜线 `\` 开头，用于表示无法直接输入的字符，如换行符 `\n`、制表符 `\t` 等。
8.  **数组字面量**：用花括号 `{}` 表示，用于初始化数组。例如：`{1, 2, 3}`。
9.  **枚举常量**：枚举类型的常量值，表示枚举中的特定选项。
10.  **字符编码字面量**：表示字符的 Unicode 编码，以 `\u` 开头，后面跟着四个十六进制数字。例如：`\u0041` 表示字符 ‘A’。

#### 3.3.3 基本用例

```
public class Demo {
    public static void main(String[] args) {
        System.out.println(10); // 输出一个整数
        System.out.println(5.5); // 输出一个小数
        System.out.println('a'); // 输出一个字符
        System.out.println(true); // 输出boolean值true
        System.out.println("欢迎来到黑马程序员"); // 输出字符串
    }
}

```

补充：区分技巧

1.  **不带小数点的数字**都是**整数**类型的字面量
2.  只要带了**小数点**，那么就是**小数类型**的字面量
3.  只要用**双引号**引起来的，不管里面的内容是什么，不管里面有没有内容，都是**字符串类型**的字面量。
4.  **字符类型**的字面量必须用**单引号**引起来，不管内容是什么，但是个数有且只能有一个
5.  **布尔类型**的字面量只有两个值，true、false
6.  **空类型**的字面量只有一个值，**null**

### 3.4 变量

#### 3.4.1 概述

​ 变量就在程序中临时存储数据的容器。但是这个容器中只能存一个值。

#### 3.4.2 格式

```
数据类型 变量名 = 数据值；

```

说明：

*   如果要存 10，那么数据类型就需要写整数类型。
    
*   如果要存 10.0，那么数据类型就需要写小数类型。
    

补充：参数解释

*   变量名：其实就是这个容器的名字
    
*   数据值：真正存储在容器中的数据
    
*   分号：表示语句的结束，就跟以前写作文时候的句号是一样的
    

#### 3.4.3 基本用例 - 变量演示

```
public class VariableDemo2{
	public static void main(String[] args){
		//1.变量名不允许重复
		//int a = 10;
		//int a = 20;
		//System.out.println(a);
		
		//2.一条语句可以定义多个变量
		//了解。
		//int a = 10, b = 20, c = 20,d = 20;
		//System.out.println(a);//?
		//System.out.println(b);//?
		
		
		//3.变量在使用之前必须要赋值
		int a = 30;
		System.out.println(a);
	}
}

```

注意：

*   变量名不能重复
*   在一条语句中，可以定义多个变量。但是这种方式影响代码的阅读，所以了解一下即可。
*   变量在使用之前必须要赋值。

### 3.5 数据类型

#### 3.5.1 概述

​ Java 数据类型是用来定义变量或表达式可以存储的数据类型的分类

#### 3.5.2 分类

*   基本数据类型
*   引用数据类型（面向对象的时候再深入学习）

#### 3.5.3 基本数据类型

1.  **整数类型（Integer Types）**：`byte`：8 位，范围为 -128 到 127、`short`：16 位，范围为 -32,768 到 32,767、`int`：32 位，范围为 -2^31 到 2^31 - 1、`long`：64 位，范围为 -2^63 到 2^63 - 1
2.  **浮点类型（Floating-Point Types）**：`float`：32 位，用于表示单精度浮点数、`double`：64 位，用于表示双精度浮点数
3.  **字符类型（Character Type）**：`char`：16 位，用于存储一个 Unicode 字符
4.  **布尔类型（Boolean Type）**：`boolean`：用于表示布尔值，只有两个取值：`true` 和 `false`

注意：

*   **byte** 类型的取值范围： **-128 ~ 127**
*   **int** 类型的大概取值范围： **-21 亿多 ~ 21 亿多**

补充：**整数类型和小数类型的取值范围大小关系：**

*   double > float > long > int > short > byte
*   在 java 中整数默认是 int 类型，浮点数默认是 double 类型

代码示例：

```
public class VariableDemo3{
    public static void main(String[] args){
        //1.定义byte类型的变量
        //数据类型 变量名 = 数据值;
        byte a = 10;
        System.out.println(a);

        //2.定义short类型的变量
        short b = 20;
        System.out.println(b);

        //3.定义int类型的变量
        int c = 30;
        System.out.println(c);

        //4.定义long类型的变量
        long d = 123456789123456789L;
        System.out.println(d);

        //5.定义float类型的变量
        float e = 10.1F;
        System.out.println(e);

        //6.定义double类型的变量
        double f = 20.3;
        System.out.println(f);

        //7.定义char类型的变量
        char g = 'a';
        System.out.println(g);

        //8.定义boolean类型的变量
        boolean h = true;
        System.out.println(h);

    }
}

```

注意：

*   如果要定义 一个整数类型的变量，不知道选择哪种数据类型了，默认使用 int。
*   如果要定义 一个小数类型的变量，不知道选择哪种数据类型了，默认使用 double。
*   如果要定义一个 long 类型的变量，那么在数据值的后面需要加上 **L 后缀**。（大小写都可以，建议大写。）
*   如果要定义一个 float 类型的变量，那么在数据值的后面需要加上 **F 后缀**。（大小写都可以）

#### 3.5.4 引用数据类型

1.  **类（Class）**：类是用来创建对象的模板。它定义了对象的属性（成员变量）和方法（成员方法）。通过实例化类，可以创建类的对象，并使用对象调用类的方法。
2.  **接口（Interface）**：接口定义了一组方法的规范，但没有实际的方法体。类可以实现一个或多个接口，从而获得接口定义的方法，并在类中实现这些方法。
3.  **数组（Array）**：数组是一种用于存储相同类型元素的数据结构。它可以是一维数组或多维数组，用于在内存中连续存储多个元素。
4.  **枚举（Enum）**：枚举是一种特殊的类，用于表示一组预定义的常量。枚举常常用于表示一组相关的值。
5.  **字符串（String）**：字符串是一种引用数据类型，但它具有特殊的性质，可以像基本数据类型一样进行操作。字符串实际上是一个字符序列，它有许多方法用于处理字符串操作。
6.  **自定义引用类型**：除了上述内置的引用数据类型，开发人员还可以创建自定义的类和接口，以及它们的实例，从而构建更复杂的数据结构和功能。

#### 3.5.5 基本数据类型和引用数据类型区别

1.  基本数据类型：基本数据类型是按值传递的，它们在 Java 虚拟机栈中分配内存空间，并直接存储值本身。当基本数据类型的变量被赋值时，实际上是将该变量中的值复制到另一个变量中，这两个变量之间没有任何关联。
2.  引用数据类型：引用数据类型是按引用传递的，它们在 Java 虚拟机堆中分配内存空间，存储的是对象的引用（内存地址）。当引用数据类型的变量被赋值时，实际上是将该变量中的引用复制到另一个变量中，这两个变量指向同一个对象。

补充：

​ 详细请参考知识加油站站`基本数据类型和引用数据类型区别`

代码示例：

```
// 使用引用数据类型创建一个对象
String message = new String("Hello, World!");

// 创建一个数组
int[] numbers = new int[5];

// 使用自定义类创建对象
class Person {
    String name;
    int age;
}
Person person = new Person();
person.name = "Alice";
person.age = 30;

// 枚举类型
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
Day today = Day.WEDNESDAY;

```

#### 3.5.6 常用的数据类型

*   ​ 整数：int
*   ​ 小数：（浮点数）double

代码示例：

```
public class VariableDemo{
	public static void main(String[] args){
		//定义一个整数类型的变量
		//数据类型 变量名 = 数据值;
		int a = 16;
		System.out.println(a);//16
		
		//定义一个小数类型的变量
		double b = 10.1;
		System.out.println(b);//10.1
	}
}

```

补充：

​ null 不能直接打印的，如果需要打印需要用字符串的形式进行打印。

最为常用的数据类型选择：

*   在定义变量的时候，要根据实际的情况来选择不同类型的变量。
    
    比如：**人的年龄**，可以选择 **byte 类型**
    
    比如：**地球的年龄**，可以选择 **long 类型**
    
*   如果**整数**类型中，**不太确定范围**，那么默认使用 **int 类型**
    
*   如果**小数**类型中，**不太确定范围**，那么默认使用 **double 类型**
    
*   如果要定义**字符类型**的变量，那么使用 **char**
    
*   如果要定义**布尔类型**的变量，那么使用 **boolean**
    

### 3.6 标识符

​ 在 Java 中，标识符是用来**标识程序中各种元素的名称**，比如**变量、方法、类、接口**等。标识符是由字母、数字、下划线（_）和美元符号（$）组成的序列，且必须以字母、下划线或美元符号开头。标识符在编程中用于命名各种实体，使得程序易于阅读、理解和维护

#### 3.6.1 硬性要求

​ 必须要这么做，否则代码会报错。

*   必须由数字、字母、下划线_、** 美元符号 $** 组成。
*   数字不能开头
*   不能是关键字
*   区分大小写的。

#### 3.6.2 软性建议

**1. 小驼峰命名法**

适用于变量名和方法名

*   如果是一个单词，那么全部小写，比如：name
    
*   如果是多个单词，那么从第二个单词开始，首字母大写，比如：firstName、maxAge
    

**2. 大驼峰命名法**

适用于类名

*   如果是一个单词，那么首字母大写。比如：Demo、Test。
    
*   如果是多个单词，那么每一个单词首字母都需要大写。比如：HelloWorld
    

#### 3.6.3 阿里巴巴命名规范细节

1.  尽量不要用拼音。但是一些国际通用的拼音可视为英文单词。
    
    正确：alibaba、hangzhou、nanjing
    
    错误：jiage、dazhe
    
2.  平时在给变量名、方法名、类名起名字的时候，不要使用下划线或美元符号。
    
    错误：_name
    
    正确：name
    

### 3.7 权限修饰符

#### 3.7.1 概述

​ 在 Java 中提供了四种访问权限，使用不同的访问权限修饰符修饰时，被修饰的内容会有不同的访问权限，我们之前已经学习过了`public` 和 `private`，接下来我们研究一下 protected 和默认修饰符的作用。

*   public：公共的，所有地方都可以访问。
    
*   protected：本类 ，本包，其他包中的子类都可以访问。
    
*   默认（没有修饰符）：本类 ，本包可以访问。
    
    注意：默认是空着不写，不是 default
    
*   private：私有的，当前类可以访问。  
    `public > protected > 默认 > private`
    

#### 3.7.2 权限访问能力

权限范围

private < 默认 / 空着不写 < protected<public

<table><thead><tr><th></th><th>public</th><th>protected</th><th>默认</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中的类</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr></tbody></table>

可见，public 具有最大权限。private 则是最小权限。

编写代码时，如果没有特殊的考虑，建议这样使用权限：

*   成员变量使用`private` ，隐藏细节。
*   构造方法使用 `public` ，方便创建对象。
*   成员方法使用`public` ，方便调用方法。

补充：

不加权限修饰符，就是默认权限

#### 3.7.3 权限使用规则

实际开发中，一般只用 private 和 public

*   成员变量私有
*   方法公开

注意：

​ 如果方法中的代码是抽取其他方法中共性代码，这个方法一般也私有

### 3.8 包

#### 3.8.1 概述

​ 在 Java 中，包（Package）是一种用于**组织类和接口的方式**，它们通过逻辑上的组织将相关的类和接口归类到一个命名空间中。包的主要目的是避免命名冲突，并提供更好的代码管理和组织结构

​ 包在操作系统中其实就是一个文件夹。**包是用来分门别类的管理技术，不同的技术类放在不同的包下**，方便管理和维护。

在 IDEA 项目中，建包的操作如下：

![](<assets/1740015215993.png>)

**包名的命名规范**：

```
路径名.路径名.xxx.xxx
// 例如：com.itheima.oa

```

*   包名一般是公司域名的倒写。例如：黑马是 www.itheima.com, 包名就可以定义成 com.itheima. 技术名称。
*   包名必须用”.“连接。
*   包名的每个路径名必须是一个合法的标识符，而且不能是 Java 的关键字。

#### 3.8.2 导包

什么时候需要导包？

​ 情况一：在使用 Java 中提供的 ** 非核心包 (java.lang)** 中的类时

​ 情况二：使用自己写的**其他包中的类时**

什么时候不需要导包？

​ 情况一：在使用 Java 核心包（**java.lang**）中的类时

​ 情况二：在使用自己写的**同一个包中的类时**

假设 demo1 和 demo2 中都有一个 Student 该如何使用？

代码示例：

```
//使用全类名的形式即可。
//全类名：包名 + 类名
//拷贝全类名的快捷键：选中类名crtl + shift + alt + c 或者用鼠标点copy，再点击copy Reference
com.itheima.homework.demo1.Student s1 = new com.itheima.homework.demo1.Student();
com.itheima.homework.demo2.Student s2 = new com.itheima.homework.demo2.Student();

```

## 4.IDEA 开发工具

笔记小结：

1.  概述：目前用于 Java 程序开发最好的工具
2.  层级结构介绍：project - module - package - class
3.  类操作
    *   新建类文件
    *   删除类文件
    *   修改类文件
4.  模块操作
    *   新建模块
    *   删除模块
    *   修改模块
    *   导入模块
5.  项目操作
    *   关闭项目
    *   打开项目
    *   修改项目
    *   新建项目

### 4.1 概述

​ IDEA 全称 IntelliJ IDEA，是用于 Java 语言开发的集成环境，它是业界公认的目前用于 Java 程序开发最好的工具。

补充：

​ 把代码编写，编译，执行，调试等多种功能综合到一起的开发工具

### 4.2 安装

说明：

​ 学习好东西，参考链接：[IDEA2023. 学习持续更新 - 搜云库技术团队 (souyunku.com)](https://tech.souyunku.com/?p=15076)

步骤一：下载

说明：

​ 下载链接为：https://www.jetbrains.com/idea

![](<assets/1740015216219.png>)

步骤二：安装

1. 进入安装界面

![](<assets/1740015216454.png>)

2. 修改安装目录

![](<assets/1740015216766.png>)

说明：

​ 建议不要放在 C 盘

3. 额外选项

![](<assets/1740015217011.png>)

说明：

​ 勾选 64-bit launcher。表示在桌面新建一个 64 位的快捷方式。

4. 安装

![](<assets/1740015217275.png>)

5. 启动

![](<assets/1740015217472.png>)

说明：

​ 选择第二个不导入，保持默认设置，再点击 OK

### 4.3 目录层级结构

笔记小结

*   层级关系：project - module - package - class
    
*   包含数量：
    
*   **一个 project** 中可以创建**多个 module**
    
*   **一个 module** 中可以创建**多个 package**
    
*   **一个 package** 中可以创建**多个 class**
    

#### 3.4.1 概述

![](<assets/1740015217779.png>)

补充：**结构分类**

*   project（项目、工程）
*   module（模块）
*   package（包）
*   class（类）

#### 4.3.2 项目、工程（project）

​ 淘宝、京东、黑马程序员网站都属于一个个项目，IDEA 中就是一个个的 Project。

#### 4.3.2 模块（module）

​ 在一个项目中，可以存放多个模块，不同的模块可以存放项目中不同的业务功能代码。在黑马程序员的官方网站中，至少包含了以下模块：

*   论坛模块
*   报名、咨询模块

#### 4.3.3 包（package）

​ 一个模块中又有很多的业务，以黑马程序员官方网站的论坛模块为例，至少包含了以下不同的业务。

*   发帖
*   评论

为了把这些业务区分的更加清楚，就会用包来管理这些不同的业务。

#### 4.3.4 类（class）

### 4.4 常用配置

1. 修改字体

![](<assets/1740015218031.png>)

说明：

字体选择 Consolas，此字体比较柔和

### 4.5 类的相关操作

类的相关操作

*   新建类文件
*   删除类文件
*   修改类文件

### 4.6 模块的相关操作

模块的相关操作

*   新建模块
*   删除模块
*   修改模块
*   导入模块

### 4.7 项目的相关操作

项目的相关操作

*   关闭项目
*   打开项目
*   修改项目
*   **新建项目**

**修改项目**

点击 File，选择 Project Structure

![](<assets/1740015218319.png>)

在这个界面，默认是 Module

所以，要先点击 Project

在右侧页面中，输入新的项目名称

修改 JDK 版本和编译版本都变成 JDK14

再点击 OK

![](<assets/1740015218624.png>)

*   此时发现，项目名称已经修改完毕

![](<assets/1740015218991.png>)

*   但是本地文件夹的名字还没有修改

![](<assets/1740015219261.png>)

*   需要先关闭当前项目

![](<assets/1740015219621.png>)

*   点击项目后面的叉，从列表中移除项目

![](<assets/1740015219864.png>)

*   到本地硬盘中手动修改文件夹的名称
*   点击 Open or Import 重新打开项目

![](<assets/1740015220188.png>)

*   选择修改之后的项目
    
    点击 OK
    

![](<assets/1740015220424.png>)

*   此时会发现，项目名称和本地硬盘文件夹的名称都已经修改完毕了

![](<assets/1740015220688.png>)

### 4.8 插件管理

参考链接：

[IntelliJ Idea 常用 12 款插件（提高开发效率），附优秀主题插件_idea 插件_Java 技术攀登者的博客 - CSDN 博客](https://blog.csdn.net/weixin_41846320/article/details/82697818)

[IDEA 值得推荐的 20 款优秀的插件_idea 插件_新猿一马的博客 - CSDN 博客](https://blog.csdn.net/jack1liu/article/details/111505592)

## 5. 运算符和表达式

笔记小结：

1.  概述：
    
    1.  Java 运算符是用于对一个或多个操作数执行操作的**特殊符号**
        
    2.  表达式是由变量、常量、运算符和方法调用组成的符合语法规则的**语句**
        
    3.  运算符和表达式区别：
        
        *   运算符就是对常量或者变量进行**操作**的符号
            
        *   表达式就是符合 Java 语法的**式子**就是表达式
            
2.  算术运算符：
    
    *   定义：算术运算符是用来执行**基本的数学运算**的
        
    *   例如：
        
        ```
        +、-、 *、  / 
        
        ```
        
3.  自增自减运算符：
    
    *   定义：自增自减运算符是一种特殊的算数运算符，用于对变量的值进行**加 1** 或**减 1** 操作
        
    *   例如：
        
        ```
         ++、--
        
        ```
        
4.  赋值运算符：
    
    *   定义：赋值运算符是 Java 中用于给**变量赋值**的运算符
        
    *   例如：
        
        ```
        b = 20;
        
        ```
        
5.  扩展赋值运算符：
    
    *   定义：扩展赋值运算符是将**算术运算符和赋值运算符组合**在一起的运算符
        
    *   例如：
        
        ```
         "+="、 "-="、 "*="、 "/="、 "%="
        
        ```
        
    *   特点：扩展的赋值运算符中隐层还包含了一个强制转换
        
6.  关系运算符：
    
    *   含义：关系运算符是用于**比较**两个值之间的大小关系
        
    *   例如：
        
        ```
        a > b
        
        ```
        
    *   注意：区分 **==** 和 **=** 赋值运算符和关系运算符
        
7.  逻辑运算符：
    
    *   含义：用于多个布尔表达式组合在一起，以生成新的**布尔表达式**
        
    *   例如：
        
        ```
        true & true、false & false
        
        ```
        
    *   注意：逻辑运算符还有
        
        ```
        ！、& 、 |、^ 
        
        ```
        
8.  短路逻辑运算符：
    
    *   含义：如果已经可以**确定整个表达式的结果**时，就不再继续计算剩下的表达式
        
    *   例如：
        
        ```
        用户名正确  && 密码正确
        
        ```
        
9.  三元运算符：
    
    *   含义：被称为条件运算符，它是 Java 中唯一的具有**三个操作数**的运算符
        
    *   格式：
        
        ```
        关系表达式 ？ 表达式1 ：表达式2 ；
        
        ```
        
    *   例如：
        
        ```
        a > b ? a : b
        
        ```
        
10.  运算符优先级：**小括号优先** ( )
    
11.  隐式转换与强制转换
    
    1.  隐式转换：**自动**类型**提升**
        
        *   取值关系：byte < short < int < long < float < double
        *   注意：float 类型的存储空间比 long 类型小，但 float 类型的表示范围比 long 类型大
    2.  强制转换：**强制**类型**提升**
        
        *   格式：
            
            ```
            目标数据类型 变量名 = （目标数据类型）被强转的数据
            
            ```
            
12.  **字符串的 + 操作**（特例）：
    
    *   含义：当 + 操作中出现了字符，会拿着字符到计算机内置的 ASCII 码表中去查对应的数字，然后再进行计算
        
    *   例如：
        
        ```
        char c = 'a';
        int result = c + 0;
        System.out.println(result);//9
        
        ``` 

### 5.0 概述

#### 5.0.1 定义

​ Java 运算符是用于对一个或多个操作数执行操作的特殊符号。表达式是由变量、常量、运算符和方法调用组成的符合语法规则的语句。

#### 5.0.2 运算符

定义：就是对常量或者变量进行操作的符号。

比如：

```
 +  -  *  / 

```

#### 5.0.3 表达式

定义：用运算符把常量或者变量连接起来的，符合 Java 语法的式子就是表达式。

比如：

```
a + b 这个整体就是表达式。

```

说明：

​ 而其中 + 是算术运算符的一种，所以这个表达式也称之为算术表达式。

### 5.1 算术运算符

#### 5.1.1 概述

##### 5.1.1.1 定义

​ 算术运算符是用来执行基本的数学运算，例如加、减、乘、除和模（取余）运算等。在 Java 中，算术运算符包括加号（+）、减号（-）、乘号（*）、除号（/）和模运算符（%）等。这些运算符可用于处理数字类型的变量，如 int、long、float 和 double

##### 5.1.1.2 分类

```
+ - * / %

```

##### 5.1.1.3 特点

```
+ - * :跟小学数学中一模一样没有任何区别.

```

#### 5.1.2 基本用例 - 运算符演示

/ 号

```
/：
1.整数相除结果只能得到整除，如果结果想要是小数，必须要有小数参数。
2.小数直接参与运算，得到的结果有可能是不精确的。
案例：
System.out.println( 10 / 3);//3
System.out.println(10.0 / 3);//3.3333333333333335

```

% 号

```
%：取模、取余。
   他做的也是除法运算，只不过获取的是余数而已。
案例：
System.out.println(10 % 2);//0
System.out.println(10 % 3);//1
应用场景：
//可以利用取模来判断一个数是奇数还是偶数
System.out.println(15 % 2);//1  奇数

```

#### 5.1.3 案例 - 数值拆分

演示：键盘录入一个三位数，将其拆分为个位、十位、百位后，打印在控制台

```
//1.键盘录入一个三位数
//导包 --- 创建对象 --- 接收数据
Scanner sc = new Scanner(System.in);
System.out.println("请输入一个三位数");
int number = sc.nextInt();//123

//2.获取这个三位数的个位、十位、百位并打印出来
//公式：
//针对于任意的一个数而言
//个位： 数字 % 10
int ones = number % 10;
//十位： 数字 / 10 % 10
int tens = number / 10 % 10;
//百位： 数字 / 100 % 10
int hundreds = number / 100  % 10;

//输出结果
System.out.println(ones);
System.out.println(tens);
System.out.println(hundreds);

```

细节：

*   公式：获取任意一个数上每一位数。
    
    1.  个位：数字 % 10
        
    2.  十位：数字 / 10 % 10
        
    3.  百位：数字 / 100 % 10
        
    4.  千位：数字 / 1000 % 10
        
    5.  ……
        

### 5.2 自增自减运算符

#### 5.2.1 概述

##### 5.2.1.1 定义

​ 自增自减运算符是一种特殊的算数运算符，用于对变量进行加 1 或减 1 的操作。在 Java 中，自增自减运算符有两种形式：前缀形式和后缀形式。

##### 5.2.1.2 分类

```
++  自增运算符

```

说明：

​ ++：就是把变量里面的值 + 1

```
--  自减运算符

```

说明：

​ --：就是把变量里面的值 - 1

##### 5.2.1.3 特点

*   放在变量的前面，我们叫做先 ++。 比如：++a
*   放在变量的后面，我们叫做后 ++。 比如：a++

细节：

​ 不管是先 ++，还是后 ++。单独写在一行的时候，运算结果是一模一样的

#### 5.2.2 基本用例 - 自增自减演示

```
//++
int a = 10;
a++;//就是让变量a里面的值 + 1
System.out.println(a);//11
++a;//就是让变量a里面的值 + 1
System.out.println(a);//12

```

### 5.3 赋值运算符

#### 5.3.1 概述

​ 赋值运算符是 Java 中用于给变量赋值的运算符。在 Java 中，赋值运算符使用等号（=）表示，左边是变量名，右边是赋给变量的值。

#### 5.3.2 基本用例 - 赋值运算符演示

```
public class OperatorDemo6 {
    public static void main(String[] args) {
        //1.最为简单的赋值运算符用法
        int a = 10;//就是把10赋值给变量a
        System.out.println(a);

        //2.如果等号右边需要进行计算。
        int b = 20;
        int c = a + b;//先计算等号右边的，把计算的结果赋值给左边的变量
        System.out.println(c);

        //3.特殊的用法
        a = a + 10;//先计算等号右边的，把计算的结果赋值给左边的变量
        System.out.println(a);//20
    }
}

```

### 5.4 扩展赋值运算符

#### 4.4.1 概述

##### 4.4.1.1

​ 扩展赋值运算符是指在原有的赋值运算符基础上加上其他算数运算符，例如 `+=`, `-=`，`*=` 等等

##### 5.4.1.2 分类

​ +=、-=、*=、/=、%=

##### 4.5.1.3 特点

​ 就是把左边跟右边进行运算，把最终的结果赋值给左边，对右边没有任何影响。

#### 5.4.2 基本用例 - 扩展运算符演示

```
public class OperatorDemo7 {
    public static void main(String[] args) {
        //扩展赋值运算符
        int a = 10;
        int b = 20;
        a += b;//把左边和右边相加，再把最终的结果赋值给左边，对右边没有任何影响
        // 相当于 a = a + b;
        System.out.println(a);//30
        System.out.println(b);//20
    }
}

```

注意：

*   扩展的赋值运算符中隐层还包含了一个强制转换
    
*   例如：
    
    ```
    public class OperatorDemo8 {
        public static void main(String[] args) {
            byte a = 10;
            byte b = 20;
            //a += b;
            a = (byte)(a + b);
            System.out.println(a);//30
        }
    }
    
    ```
    
    说明：以 += 为例。a += b ; 实际上相当于 a = (byte)(a + b);
    

### 5.5 关系运算符

#### 5.5.1 定义

​ 又叫比较运算符，其实就是拿着左边跟右边进行了判断而已。

#### 5.5.2 分类

<table><thead><tr><th>符号</th><th>解释</th></tr></thead><tbody><tr><td>==</td><td>就是判断左边跟右边是否相等，如果成立就是 true，如果不成立就是 false</td></tr><tr><td>!=</td><td>就是判断左边跟右边是否不相等，如果成立就是 true，如果不成立就是 false</td></tr><tr><td>&gt;</td><td>就是判断左边是否大于右边，如果成立就是 true，如果不成立就是 false</td></tr><tr><td>&gt;=</td><td>就是判断左边是否大于等于右边，如果成立就是 true，如果不成立就是 false</td></tr><tr><td>&lt;</td><td>就是判断左边是否小于右边，如果成立就是 true，如果不成立就是 false</td></tr><tr><td>&lt;=</td><td>就是判断左边是否小于等于右边，如果成立就是 true，如果不成立就是 false</td></tr></tbody></table>

细节：

*   关系运算符最终的结果一定是布尔类型的。要么是 true，要么是 false
*   在写 == 的时候，千万不要写成 =

### 5.6 逻辑运算符

#### 5.6.1 概述

##### 5.6.1.1 定义

​ 逻辑运算符是一种用于连接多个条件表达式的运算符，用于构建复杂的条件表达式

##### 5.6.1.2& 和 | 的使用

&：逻辑与（而且）

​ 两边都为真，结果才是真，只要有一个为假，那么结果就是假。

|：逻辑或（或者）

​ 两边都为假，结果才是假，只要有一个为真，那么结果就是真。

#### 5.6.2 基本用例 - 逻辑运算符演示

```
// &  //两边都是真，结果才是真。
System.out.println(true & true);//true
System.out.println(false & false);//false
System.out.println(true & false);//false
System.out.println(false & true);//false

System.out.println("===================================");

// | 或  //两边都是假，结果才是假，如果有一个为真，那么结果就是真。
System.out.println(true | true);//true
System.out.println(false | false);//false
System.out.println(true | false);//true
System.out.println(false | true);//true

```

#### 5.6.3 应用场景

##### 5.6.3.1 场景举例

​ 根据固定的场景，来选择使用 & 还是使用 |

*   用户登录。
    
    用户名输入正确 & 密码输入正确
    
    因为只有用户名和密码同时都正确了，那么才能成功登录，只要有一个失败了都不行。
    
    使用技巧：
    
    ​ 当我们需要同时满足左边和右边两种情况时，可以使用且
    
*   丈母娘选女婿
    
    丈母娘：女婿啊，你要么买个房子，要么买辆车。就可以把我的小棉袄穿走了。
    
    买个房子 | 买辆车
    
    两个条件中，只要满足其中一个，就可以穿走小棉袄了。
    
    使用技巧：
    
    ​ 当两种条件只要满足其中一个的时候，可以使用或
    

##### 5.6.3.2^（异或）的使用

​ 在以后用的不多，了解一下即可。

计算规则：如果两边相同，结果为 false，如果两边不同，结果为 true

代码示例：

```
//^   //左右不相同，结果才是true，左右相同结果就是false
System.out.println(true ^ true);//false
System.out.println(false ^ false);//false
System.out.println(true ^ false);//true
System.out.println(false ^ true);//true

```

##### 5.6.3.3!（取反）的使用

​ 是取反，也叫做非。

计算规则：false 取反就是 true，true 取反就是 false

温馨提示：**取反最多只用一个。**

代码示例：

```
System.out.println(!false);//true
System.out.println(!true);//false
System.out.println(!!false);//报错

```

细节：

​ 注意点：取反最多只用一个

### 5.7 短路逻辑运算符

#### 5.7.1 概述

##### 5.7.1.1 定义

​ 短路逻辑运算符是指在逻辑运算中，如果能够根据左侧的表达式的值得出整个逻辑表达式的结果，就不再对右侧的表达式进行计算

##### 5.7.1.2 分类

*   &&
    
    运算结果跟 & 是一模一样的，只不过具有短路效果。
    
*   ||
    
    运算结果跟 | 是一模一样的。只不过具有短路效果。
    

逻辑核心：

​ 当左边不能确定整个表达式的结果，右边才会执行。

​ 当左边能确定整个表达式的结果，那么右边就不会执行了。从而提高了代码的运行效率。

#### 5.7.2 应用场景

##### 5.7.2.1 场景

**1. 用户登录案例**

用户名正确 & 密码正确

如果使用一个 &，不管用户名是否正确都会去验证密码。

思考：

​ 如果用户名输入正确了，那么我们再判断密码是否正确，是符合业务逻辑的。

​ 但是如果用户名输入错误了，那么现在还有必要去比较密码吗？没有不要了。

​ 如果使用一个 &，那么左边和右边不管什么情况下，都会执行。

​ 用户名正确 && 密码正确

​ 如果用户名输入正确了，那么才会验证密码是否输入正确。

​ 如果用户名输入错误了，那么就不会再去验证密码是否正确，最终的结果直接为 false。从而提高了程序运行的效率。

**2. 丈母娘选女婿**

有房 | 有车

首先先看看有没有房，发现有，然后再去看看有没有车。

思考：

​ 既然都有房子，干嘛还要去看车呢？多此一举。

​ 有房 || 有车

​ 首先先看看有没有房，如果有，那么右边就不执行了。最终的结果直接为 true。

​ 如果没有房子，才会去看右边有没有车。

##### 5.7.2.2 总结

​ && 和 & 、|| 和 | 的运行结果都是一模一样的。

​ 但是短路逻辑运算符可以提高程序的运行效率。

##### 5.7.2.3 建议

​ 最为常用： && || ！

### 5.8 三元运算符

#### 5.8.1 概述

##### 5.8.1.1 定义

​ 三元表达式或者问号冒号表达式。

##### 5.8.1.2 格式

​ 关系表达式 ？ 表达式 1 ：表达式 2 ；

细节：

*   计算关系表达式的值。
*   如果关系表达式的值为真，那么执行表达式 1。
*   如果关系表达式的值为假，那么执行表达式 2。

注意：

​ 三元运算符的最终结果一定要被使用，要么赋值给一个变量，要么直接打印出来。

#### 5.8.2 基本用例 - 三元运算符演示

```
public class OperatorDemo12 {
    public static void main(String[] args) {
        //需求：求两个数的较大值
        int a = 10;
        int b = 20;

        //格式：关系表达式 ？ 表达式1 ： 表达式2 ；
        //注意点：
        //三元运算符的最终结果一定要被使用。
        //要么赋值给一个变量，要么直接输出。
       int max =  a > b ? a : b ;
        System.out.println(max);


        System.out.println(a > b ? a : b);
    }
}

```

### 5.9 运算符的优先级

​ 在 Java 中涉及了很多的运算符，每一种运算符都有各自的优先级。但是这些优先级不需要记忆。咱们只要知道其中一点：**小括号优先于所有**

### 5.10 隐式转换

#### 5.10.1 定义

​ 在 Java 中，隐式转换就是把一个取值范围小的数据或者变量，赋值给另一个取值范围大的变量。此时不需要我们额外写代码单独实现，是程序自动帮我们完成的。也叫自动类型提升。换句话说，就是小的范围数据类型可以给大的范围数据类型，可以直接给

#### 5.10.2 提升规则

*   取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算。
*   byte、short、char 三种类型的数据在运算的时候，都会直接先提升为 int，然后再进行运算。

#### 5.10.3 取值范围关系

​ byte < short < int < long < float < double

### 5.11 强制转换

#### 5.11.1 概念

##### 5.11.1.1 定义

​ 如果要把一个取值范围大的数据或者变量赋值给另一个取值范围小的变量。是不允许直接操作。

##### 5.11.1.2 格式

​ 目标数据类型 变量名 = （目标数据类型）被强转的数据；

#### 5.11.2 基本用例 - 轻质转换演示

```
public class OperatorDemo2 {
    public static void main(String[] args) {
        double a = 12.3;
        int b = (int) a;
        System.out.println(b);//12
    }
}

```

注意点：

​ 强制转换有可能会导致数据发生错误。（数据的精度丢失）

### 5.12 中字符的 + 操作

#### 5.12.1 概念

​ 当 + 操作中出现了字符，会拿着字符到计算机内置的 ASCII 码表中去查对应的数字，然后再进行计算。

#### 5.12.2 基本用例 - 字符 + 演示

```
char c = 'a';
int result = c + 0;
System.out.println(result);//97

```

说明：

*   ASCII 码表中：
    
    1.  ‘a’ ----- 97
        
    2.  ‘A’ ----- 65
        

### 5.13 位移运算符

​ 在 Java 中，位移运算符是一种操作二进制位的运算符，它可以对整数类型的数据进行位移操作。Java 提供了三种位移运算符：左移（<<），右移（>>），无符号右移（>>>）

1.  左移（<<）：将一个数的二进制表示向左移动指定的位数，**右侧用零填充**。左移操作可以看作是对原数乘以 2 的移动位数次幂。例如，对于整数 a，a << b 表示将 a 的二进制表示向左移动 b 位。
2.  右移（>>）：将一个数的二进制表示向右移动指定的位数，根据最高位的符号位进行填充。右移操作可以看作是对原数除以 2 的移动位数次幂并取整。例如，对于整数 a，a >> b 表示将 a 的二进制表示向右移动 b 位。
3.  无符号右移（>>>）：将一个数的二进制表示向右移动指定的位数，无论最高位的符号位是什么，都用零填充。无符号右移操作会将符号位当作普通位处理，因此适用于无符号数的位移操作

​ 这些位移运算符在处理整数的二进制位时非常有用，常用于位操作、位标志的设置和清除，以及优化特定的算法。请注意，位移运算符仅适用于整数类型（如 int、long 等），不适用于浮点数类型。

## 6. 控制语句

笔记小结：

1.  流程控制语句
    
    1.  顺序结构：
        
        *   含义：按照编写顺序**依次**执行的结构
    2.  判断和选择结构
        
        *   含义：**根据条件**的不同而选择执行不同代码块的结构
            
        *   例如：
            
            ```
            if、switch
            
            ```
            
    3.  循环结构
        
        *   含义：**重复**执行某段代码的结构
            
        *   例如：
            
            ```
            while、do…while、for
            
            ```
            
        *   循环间的区别：1.for 和 while 循环，是先判断，再执行。2.do…while 是先执行，再判断
            
2.  条件控制语句
    
    *   含义：是一种程序**控制结构**，用于基于某些条件来执行或跳过代码块
        
    *   例如：
        
        ```
        break、continue
        
        ```
        
    *   **注意**：条件控制语句在非循环结构中，不能使用
        

### 6.1 概述

#### 6.1.1 定义

​ Java 控制语句是用于控制程序流程执行的语句，它们可以根据条件或循环来改变程序的执行顺序。控制语句可以帮助你实现不同的条件逻辑和循环结构，从而实现不同的任务和功能。

#### 6.1.2 分类

​ Java 控制语句分为：**流程控制语句**、**条件控制语句**

### 6.1 流程控制语句

#### 6.1.1 概述

##### 6.1.1.1 定义

​ 在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候要通过控制语句的执行顺序来实现我们想要的功能

##### 6.1.1.2 分类

*   顺序结构
    
*   判断和选择结构 (if, switch)
    
*   循环结构 (for, while, do…while)
    

#### 6.1.1 顺序结构

##### 6.1.1.1 定义

​ 顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构，按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的

##### 6.1.1.2 执行流程图

![](<assets/1740015220972.png>)

#### 6.1.2 判断结构–f 语句

*   **if 语句格式 1**

```
格式：
if (关系表达式) {
    语句体;	
}

```

执行流程：

①首先计算关系表达式的值

②如果关系表达式的值为 true 就执行语句体

③如果关系表达式的值为 false 就不执行语句体

④继续执行后面的语句内容

![](<assets/1740015221148.png>)

示例：

```
public class IfDemo {
	public static void main(String[] args) {
		System.out.println("开始");	
		//定义两个变量
		int a = 10;
		int b = 20;	
		//需求：判断a和b的值是否相等，如果相等，就在控制台输出：a等于b
		if(a == b) {
			System.out.println("a等于b");
		}		
		//需求：判断a和c的值是否相等，如果相等，就在控制台输出：a等于c
		int c = 10;
		if(a == c) {
			System.out.println("a等于c");
		}		
		System.out.println("结束");
	}
}

```

*   **f 语句格式 2**

```
格式：
if (关系表达式) {
    语句体1;	
} else {
    语句体2;	
}

```

执行流程：

①首先计算关系表达式的值

②如果关系表达式的值为 true 就执行语句体 1

③如果关系表达式的值为 false 就执行语句体 2

④继续执行后面的语句内容

![](<assets/1740015221384.png>)

示例：

```
public class IfDemo02 {
	public static void main(String[] args) {
		System.out.println("开始");		
		//定义两个变量
		int a = 10;
		int b = 20;
		//需求：判断a是否大于b，如果是，在控制台输出：a的值大于b，否则，在控制台输出：a的值不大于b
		if(a > b) {
			System.out.println("a的值大于b");
		} else {
			System.out.println("a的值不大于b");
		}		
		System.out.println("结束");
	}
}

```

**if 语句格式 3**

```
格式：
if (关系表达式1) {
    语句体1;	
} else if (关系表达式2) {
    语句体2;	
} 
…
else {
    语句体n+1;
}

```

执行流程：

①首先计算关系表达式 1 的值

②如果值为 true 就执行语句体 1；如果值为 false 就计算关系表达式 2 的值

③如果值为 true 就执行语句体 2；如果值为 false 就计算关系表达式 3 的值

④…

⑤如果没有任何关系表达式为 true，就执行语句体 n+1。

![](<assets/1740015221552.png>)

#### 6.1.3 选择结构–switch 语句

格式

```
switch (表达式) {
	case 1:
		语句体1;
		break;
	case 2:
		语句体2;
		break;
	...
	default:
		语句体n+1;
		break;
}

```

**执行流程：**

*   首先计算出表达式的值
    
*   其次，和 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结 束。
    
*   最后，如果所有的 case 都和表达式的值不匹配，就会执行 default 语句体部分，然后程序结束掉。
    
*   default 的位置和省略情况
    
    default 可以放在任意位置，也可以省略
    
*   case 穿透
    
    不写 break 会引发 case 穿透现象
    
*   switch 在 JDK12 的新特性
    

```
int number = 10;
switch (number) {
    case 1 -> System.out.println("一");
    case 2 -> System.out.println("二");
    case 3 -> System.out.println("三");
    default -> System.out.println("其他");
}

```

*   switch 和 if 第三种格式各自的使用场景

当我们需要对一个范围进行判断的时候，用 if 的第三种格式

当我们把有限个数据列举出来，选择其中一个执行的时候，用 switch 语句

比如：

​ 小明的考试成绩，如果用 switch，那么需要写 100 个 case，太麻烦了，所以用 if 简单。

​ 如果是星期，月份，客服电话中 0~9 的功能选择就可以用 switch

#### 6.1.4 循环结构

##### 6.1.4.1for 循环结构（掌握）

​ 循环语句可以在满足循环条件的情况下，反复执行某一段代码，这段被重复执行的代码被称为循环体语句，当反复 执行这个循环体时，需要在合适的时候把循环判断条件修改为 false，从而结束循环，否则循环将一直执行下去，形 成死循环。

for 循环格式：

```
for (初始化语句;条件判断语句;条件控制语句) {
	循环体语句;
}

```

格式解释：

*   初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样
*   条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去
*   循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情
*   条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去

**执行流程：**

①执行初始化语句

②执行条件判断语句，看其结果是 true 还是 false

​ 如果是 false，循环结束

​ 如果是 true，继续执行

③执行循环体语句

④执行条件控制语句

⑤回到②继续

**for 循环书写技巧：**

*   确定循环的开始条件
*   确定循环的结束条件
*   确定循环要重复执行的代码

代码示例：

```
//1.确定循环的开始条件
//2.确定循环的结束条件
//3.确定要重复执行的代码

//需求：打印5次HelloWorld
//开始条件：1
//结束条件：5
//重复代码：打印语句

for (int i = 1; i <= 5; i++) {
    System.out.println("HelloWorld");
}

```

##### 6.1.4.2while 循环

格式：

```
初始化语句;
while(条件判断语句){
	循环体;
	条件控制语句;
}

```

##### 6.1.4.3do…while 循环

本知识点了解即可

格式：

```
初始化语句;
do{
    循环体;
    条件控制语句;
}while(条件判断语句);

```

特点：

​ 先执行，再判断。

##### 6.1.4.4 三种格式的区别

​ for 和 while 循环，是先判断，再执行。

​ do…while 是先执行，再判断。

​ 当知道循环次数或者循环范围的时候，用 for 循环。

​ 当不知道循环次数，也不知道循环范围，但是知道循环的结束条件时，用 while 循环。

##### 6.1.4.4 无限循环

概念：

​ 又叫死循环。循环一直停不下来。

**for 格式：**

```
for(;;){
    System.out.println("循环执行一直在打印内容");
}

```

解释：

初始化语句可以空着不写，表示循环之前不定义任何的控制变量。

条件判断语句可以空着不写，如果不写，默认表示 true，循环一直进行。

条件控制语句可以空着不写，表示每次循环体执行完毕后，控制变量不做任何变化。

**while 格式：**

```
while(true){
    System.out.println("循环执行一直在打印内容");
}

```

解释：

​ 小括号里面就不能省略了，true 一定要写出来，否则代码会报错。

**do…while 格式：**

```
do{
    System.out.println("循环执行一直在打印内容");
}while(true);

```

解释：

​ 小括号里面就不能省略了，true 一定要写出来，否则代码会报错。

无限循环的注意事项：

*   最为常用的格式：while
*   无限循环下面不能再写其他代码了，因为永远执行不到。

### 6.2 条件控制语句

*   break
*   continue

#### 6.2.1break

​ 不能单独存在的。可以用在 switch 和循环中，表示结束，跳出的意思。

代码示例：

```
//1.吃1~5号包子
for (int i = 1; i <= 5; i++) {
    System.out.println("在吃第" + i + "个包子");
    //2.吃完第三个的时候就不吃了
    if(i == 3){
        break;//结束整个循环。
    }
}

```

#### 6.2.2continue

​ 不能单独存在的。只能存在于循环当中。

​ 表示：跳过本次循环，继续执行下次循环。

代码示例：

```
//1.吃1~5号包子
for (int i = 1; i <= 5; i++) {
    //2.第3个包子有虫子就跳过，继续吃下面的包子
    if(i == 3){
        //跳过本次循环（本次循环中，下面的代码就不执行了），继续执行下次循环。
        continue;
    }
    System.out.println("在吃第" + i + "个包子");
}

```

Random 跟 Scanner 一样，也是 Java 提前写好的类，我们不需要关心是如何实现的，只要直接使用就可以了。

## 7. 数组

笔记小结：

1.  定义：数组指的是一种**容器**，可以同来存储同种数据类型的多个值
    
2.  定义方式：
    
    *   格式一：
        
        ```
        数据类型 [] 数组名;
        //例如
        int [] array;
        
        ```
        
    *   格式二：
        
        ```
        数据类型  数组名 [];
        //例如
        int array [];
        
        ```
        
    *   注意：不同的数据类型对应不同的默认值
        
        *   整数类型：0
        *   小数类型：0.0
        *   布尔类型：false
        *   字符类型：‘\u0000’
        *   引用类型：null
3.  静态数组初始化：
    
    *   格式一：
        
        ```
        数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...};
        //例如
        double[] arr = new double[]{1.1,1.2,1.3};
        
        ```
        
    *   格式二：
        
        ```
        数据类型[] 数组名 = {元素1，元素2，元素3，元素4...};
        //例如
        int[] array = {1,2,3,4,5};
        
        ```
        
4.  动态数组初始化：
    
    *   格式：
        
        ```
        数据类型[] 数组名 = new 数据类型[数组的长度];
        //例如
        double[] arr = new double[10];
        
        ```
        
5.  数组动态初始化与数组的静态初始化的区别：
    
    1.  **语法**不同
    2.  **数组长度**不同
    3.  **赋值时机**不同
    4.  注意：无论是何种数组，数组的最大长度为，数组的长度 - 1。例如：arr.length - 1
6.  地址值：
    
    *   含义：数组的地址值是指向数组对象的**指针或引用**
        
    *   例如：
        
        ```
        int[] arr = {1,2,3,4,5};
        System.out.println(arr);	//[I@6d03e736
        /*
        [ ：表示现在打印的是一个数组。
        I：表示现在打印的数组是int类型的。
        @：仅仅是一个间隔符号而已。
        6d03e736：就是数组在内存中真正的地址值。（十六进制的）
        */
        
        ```
        
7.  索引：
    
    *   含义：用来**标识**它在数组中的**位置**
        
    *   例如：
        
        ```
        arr[0]、arr[1]、……
        
        ```
        
    *   特点：
        
        1.  起始值为 0
        2.  连续不间断
        3.  逐个 + 1 增长。
8.  数组元素访问
    
    *   含义：根据索引访问数组中的值
    *   格式：数组名 [索引];
9.  遍历
    
    *   含义：依次取出元组中的元素
        
    *   格式：
        
        ```
        for(int i = 0; i < arr.length; i++){
            //在循环的过程中，i依次表示数组中的每一个索引
            sout(arr[i]);//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。
        }
        
        ```
        
        说明：arr.length 表示获取数组的长度
        

### 7.1 概述

#### 7.1.1 定义

​ 在 Java 中，数组指的是一种**容器**，可以同来存储同种数据类型的多个值。但是数组容器在存储数据的时候，需要结合隐式转换考虑

注意：数组中的隐式转换

*   ​ 定义了一个 int 类型的数组。那么 boolean。double 类型的数据是不能存到这个数组中的，但是 byte 类型，short 类型，int 类型的数据是可以存到这个数组里面的

#### 7.1.2 建议

​ 容器的类，和存储的数据类型保持一致

说明：

*   整数 1 2 3 4 56 就可以使用 int 类型的数组来存储。
*   小数 1.1 1.2 1.3 1.4 就可以使用 double 类型的数组来存储。
*   字符串 "aaa" “bbb” “ccc” 就可以使用 String 类型的数组来存储。

### 7.2 数组定义

#### 7.2.1 格式一

```
数据类型 [] 数组名
# 例如
int [] array

```

#### 7.2.2 格式二

```
数据类型  数组名 []
# 例如
int array []

```

细节：

*   数据类型：限定了数组以后能存什么类型的数据。
    *   数组的默认初始化值：
        1.  整数类型：0
        2.  小数类型：0.0
        3.  布尔类型：false
        4.  字符类型：‘\u0000’
        5.  引用类型：null
*   方括号：表示现在定义的是一个数组。
*   数组名：就是一个名字而已，方便以后使用。

注意：

​ 方法括号跟数组名，谁写在前面，谁写在后面都是一样的

### 7.3 数组的静态初始化

```
/* 完整格式：
数据类型[] 数组名 = new 数据类型[]{元素1，元素2，元素3，元素4...}; */
int[] arr = new int[]{11,22,33};
double[] arr = new double[]{1.1,1.2,1.3};
/* 简化格式：
数据类型[] 数组名 = {元素1，元素2，元素3，元素4...}; */
int[] array = {1,2,3,4,5};
double[] array = {1.1,1.2,1.3};

```

细节：

*   数据类型：限定了数组以后能存什么类型的数据
*   方括号：表示现在定义的是一个数组
*   数组名：其实就是名字而已，方便以后使用，在起名字的时候遵循小驼峰命名法
*   new：就是给数组在内存中开辟了一个空间
*   大括号：表示数组里面的元素。元素也就是存入到数组中的数据。多个元素之间，一定要用逗号隔开

注意：

*   前面和后面的数据类型一定要保持一致
*   数组一旦创建之后，长度不能发生变化

### 7.4 数组的动态初始化

```
/* 格式：
数据类型[] 数组名 = new 数据类型[数组的长度]; */
int[] agesArr = new int[3];
int[] scoresArr = new int[10];

```

### 7.5 地址值

```
int[] arr = {1,2,3,4,5};
System.out.println(arr);//[I@6d03e736

double[] arr2 = {1.1,2.2,3.3};
System.out.println(arr2);//[D@568db2f2

```

细节：

*   打印数组的时候，实际出现的是数组的地址值。数组的地址值：就表示数组在内存中的位置。
    
*   地址详细介绍
    
    ```
    /*
    以[I@6d03e736为例：
    [ ：表示现在打印的是一个数组。
    I：表示现在打印的数组是int类型的。
    @：仅仅是一个间隔符号而已。
    6d03e736：就是数组在内存中真正的地址值。（十六进制的）
    但是，我们习惯性会把[I@6d03e736这个整体称之为数组的地址值
    */
    
    ``` 

### 7.6 索引

#### 7.6.1 定义

​ 在 Java 中，索引也叫角标、下标。换句话说，就是数组容器中每一个小格子对应的编号。

#### 7.6.2 特点

*   索引一定是从 0 开始的。
*   连续不间断。
*   逐个 + 1 增长。

### 7.7 数组元素访问

#### 7.7.1 作用

*   获取数组中对应索引上的值
    
*   修改数组中对应索引上的值，一旦修改之后，原来的值就会被覆盖
    

#### 7.7.2 基本用例 - 数组访问演示

```
public class ArrDemo2 {
    /*

        数组中元素访问的格式：
                数组名[索引];

         作用：
            1.获取指定索引上对应的元素
            2.修改指定索引上对应的元素


    */
    public static void main(String[] args) {
       int[] arr = {1,2,3,4,5};
       //需求1：获取arr数组中，3索引上的值
        int number = arr[3];
        System.out.println(number);
        System.out.println(arr[3]);

       //需求2：将arr数组中，3索引上的值修改为10
            arr[3] = 10;
        System.out.println("修改之后为:" + arr[3]);

    }
}

```

### 7.8 数组的遍历

#### 7.8.1 遍历

​ 就是把数组里面所有的内容一个一个全部取出来。

#### 7.8.2 基本用例 - 数组遍历演示

```
/* 格式：
数组名.length */
for(int i = 0; i < arr.length; i++){
    //在循环的过程中，i依次表示数组中的每一个索引
    sout(arr[i]);//就可以把数组里面的每一个元素都获取出来，并打印在控制台上了。
}

```

### 7.9 数组两种初始化方式的区别

#### 7.9.1 静态初始化

```
int[] arr = {1,2,3,4,5};

```

说明：

​ 手动指定数组的元素，系统会根据元素的个数，计算出数组的长度。

#### 7.9.2 动态初始化

```
int[] arr = new int[3];

```

说明：

​ 手动指定数组长度，由系统给出默认初始化值。

#### 7.9.3 应用场景

*   只明确元素个数，但是不明确具体的数据，推荐使用动态初始化。

说明：

```
// 使用数组来存储键盘录入的5个整数。
int[] arr = new int[5];

``` 

*   已经明确了要操作的所有数据，推荐使用静态初始化。

说明：

```
// 将全班的学生成绩存入数组中，已知学生成绩为：66,77,88,99,100
int[] arr = {66,77,88,99,100}

``` 

#### 7.9.4 数组常见问题

**索引越界**

```
public class ArrDemo6 {
    public static void main(String[] args) {
       int[] arr = {1,2,3,4,5,5,5,5,5};
        //用索引来访问数组中的元素
        System.out.println(arr[1]);
        System.out.println(arr[10]);//ArrayIndexOutOfBoundsException

    }
}

```

说明：针对于任意一个数组，索引的范围

1.  最小索引：0
2.  最大索引：
    *   数组的长度 - 1
    *   数组名. length - 1

## 8. 代码块

笔记小结：

1.  局部代码块：略
    
2.  构造代码块：略
    
3.  静态代码块（重点）
    
    *   含义：被 static 修饰的代码块
        
    *   基本用例：
        
        ```
        /*格式：
        static{}，需要通过static关键字修饰 */
        static{
        
        }
        // 当类加载时，此代码块就会被加载
        
        ```
        
    *   特点：随着类的加载而加载，并且自动出发，只执行一次
        

### 8.1 局部代码块

```
public class CodeBlockLearn {
    public static void main(String[] args) {
        {
            int a=10;
            System.out.println(a);
        }
    }
}

```

说明：

*   应用场景：那么当超出了方括号，变量 a 也就不存在了，有着提前释放变量的作用

### 8.2 构造代码块

*   卸载成员位置的代码块，可以把多个构造方法中重复的代码抽取出来
*   执行时机: 我们在**创建本类对象的时**候会先执行构造代码块再执行构造方法

说明：

​ 构造代码块优先于构造方法而执行的

### 8.3 静态代码块（重点）

```
/*格式：
static{}，需要通过static关键字修饰 */
public class MyClass {
    static {
        System.out.println("静态代码块执行了");
    }
 
    public static void main(String[] args) {
        System.out.println("主方法执行了");
    }
}

```

说明：

*   执行时机：随着类的加载而加载，并且自动出发，只执行一次
*   使用场景：在类加载时，做一些初始化的操作

## 9. 关键字

笔记小结：见各模块

### 9.1this 关键字

笔记小结：

*   定义：当我们在一个类中使用 `this` 时，它指的是**该类的当前对象**。
    
*   基础用例：
    
    ```
     public class Person {
        private String name;
        private int age;
    
        public Person(String name, int age) {
                      this.name = name; //使用this关键字引用当前对象的成员变量name
            this.age = age; //使用this关键字引用当前对象的成员变量age
        }
    }
    
    ``` 

定义：在 Java 中，this 是一个关键字，表示当前对象。它可以用于访问当前对象的属性和方法。

基本用例

```
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name; //使用this关键字引用当前对象的成员变量name
        this.age = age; //使用this关键字引用当前对象的成员变量age
    }
}

```

说明：

​ 当我们在一个类中使用 `this` 时，它指的是该类的当前对象。

### 9.2static 关键字

笔记小结：

*   定义：static 是一个关键字，用于修饰类的成员变量、成员方法和代码块，其作用是将这些成员变量、成员方法和代码块与类本身关联，而不是与类的实例对象关联
    
*   **静态变量**及其访问
    
    1.  含义：static 修饰类的成员变量
        
    2.  定义：
        
        ```
        /* 格式：
        	修饰符 static 数据类型 变量名 = 初始值；*/
        public static String schoolName = "传智播客"；  
        
        ```
        
    3.  访问：
        
        ```
        /* 格式：
        	类名.静态变量 */
        System.out.println(Student.schoolName); // 传智播客
        
        ```
        
*   **实例变量**及其访问
    
    1.  含义：无 static 修饰类的成员变量
        
    2.  定义：
        
        ```
        /* 格式：
        	修饰符 数据类型 变量名 = 初始值；  */
        public String schoolName = "传智播客"；  
        
        ```
        
    3.  访问：
        
        ```
        /* 格式：
        	对象.方法名 */
        Student stu = new Student();
        System.out.println(stu.schoolName);
        
        ```
        
    4.  注意：
        
        *   实例变量是属于每个对象，必须**创建**类的**对象**才可以访问
        *   静态变量**不属于成员对象**，属于类。该**静态变量的加载随着类的加载而加载**，优先于对象存在
*   **静态方法**及其访问
    
    1.  含义：static 修饰类的成员方法
        
    2.  定义：
        
        ```
        /* 格式：
        	修饰符 static 类型 方法名() */
        public static void study(){ // 类方法或者静态方法。
            System.out.println("我们都在黑马程序员学习");   
        }
        
        ```
        
    3.  访问：通过类名. 方法名 ()
        
        ```
        /* 格式：
        	类名.方法名() */
        Student.study();
        
        ```
        
    4.  注意：实例方法是属于每个对象，必须**创建**类的**对象**才可以访问
        
*   **实例方法**及其访问
    
    1.  含义：无 static 修饰类的成员方法
        
    2.  定义：
        
        ```
        /* 格式：
        	修饰符 类型 方法名()*/
        public void study(){ // 类方法或者静态方法。
            System.out.println("我们都在黑马程序员学习");   
        }
        
        ```
        
    3.  访问：需要 new 对象
        
        ```
        /* 格式：
        	对象.方法名 */
        Student stu = new Student();
        System.out.println(stu.study());
        
        ```
        
*   **内存图**：
    
    1.  当使用了 static 关键字，会在堆内存中开辟一个名叫 “**静态存储位置**” 的内存空间
    2.  静态方法**不能访问非静态资源**
    3.  静态方法**不能调用实例变量**
    4.  **非静态**资源可以访问**所有**
    5.  注意，静态成员的**生命周期**与类的生命周期**一样长**

#### 9.2.1 概述

​ static 是一个关键字，用于修饰类的成员变量、成员方法和代码块，其作用是将这些成员变量、成员方法和代码块与类本身关联，而不是与类的实例对象关联

#### 9.2.1 静态变量及其访问

##### 9.2.1.1 概述

​ 有 static 修饰成员变量，说明这个成员变量是属于类的，这个成员变量称为**类变量**或者**静态成员变量**。 直接用 类名访问即可。因为类只有一个，所以静态成员变量在内存区域中也只存在一份。所有的对象都可以共享这个变量。

##### 9.2.1.2 基本用例 - static 关键字使用

```
/* 格式：
	修饰符 static 数据类型 变量名 = 初始值；*/    
public class Student {
    public static String schoolName = "传智播客"； // 类变量或者静态成员变量
    // .....
}

```

##### 9.2.1.3 访问

```
/*格式：
	类名.静态变量	*/
public static void  main(String[] args){
    System.out.println(Student.schoolName); // 传智播客
    Student.schoolName = "黑马程序员";
    System.out.println(Student.schoolName); // 黑马程序员
}

```

#### 9.2.2 实例变量及其访问

##### 9.2.2.1 概述

​ 无 static 修饰的成员变量属于每个对象的， 这个成员变量叫**实例变量**，之前我们写成员变量就是实例成员变量。

##### 9.2.2.2 基本用例 - 实例变量使用

```
public class Student {
    public  String schoolName = "传智播客"； // 成员变量
    // .....
}

```

##### 9.2.2.3 访问

```
/* 格式：
	对象.实例成员变量 */
public static void main(String[] args) {
    Student stu = new Student();
    System.out.println(stu.schoolName);
}

```

细节：

​ 实例成员变量属于每个对象，必须**创建类的对象**才可以访问。

#### 9.2.3 静态方法及其访问

##### 9.2.3.1 概述

​ 有 static 修饰成员方法，说明这个成员方法是属于类的，这个成员方法称为**类方法或者**静态方法。 直接用 类名访问即可。因为类只有一个，所以静态方法在内存区域中也只存在一份。所有的对象都可以共享这个方法。

​ 与静态成员变量一样，静态方法也是直接通过**类名. 方法名称**即可访问。

##### 9.2.3.2 基本用例

```
public class Student{
    public static String schoolName = "传智播客"； 
        // .....
        public static void study(){ // 类方法或者静态方法。
        System.out.println("我们都在黑马程序员学习");   
    }
}

```

##### 9.2.3.2 访问

```
/* 格式：
	类名.静态方法*/
public static void  main(String[] args){
    Student.study();
}

```

#### 9.2.4 实例方法及其访问

##### 9.2.4.1 概述

无 static 修饰的成员方法属于每个对象的，这个成员方法也叫做**实例方法**。

细节

​ 实例方法是属于每个对象，必须创建类的对象才可以访问

##### 9.2.4.2 基本用例 - 实例方法使用

```
/*格式：
	对象.实例方法*/
public class Student {
    // 实例变量
    private String name ;
    // 2.方法：行为
    // 无 static修饰，实例方法。属于每个对象，必须创建对象调用
    public void run(){
        System.out.println("学生可以跑步");
    }
	// 无 static修饰，实例方法
    public  void sleep(){
        System.out.println("学生睡觉");
    }
    public static void study(){
        
    }
}

```

##### 9.2.4.3 访问

```
public static void main(String[] args){
    // 创建对象 
    Student stu = new Student ;
    stu.name = "徐干";
    // Student.sleep();// 报错，必须用对象访问。
    stu.sleep();
    stu.run();
}

```

**小结**

1. 当 `static` 修饰成员变量或者成员方法时，该变量称为**静态变量**，该方法称为**静态方法**。该类的每个对象都**共享**同一个类的静态变量和静态方法。任何对象都可以更改该静态变量的值或者访问静态方法。但是不推荐这种方式去访问。因为静态变量或者静态方法直接通过类名访问即可，完全没有必要用对象去访问。

2. 无 static 修饰的成员变量或者成员方法，称为**实例变量，实例方法**，实例变量和实例方法必须创建类的对象，然后通过对象来访问。

3.static 修饰的成员属于类，会存储在静态区，是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。

4. 无 static 修饰的成员，是属于对象，对象有多少个，他们就会出现多少份。所以必须由对象调用。

#### 9.2.5Static 内存图（重点）

静态方法

![](<assets/1740015221738.png>)

说明：

若想让类中的某个成员变量被共享，可以将它变为 static 给修饰，这就是 **static 的内存中的执行流程**

补充：

方法入栈后会退出

注意事项：静态方法不能访问非静态

![](<assets/1740015222115.png>)

说明：

1.  若 name 是非 static 修饰，则不会出现在堆内存中的静态存储位置，因此**静态方法不能访问非静态**
2.  现在堆内存中并没有任何实例过的对象，因此**静态方法不能调用实例变量**

补充：

main 方法中读取到 Student.teacherName 方法的 Student 时，会把 Student.class 字节码文件加载到方法区

![](<assets/1740015222296.png>)

说明：

假如 method 方法中可以调用 show 方法，那么在栈内存中，这个？？？.show 方法又是谁来进行调用，正常来说应该是由一个对象来进行调用，因此**静态方法不能访问非静态**

补充：

静态成员的生命周期与类的生命周期一样长，也就是说，当类被加载时，静态成员就被分配内存；当类被卸载时，静态成员所占用的内存也被释放。

#### 9.2.6Static 修饰成员变量和成员方法

![](<assets/1740015222559.png>)

#### 9.2.7 工具类常用 Static

帮助我们做一些事情的, 但是不描述任何事物的类

1. 有同学没听懂，我这里解释一下，上节课说到**静态变量先于类创建**

2. 意思就是我先加载静态变量，再创建类，是按照这个步骤来的

3. 那么 ，如果这个类只有方法，也就是工具类，我没必要创建这个类

4. 因为我可以先于这个类直接调用方法，而只有静态方法可以优先被创建

#### 9.2.8Static 弊端

1.  静态变量生命周期过长：静态变量在整个程序运行期间都存在，可能会导致**占用大量的内存空间**，影响程序的性能
2.  静态变量的并发访问问题：多个线程同时访问静态变量时可能会发生**并发访问**的问题，导致数据不一致或其他错误
3.  静态方法不能被子类覆盖：由于静态方法是属于类的，而非对象的，因此它们不能被子类覆盖，这**限制了程序的灵活性**
4.  静态方法调用非静态方法或变量时需要创建对象：由于静态方法属于类，**无法直接访问非静态的方法或变量**，因此需要通过创建对象来访问
5.  静态代码块无法处理异常：静态代码块中的语句无法**处理异常**，只能通过抛出异常来处理。

[static 静态方法执行–内存分析_静态方法运行时存在的_qingdao_java 的博客 - CSDN 博客](https://blog.csdn.net/jiaxuebingzhaojin/article/details/89913017)

### 9.3final 关键字

笔记小结：

*   定义：`final` 是一个关键字，它可以用来修饰变量、方法和类，表示**不可改变**的、**终态**的。
    
*   修饰变量：
    
    1.  局部变量：表示它的值不能被改变，即该变量为常量。变量值**不可被修改**
        
        ```
           final int a;
           a = 10;
        
        ```
        
    2.  成员变量：表示它的值不能被改变，即该变量为常量。变量只可在定义成员变量的时候**立马赋值**
        
        ```
         final int num = 10;
        
        ```
        
    3.  变量明明规范：单个单词全部**大写**，多个单词间使用**下划线隔开**
        
*   修饰方法：表示该方法**不能**被子类**重写**（覆盖）
    
    ```
    final public void show1() {
    		System.out.println("Fu2 show1");
    	}
    
    ```
    
*   修饰类：表示该类被称为称为最终类（或不可扩展类），因为**不能被**其余类**继承**
    
    ```
    final class Fu {
    }
    
    ```
    
*   细节：
    
    1.  final 修饰的变量是**基本类型**: 那么变量存储的**数据值不能发生改变**
    2.  final 修饰的变量是**引用类型**: 那么变量存储的**地址值不能发生改变**，是其指向的对象的**内容可以被修改**

#### 9.3.1 概述

`final` 是一个关键字，它可以用来修饰变量、方法和类，表示不可改变的、终态的。

1.  修饰变量：
    *   `final` 修饰的变量表示常量，一旦被赋值后，就**不能再被改变**。
    *   `final` 声明的变量必须在声明时或者在构造器中初始化，否则编译器会报错。
    *   声明 `final` 变量时，一般使用全大写字母和下划线来表示。
2.  修饰方法：
    *   `final` 修饰的方法表示该方法不**能被子类重写或覆盖**。
    *   当一个类被声明为 `final` 时，其中所有的方法都会自动地成为 `final`，但是实例变量不会受到影响。
3.  修饰类：
    *   `final` 修饰的类表示该类**不能被继承**。
    *   使用 `final` 修饰类可以保证该类的行为不会被改变，也可以提高代码的安全性和可靠性。

#### 9.3.2 修饰变量

##### 9.3.2.1 局部变量（重点）

```
public class FinalDemo1 {
    public static void main(String[] args) {
        // 声明变量，使用final修饰
        final int a;
        // 第一次赋值 
        a = 10;
        // 第二次赋值
        a = 20; // 报错,不可重新赋值

        // 声明变量，直接赋值，使用final修饰
        final int b = 10;
        // 第二次赋值
        b = 20; // 报错,不可重新赋值
    }
}

```

说明：

​ 基本类型的局部变量，被 final 修饰后，只能赋值一次，不能再更改。

##### 9.3.2.2 成员变量（重点）

成员变量涉及到初始化的问题，初始化方式有显示初始化和构造方法初始化，只能选择其中一个：

*   显示初始化 (在定义成员变量的时候立马赋值)（常用）；

```
public class Student {
    final int num = 10;
}

```

*   构造方法初始化 (在构造方法中赋值一次)（不常用，了解即可）。
    
    **注意：每个构造方法中都要赋值一次！**
    

```
public class Student {
    final int num = 10;
    final int num2;

    public Student() {
        this.num2 = 20;
//     this.num2 = 20;
    }
    
     public Student(String name) {
        this.num2 = 20;
//     this.num2 = 20;
    }
}

```

说明：

​ 被 final 修饰的常量名称，一般都有书写规范，所有字母都**大写**。

#### 9.3.3 修饰方法

##### 9.3.3.1 概述

final 修饰的方法，不能被重写

##### 9.3.3.2 基本用例 - 修饰方法演示

```
/* 格式：
修饰符 final 返回值类型 方法名(参数列表){
    //方法体
} */
class Fu2 {
	final public void show1() {
		System.out.println("Fu2 show1");
	}
	public void show2() {
		System.out.println("Fu2 show2");
	}
}

class Zi2 extends Fu2 {
//	@Override
//	public void show1() {
//		System.out.println("Zi2 show1");
//	}
	@Override
	public void show2() {
		System.out.println("Zi2 show2");
	}
}

```

#### 9.3.4 修饰类

##### 9.3.4.1 概述

final 修饰的类，不能被继承

##### 9.3.4.2 基本用例 - 修饰类使用

```
/* 格式：
	final class 类名 {
	} 	*/
final class Fu {
}
// class Zi extends Fu {} // 报错,不能继承final的类

```

说明：

​ 查询 API 发现像 `public final class String` 、`public final class Math` 、`public final class Scanner` 等，很多我们学习过的类，都是被 final 修饰的，目的就是供我们使用，而不让我们所以改变其内容。

### 9.4private 关键字

笔记小结：

1.  概述：用于修饰类的成员变量和方法的修饰符
2.  作用：**防止**外部程序对对象的数据进行非法访问和操作

#### 9.4.1 概述

​ private 是一个修饰符，可以用来修饰成员（成员变量，成员方法）

说明：

​ 被 private 修饰的成员，只能在本类进行访问，针对 private 修饰的成员变量，如果需要被其他类使用，提供相应的操作

细节：

*   提供 “get 变量名()” 方法，用于获取成员变量的值，方法用 public 修饰
*   提供 “set 变量名(参数)” 方法，用于设置成员变量的值，方法用 public 修饰

#### 9.4.2 基本用例 - private 关键字使用

```
/*
    学生类
 */
class Student {
    //成员变量
    String name;
    private int age;

    //提供get/set方法
    public void setAge(int a) {
        if(a<0 || a>120) {
            System.out.println("你给的年龄有误");
        } else {
            age = a;
        }
    }

    public int getAge() {
        return age;
    }

    //成员方法
    public void show() {
        System.out.println(name + "," + age);
    }
}
/*
    学生测试类
 */
public class StudentDemo {
    public static void main(String[] args) {
        //创建对象
        Student s = new Student();
        //给成员变量赋值
        s.name = "林青霞";
        s.setAge(30);
        //调用show方法
        s.show();
    }
}

```

#### 9.4.3 案例 - private 的使用

*   需求：定义标准的学生类，要求 name 和 age 使用 private 修饰，并提供 set 和 get 方法以及便于显示数据的 show 方法，测试类中创建对象并使用，最终控制台输出 林青霞，30
    
*   示例代码：
    
    ```
    /*
        学生类
     */
    class Student {
        //成员变量
        private String name;
        private int age;
    
        //get/set方法
        public void setName(String n) {
            name = n;
        }
    
        public String getName() {
            return name;
        }
    
        public void setAge(int a) {
            age = a;
        }
    
        public int getAge() {
            return age;
        }
    
        public void show() {
            System.out.println(name + "," + age);
        }
    }
    /*
        学生测试类
     */
    public class StudentDemo {
        public static void main(String[] args) {
            //创建对象
            Student s = new Student();
    
            //使用set方法给成员变量赋值
            s.setName("林青霞");
            s.setAge(30);
    
            s.show();
            //使用get方法获取成员变量的值
            System.out.println(s.getName() + "---" + s.getAge());
            System.out.println(s.getName() + "," + s.getAge());
    
        }
    }
    
    ```
    

### 9.5this 关键字

笔记小结：

1.  含义：**this 的本质就是所在方法调用者的地址值**
2.  内存图：
    *   方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，而不是成员变量
    *   方法的形参**没有**与成员变量同名，不带 this 修饰的变量指的是成员变量

**this 关键字内存原理（重点）**

![](<assets/1740015222833.png>)

![](<assets/1740015223186.png>)

说明：

方法执行完成后会出栈

总结一句话：**this 的本质就是所在方法调用者的地址值**

this 修饰的变量用于指代成员变量，其主要作用是（区分局部变量和成员变量的重名问题）

*   方法的形参如果与成员变量同名，不带 this 修饰的变量指的是形参，带 this 修饰的变量是成员变量
*   方法的形参没有与成员变量同名，不带 this 修饰的变量指的是成员变量

```
public class Student {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void show() {
        System.out.println(name + "," + age);
    }
}

```

### 9.6super 关键字

笔记小结：

1.  含义：表示**父类对象的引用**，可以用来调用父类的**构造方法**、**实例方法**和**实例变量**
    
2.  用法格式：
    
    ```
    this.成员变量    	--    本类的
    super.成员变量    	--    父类的
    
    this.成员方法名()  	--    本类的    
    super.成员方法名()   --    父类的
    
    super(...) -- 调用父类的构造方法，根据参数匹配确认
    this(...) -- 调用本类的其他构造方法，根据参数匹配确认
    
    ```
    
3.  super 用法示例：
    
    *   super() 和 this() 都必须是在构造方法的第一行，所以**不能同时出现**
    *   super(…) 是根据参数去确定调用父类哪个构造方法的
4.  内存图：
    
    ![](<assets/1740015223435.png>)
    
5.  细节：
    
    *   **子类的每个构造方法中均有默认的 super()，调用父类的空参构造。手动调用父类构造会覆盖默认的 super()**
        
    *   **super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现**
        
    *   **super() 和 this() 是根据参数去确定调用父类哪个构造方法的**
        
    *   super( ) 可以调用父类构造方法初始化继承自父类的成员变量的数据
        
    *   this( ) 可以调用本类中的其他构造方法
        

#### 9.6.1 概述

​ 在 Java 中 super 关键字，表示父类对象的引用，可以用来调用父类的构造方法、实例方法和实例变量

```
class Person {
    private String name;
    private int age;

    public Person() {
        System.out.println("父类无参");
    }

    // getter/setter省略
}

class Student extends Person {
    private double score;

    public Student() {
        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行
        System.out.println("子类无参");
    }
    
     public Student(double score) {
        //super();  // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行
        this.score = score;    
        System.out.println("子类有参");
     }
      // getter/setter省略
}

public class Demo07 {
    public static void main(String[] args) {
        // 调用子类有参数构造方法
        Student s2 = new Student(99.9);
        System.out.println(s2.getScore()); // 99.9
        System.out.println(s2.getName()); // 输出 null
        System.out.println(s2.getAge()); // 输出 0
    }
}

```

说明：

​ 我们发现，子类有参数构造方法只是初始化了自己对象中的成员变量 score，而父类中的成员变量 name 和 age 依然是没有数据的，怎么解决这个问题呢，我们可以借助与 super(…) 去调用父类构造方法，以便初始化继承自父类对象的 name 和 age

#### 9.6.3 基本用例 - super 关键字使用

```
/* 格式：
    super.成员变量    	--    父类的
    super.成员方法名()   --    父类的 */
class Person {
    private String name ="凤姐";
    private int age = 20;

    public Person() {
        System.out.println("父类无参");
    }
    
    public Person(String name , int age){
        this.name = name ;
        this.age = age ;
    }

    // getter/setter省略
}

class Student extends Person {
    private double score = 100;

    public Student() {
        //super(); // 调用父类无参构造方法,默认就存在，可以不写，必须再第一行
        System.out.println("子类无参");
    }
    
     public Student(String name ， int age，double score) {
        super(name ,age);// 调用父类有参构造方法Person(String name , int age)初始化name和age
        this.score = score;    
        System.out.println("子类有参");
     }
      // getter/setter省略
}

public class Demo07 {
    public static void main(String[] args) {
        // 调用子类有参数构造方法
        Student s2 = new Student("张三"，20，99);
        System.out.println(s2.getScore()); // 99
        System.out.println(s2.getName()); // 输出 张三
        System.out.println(s2.getAge()); // 输出 20
    }
}

```

**注意：**

*   子类的每个构造方法中均有默认的 super()，调用父类的空参构造。手动调用父类构造会覆盖默认的 super()。
    
*   super() 和 this() 都必须是在构造方法的第一行，所以**不能同时出现**。
    
*   super(…) 是根据参数去确定调用父类哪个构造方法的。
    

#### 9.6.4 内存图

**父类空间优先于子类对象产生**

​ 在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空间，便可以包含其父类的成员，如果父类成员非 private 修饰，则子类可以随意使用父类成员。代码体现在子类的构造器调用时，一定先调用父类的构造方法。理解图解如下：

![](<assets/1740015223834.png>)

#### 9.6.5this( ) 基本用例

this(…)

*   默认是去找本类中的其他构造方法，**根据参数来确定**具体调用哪一个构造方法。
*   为了借用其他构造方法的功能。

```
/* 格式：
	this.成员变量    	--    本类的
	this.成员方法名()  	--    本类的    */
package com.itheima._08this和super调用构造方法;
/**
 * this(...):
 *    默认是去找本类中的其他构造方法，根据参数来确定具体调用哪一个构造方法。
 *    为了借用其他构造方法的功能。
 */
public class ThisDemo01 {
    public static void main(String[] args) {
        Student xuGan = new Student();
        System.out.println(xuGan.getName()); // 输出:徐干
        System.out.println(xuGan.getAge());// 输出:21
        System.out.println(xuGan.getSex());// 输出： 男
    }
}

class Student{
    private String name ;
    private int age ;
    private char sex ;

    public Student() {
  // 很弱，我的兄弟很牛逼啊，我可以调用其他构造方法：Student(String name, int age, char sex)
        this("徐干",21,'男');
    }

    public Student(String name, int age, char sex) {
        this.name = name ;
        this.age = age   ;
        this.sex = sex   ;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }
}

```

说明：

​ this 内存图，已在 this 关键字详细讲解

## 知识加油篇

### 1.Java 内存模型

在 Java 中，执行一个`HelloWorld`方法的内存图

![](<assets/1740015224164.png>)

说明：

​ **栈内存**为**方法**提供使用、**堆内存**为**对象**提供使用、**方法区**为**执行的 class** 文件临时存储

补充：

*   参考资料：https://www.bilibili.com/video/BV17F411T7Ao/?p=107
*   当执行 main 方法时，会生成 StringDemo 这个 class 文件

### 2.Idea 快捷键

#### 2.1 查看接口实现类

说明：

Ctrl+Alt+B

选中一个方法，按键 Ctrl+Alt+B 即可查看实现此接口的实现类

![](<assets/1740015224448.png>)

#### 2.2 图标小细节

Ctrl+F12 可以查看当前类中的状态，例如成员方法，成员属性等等

![](<assets/1740015224717.png>)

![](<assets/1740015224977.png>)

C 表示类，M 表示方法，**F 表示常量或静态成员变量**，➡️表示继承，⬆表示重写

### 3.int 和 Integer 区别

​ 在 Java 中，`int`是一种原始数据类型（primitive data type），用于表示整数值。它是 Java 中最常用的数据类型之一，它的大小为 4 个字节（32 位），可以表示介于 - 2,147,483,648 和 2,147,483,647 之间的整数。

​ 而`Integer`是 Java 中的一个类（Class），它封装了一个基本类型的 int 的值。它允许将 int 值作为参数传递给需要一个对象的方法，也可以将 int 值转换为其他类型的值，例如字符串。

​ 因此，`int`和`Integer`的主要区别在于`int`是一个原始数据类型，而`Integer`是一个类，用于封装 int 值以便进行更多的操作。此外，`int`在 Java 中是一种基本数据类型，而`Integer`是一种引用数据类型，也就是说`Integer`实际上是一个指向对象的指针，而不是一个简单的数据值。

### 4.String 和 Character 区别

​ `String`是一种对象，用于表示一个**字符序列**（即**一组字符**）。它是 Java 中的一个类，具有许多实用方法来操作和处理字符串，例如连接、替换、搜索和分割等。字符串常量可以使用双引号括起来，例如`"hello"`。

`Character`是 Java 中的 char 类型的包装类，它用于表示**单个字符**。每个`Character`对象都包含一个 char 类型的值。它也具有一些实用方法来操作和处理字符，例如将字符转换为大写或小写。字符常量可以使用单引号括起来，例如`'A'`。

​ 因此，`String`和`Character`的主要区别在于它们表示的数据类型不同。`String`用于表示一组字符，而`Character`用于表示单个字符。此外，`String`是一个类，而`Character`是一个简单的数据类型。在 Java 中，字符串是不可变的，因此不能在原始字符串上进行修改，而`Character`是可变的，因为它只表示一个字符。

### 5. 基本数据类型和引用数据类型的区别

参考链接：[(29 条消息) 基本数据类型和引用数据类型的区别_Brandon 懂你的博客 - CSDN 博客](https://blog.csdn.net/qq_37577735/article/details/88958406)