---
url: https://blog.csdn.net/qq_40991313/article/details/130232389
title: 【Java 面试题汇总】JVM 篇（2025 版）_jvm 面试题 - CSDN 博客
date: 2025-02-20 13:45:50
tag: 
summary: 
---
**导航：**

[【Java 笔记 + 踩坑汇总】Java 基础 + JavaWeb+SSM+SpringBoot+SpringCloud + 瑞吉外卖 / 谷粒商城 / 学成在线 + 设计模式 + 面试题汇总 + 性能调优 / 架构设计 + 源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126646289%22%2C%22source%22%3A%22qq_40991313%22%7D "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[1、说说你了解的 JVM 内存模型](#t0)

[2、简单说下你对 JVM 的了解](#t1)

[3、说说类加载机制](#t2)

[4、说说对象的实例化过程](#t3)

[5、说说 JVM 的双亲委派模型](#t4)

[6、说说 JVM 调优思路](#t5)

[7、项目中有没有实际的 JVM 调优经验？](#t6)

[7.1 CPU 飙升](#t7) 

[7.2 GC 调优](#t8)

[8、请你说说内存溢出](#t9)

[9、请你说说内存泄漏](#t10)

[10、JVM 中一次完整的 GC 流程是怎样的](#t11)

[11、如何避免 Full GC?](#t12)

[12、说说 JVM 的垃圾回收机制](#t13)

[13、说说 GC 的可达性分析算法](#t14)

[14、说说 JVM 的垃圾回收算法](#t15)

[15、说说七个垃圾回收器](#t16)

[16、请你讲下 CMS（并发标记清除）回收器](#t17)

[17、请你讲下 G1 垃圾优先回收器](#t18)

### 1、说说你了解的 JVM 内存模型

**得分点** 

类加载子系统、运行时数据区、执行引擎

**JVM 由三部分组成：**类加载子系统、运行时数据区、执行引擎

**类加载子系统：**通过类加载机制加载类的 class 文件，如果该类是第一次加载，会执行加载、验证、解析。只负责 class 文件的加载，至于是否可运行，则由执行引擎决定。

类加载过程是在类加载子系统完成的：加载 --> 链接（验证 --> 准备 --> 解析） --> 初始化

**运行时数据区：**

在程序运行时，存储程序的内容（例如字节码、对象、参数、返回值等）。运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。

只有方法区和堆是各线程共享的进程内存区域，其他运行区都是每个线程可以独立拥有的。

*   **本地方法栈：**存放本地方法调用过程中的栈帧。用于管理本地方法的调用，本地方法是 C 语言写的。不是所有虚拟机都支持本地方法栈，例如 Hotspot 虚拟机就是将本地方法栈和虚拟机栈合二为一。栈解决程序的运行问题，即程序如何执行、如何处理数据。
    *   **栈帧：**栈帧是栈的元素，由三部分组成，即局部变量表（存方法参数和**局部变量**）、操作数栈（存方法执行过程中的中间结果，或者其他暂存数据）和帧数据区（存方法返回地址、线程引用等附加信息）。
*   **虚拟机栈：**存放 Java 方法调用过程中的栈帧。用于管理 Java 方法的调用，Java 方法是开发时写的 Java 方法。
*   **方法区：**可以看作是一块独立于 Java 堆的内存空间，方法区是各线程共享的内存区域。
    *   **方法区和永久代、元空间的关系：**方法区是一个抽象概念，永久代和元空间是方法区的实现方式。
        *   **永久代：**属于 JVM 方法区的内存，用来存储**类的元数据**，如类名、方法信息、字段信息等一些静态的数据。JDK7 及之前方法区也叫永久代。缺点是内存大小固定，容易出现 oom 问题。可以通过 - XX:PermSize 设置永久代大小。永久代对象只能通过 Major GC（又称 Full GC）进行垃圾回收。
        *   **元空间：**是 Hotspot 在 JDK8 引入的，用于取代永久代。元空间属于本地内存，由操作系统直接管理，不再受 JVM 管理。同时内存空间可以自动扩容，避免内存溢出。默认情况下元空间可以无限使用本地内存，也可以通过 - XX:MetaspaceSize 限制内存大小。
    *   **常量池：**就是一张表，JVM 根据这张常量表找到要执行的类信息和方法信息
        *   **类常量池：**是. class 字节码文件中的资源仓库，主要存放字面量（表示字符串值和数值，例如字符串值 "abc"、**final 常量、静态变量**）和符号引用（类和接口的全限定名、字段名、方法名）。
        *   **运行时常量池：**类加载的 “加载” 阶段会创建运行时常量池，统一存放各个类常量池去重后的符号引用。在类加载的 “解析” 阶段 JVM 会把运行时常量池的这些符号引用转为直接引用。类常量池。类常量池在字节码文件中的，运行时常量池在内存中。
        *   **字符串常量池：**专门针对 String 类型设计的常量池。是当前应用程序里所有线程共享的，每个 jvm 只有一个字符串常量池。存储字符串对象的引用。在创建 String 对象时，JVM 会先在字符串常量池寻找是否已存在相同字符串的引用，如果有的话就直接返回引用，没的话就在堆中创建一个对象，然后常量池保存这个引用并返回引用。
*   **堆：**存放对象实例、**实例变量**、数组，包括新生代（伊甸园区、幸存区 S0 和 S1）和老年代。堆是垃圾收集器管理的内存区域。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。堆实际内存空间可以不连续，大小可以选择固定大小或可扩展，堆是各线程共享的内存区域。
*   **程序计数器（PC 寄存器）：**存放下一条字节码指令的地址，由执行引擎读取下一条字节码指令并转为本地机器指令进行执行。是程序控制流（分支、循环、跳转、线程恢复）的指示器，只有它不会抛出 OutOfMemoryError。每个线程有自己独立的程序计数器，以便于线程在切换回来时能知道下一条指令是什么。程序计数器生命周期与线程一致。

**执行引擎：**将字节码指令解释 / 编译为对应平台上的本地机器指令。充当了将高级语言翻译为机器语言的译者。执行引擎在执行过程中需要执行什么样的字节码指令依赖于 PC 寄存器。每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。

*   **字节码指令（JVM 指令）：**字节码文件中的指令，内部只包含一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息，不能够直接运行在操作系统之上。
*   **本地机器指令：**可以直接运行在操作系统之上。

**详细参考：**

[什么是 JVM 的内存模型？详细阐述 Java 中局部变量、常量、类名等信息](https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501 "什么是JVM的内存模型？详细阐述Java中局部变量、常量、类名等信息")

**内存模型：**

![](<assets/1740030350922.png>)

**内存模型里的运行时数据区：**

![](<assets/1740030351128.png>)

**JVM 由三部分组成：**类加载子系统、执行引擎、运行时数据区。

**1. 类加载子系统**, 可以根据**指定的全限定名**来载入类或接口。

**2. 运行时数据区**。当程序运行时, JVM 需要内存来存储许多内容, 例如：字节码、对象、参数、返回值、局部变量、运算的中间结果, 等等, JVM 会把这些东西都存储到运行时数据区中, 以便于管理。而运行时数据区又可以分为**方法区、堆、虚拟机栈、本地方法栈、程序计数器**。

**3. 执行引擎**, 负责执行那些包含在被载入类的方法中的指令。

**加分回答 - 运行时数据区**

运行时数据区是开发者重点要关注的部分, 因为**程序的运行与它密不可分**, 很多错误的排查也需要基于对运行时数据区的理解。在运行时数据区所包含的几块内存空间中, **方法区和堆是线程之间共享的内存区域**, 而虚拟机栈、本地方法栈、程序计数器则是线程私有的区域, 就是说每个线程都有自己的这个区域。 

### 2、简单说下你对 JVM 的了解

**得分点**

Java 跨平台、HotSpot、热点代码探测技术、内存模型、垃圾回收算法、垃圾回收器

**跨平台** 

Java 跨平台，JVM 不跨平台。 

JVM 是 Java 语言**跨平台**的关键，Java 在虚拟机层面隐藏了底层技术的复杂性以及机器与操作系统的差异性。运行程序的物理机千差万别，而 JVM 则在千差万别的物理机上面建立了统一的运行平台，实现了在任意一台 JVM 上编译的程序，都能在任何其他 JVM 上正常运行。这一极大的优势使得 Java 应用的开发比传统 C/C++ 应用的开发更高效快捷，程序员可以把主要精力放在具体业务逻辑，而不是放在保障物理硬件的兼容性上。通常情况下，一个程序员只要了解了必要的 Java 类库、Java 语法，学习适当的第三方开发框架，就已经基本满足日常开发的需要了，JVM 会在用户不知不觉中完成对硬件平台的兼容及对内存等资源的管理工作。

**默认 Java 虚拟机 HotSpot** 

**HotSpot** 是 Sun/OracleJDK 和 OpenJDK 中的默认 Java 虚拟机，也是目前使用范围最广的 Java 虚拟机。HotSpot 既继承了 Sun 之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的 HotSpot 指的就是它的**热点代码探测技术**。HotSpot 的热点代码探测能力可以**通过执行计数器找出最具有编译价值的代码**，然后通知即时编译器以方法为单位进行编译。如果一个**方法被频繁调用，或**方法中有效循环次数很多，将会分别触发标准即时编译和栈上替换编译行为。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更复杂的代码优化技术，输出质量更高的本地代码。本地方法栈和 Java 方法栈是合并的。

**内存模型** 

**JVM 由三部分组成：**类加载子系统、运行时数据区、执行引擎。

**类加载子系统：**根据指定的全限定名来载入类或接口。

**运行时数据区：**在程序运行时，存储程序的内容，例如：字节码、对象、参数、返回值等。而运行时数据区又可以分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。

**执行引擎：**负责执行那些包含在被载入类的方法中的指令。

### 3、说说类加载机制

**得分点**  
加载、验证、准备、解析、初始化

**标准回答** 

**类加载过程：**加载、链接（验证、准备、解析）、初始化。这个过程是在类加载子系统完成的。

**加载：**生成类的 Class 对象。

1.  通过类的全限定名获取该类的二进制字节流
    1.  **类的全限定名：**即 "包名. 类名"，例如 Object 类的全限定名是 java.lang.Object 。包名的各个部分之间，包名和类名之间， 使用点号分割。 
    2.  **类的二进制字节流：**即类的字节码文件，是一组以 8 个字节 (64 位) 为基础单位的二进制流，各个单位内部及之间都排列紧凑，中间没有添加任何分隔符和空隙，这使得整个 Class 文件中存储的内容几乎都是程序运行的必要数据。当遇到需要占用 8 个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个 8 个字节进行存储，保证每个基础单位只有 8 个字节。
2.  将这个字节流的静态存储结构，转化为方法区的运行时数据结构。包括创建运行时常量池，将类常量池的部分符号引用放入运行时常量池。
    1.  **静态存储结构：**二进制文件，存储内容，存储内容包括魔数、版本号、常量池、访问标识、类索引、字段表、方发表、属性表
    2.  **运行时数据结构：**存储在内存中的 JVM 内存模型中的运行时数据区 - 方法区，存储内容是类常量池、运行时常量池、字符串常量池，存储形式是永久代（JDK7 及之前）和元空间（JDK8 及之后）。
3.  在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类各种数据的访问入口。注意类的 class 对象是运行时生成的、存在内存中的对象，类的 class 字节码文件是编译时生成的、存在磁盘中的文件。

**链接：**将类的二进制数据合并到 JRE 中。该过程分为以下 3 个阶段：

*   **验证：**确保代码符合 JAVA 虚拟机规范和安全约束。包括文件格式验证、元数据验证、字节码验证、符号引用验证。
    *   **文件格式验证：**验证字节码文件是否符合规范。
        *   **魔数：**是否魔数 0xCAFEBABE 开头
        *   **版本号：**版本号是否在 JVM 兼容范围
        *   **常量类型：**类常量池里常量类型是否合法
        *   **索引值：**索引值是否指向不存在或不符合类型的常量。
    *   **元数据验证：**元数据是字节码里类的全名、方法信息、字段信息、继承关系等。
        *   **标识符：**验证类名接口名标识符有没有符合规范
        *   **接口实现方法：**有没有实现接口的所有方法
        *   **抽象类实现方法：**有没有实现抽象类的所有抽象方法
        *   **final 类：**是不是继承了 final 类。
    *   **指令验证：**主要校验类的方法体，通过数据流和控制流分析，保证方法在运行时不会危害虚拟机安全。
        *   **类型转换：**保证方法体中的类型转换是否有效。例如把某个类强转成没继承关系的类
        *   **跳转指令：**保证跳转指令不会跳转到方法体以外的字节码指令上；
        *   保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
    *   **符号引用验证：**确保后面解析阶段能正常执行。
        *   **类全限定名地址：**验证类全限定名是否能找到对应的类字节码文件
        *   **引用地址：**引用指向地址是否存在实例
        *   **引用权限：**是否有权引用
*   **准备：**为类变量（即 static 变量）分配内存并赋零值。
*   **解析：**将方法区 - 运行时常量池内的符号引用（类的名字、成员名、标识符）转为直接引用（实际内存地址，不包含任何抽象信息，因此可以直接使用）。

**初始化：**类变量赋初值、执行静态语句块。

![](<assets/1740030351387.png>)

**详细参考：**

[JDK 编译生成的. class 字节码文件是什么？从底层结构到代码验证，深度解析 Java 字节码文件 - CSDN 博客](https://blog.csdn.net/qq_40991313/article/details/135538568 "JDK编译生成的.class字节码文件是什么？从底层结构到代码验证，深度解析Java字节码文件-CSDN博客")

[Java 的类是怎样在虚拟机中加载的？详细阐述 JVM 的加载、验证和解析过程](https://blog.csdn.net/qq_40991313/article/details/135250030 "Java的类是怎样在虚拟机中加载的？详细阐述JVM的加载、验证和解析过程")

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载、验证、准备、解析、初始化、使用、卸载**七个阶段，其中验证、准备、解析三个部分统称为连接，而前五个阶段则是类加载的完整过程。

![](<assets/1740030351575.png>)

​

1. 在加载阶段 JVM 需要在内存中生成一个代表这个类的 **Class 对象**，作为方法区这个类的各种数据的**访问入口**。  
2. 验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。  
3. 准备阶段是正式为类中定义变量（静态变量）分配到内存并设置类变量初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域。  
4. 解析阶段是 Java 虚拟机将常量池内的符号替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，直接引用是可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。  
5. 类的初始化阶段是类加载过程的最后一个步骤，直到初始化阶段，Java 虚拟机才**真正开始执行**类中编写的 **Java 程序代码**，将主导权移交给应用程序。本质上，初始化阶段就是**执行类构造器的过程**。并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物。  
**加分回答**  
关于在什么情况下需要开始类加载过程的第一个阶段 “加载”，《Java 虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java 虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行 “初始化”：  
1. 使用 new 实例化对象、读写类的静态字段、调用类的静态方法时。  
2. 使用 java.lang.reflect 包的方法对类型进行反射调用时。  
3. 当初始化类时，若发现其父类还没有进行过初始化，则先初始化这个父类。  
4. 虚拟机启动时，需要指定一个要执行的主类，虚拟机会先初始化这个主类。  
5. 当使用 JDK 7 新加入的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。  
6. 当一个接口中定义了 JDK 8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

### 4、说说对象的实例化过程

**得分点**

类加载、分配内存（内存规整和不规整）、处理并发安全问题、设置对象头、成员变量赋初值、执行构造方法

**对象的实例化过程：**

1.  **判断对应类是否加载过：**首先 JVM 检查在方法区 Metaspace（元空间）的常量池里能否定位到该类的符号引用，能的话通过符号引用检查该类是否加载链接初始化过；若没有则在双亲委派机制下，当前类加载器调用 findClass() 方法查找类的. class 字节码文件，然后调用 loadClass("类全限定名") 方法遵循双亲委派机制加载链接初始化类到内存中，并生成类的 class 对象，作为方法区这个类各种数据的访问入口。
2.  **创建对象：**
    1.  **分配堆内存空间：****如果内存规整：**（例如标记整理算法），采用指针碰撞法为新对象分配内存。**如果内存不规整：**（有内存碎片，例如标记清除算法），在空闲列表里找到合适大小的空闲内存分配给新对象。现在主流虚拟机新生代都是使用标记复制算法，内存都是规整的。
    2.  **处理并发安全问题：**CAS 失败重试，区域加锁，每个线程分配一块 TLAB 内存缓冲区。
    3.  **设置对象头：**将哈希码、GC 分代年龄、锁信息、GC 标记等存在对象头的 Mark Word 中；
    4.  **成员变量赋初值：**若指定了初值则赋指定的值。若未指定初值，则基本类型赋 0 或 false、引用类型赋 null。
3.  **执行构造方法：**有父类的话，子类构造方法第一行会隐式或手动显式地加 super()。

**指针碰撞法：** 指针一直在空闲和已用内存中间，分配空间时，指针往空闲内存方向移动一段距离，使这段距离刚好满足新对象内存大小。

**元空间：**是 Hotspot 在 JDK8 引入的，用于取代永久代。元空间属于本地内存，由操作系统直接管理，不再受 JVM 管理。同时也可以自动扩容内存空间，避免内存溢出。默认情况下元空间可以无限使用本地内存，也可以通过 - XX:MetaspaceSize 限制内存大小。

**指针碰撞法：** 所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。

如果垃圾收集器选择的是 Serial、ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。 一般使用带有 compact(整理) 过程的收集器时，使用指针碰撞。

**回顾 synchronized 用到的对象头：**

前面多线程篇有提到，synchronized 锁基于对象头的 Mark Word，锁升级四个状态里，偏向锁和轻量级锁基于 CAS 原子替换，重量级锁基于 Monitor 对象。对象头里 Mark Word 存哈希码、GC 标记、锁信息。对象头里类型指针指向当前对象所在的类。

锁信息：

*   锁标志位：01 未锁定、01 可偏向、00 轻量级锁、10 重量级锁、11 垃圾回收标记
    
*   偏向锁线程 ID、时间戳等
    
*   轻量级锁的指针：指向锁记录的指针
    
*   重量级锁的指针：指向 Monitor 锁的指针
    

[【Java 面试八股文】Java 多线程篇_java 多线程八股文_vincewm 的博客 - CSDN 博客](https://blog.csdn.net/qq_40991313/article/details/129446871 "【Java面试八股文】Java多线程篇_java多线程八股文_vincewm的博客-CSDN博客")

在 JVM 中，对象的创建遵循如下过程：

当 JVM 遇到一条字节码 **new 指令**时，首先将去检查这个指令的参数是否能在**常量池**中定位到一个**类的符号引用**，并且检查这个符号引用代表的类**是否已被加载、解析和初始化过**。如果**没有**，那必须先执行相应的**类加载过程**。

在类加载检查通过后，接下来虚拟机将为**新生对象分配内存**。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来。

内存分配完成之后，虚拟机必须将分配到的**内存空间都初始化为零值**，如果使用了 TLAB 的话，这一项工作也可以提前至 TLAB 分配时顺便进行。这步操作保证了对象的实例**字段**在 Java 代码中可以**不赋初始值就直接使用**，使程序能访问到这些字段的数据类型所对应的零值。

接下来，虚拟机还要对对象进行必要的**设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息**存放在对象的对象头**之中。根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。但是从 Java 程序的视角看来，对象创建才刚刚开始——**构造函数**，即 Class 文件中的 `<init>()` 方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。

一般来说，new 指令之后会接着执行 `<init>()` 方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

### 5、说说 JVM 的双亲委派模型

**得分点**

三个默认类加载器、工作过程、作用

**双亲委派模型：**当一个类加载器接收到加载类的请求时，它首先会将这个请求委派给其父类加载器处理，只有在父类加载器无法完成加载任务时，才会由该类加载器自己去加载类。 

**JVM 三个默认类加载器：**

*   **启动类加载器 BootStrapClassLoader**（最顶端）：
    *   **加载内容：**负责加载 java 的核心类库，包括 java.lang 包中的类等。底层使用 C++ 实现（不会继承 ClassLoader），是虚拟机自身的一部分。
    *   **不能被直接引用：**因为是 C++ 实现的，所以无法被 Java 程序直接引用，只能加载委派过来的请求。这些类库存放在 JAVA_HOME\lib（具体解释看下文） 目录下，或者被 -Xbootclasspath 参数指定的路径中。（启动类加载器主要加载 java 的核心类库，即加载 lib 目录下的所有 class）
*   **扩展类加载器 ExtClassLoader：**
    *   **加载内容：**负责加载 JAVA_HOME\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有类库。
    *   **可以被直接引用：**它可以直接用来加载类，也可以通过委派加载类。Ext 是 Extract 缩写，译为扩展、提取。
*   **应用程序类加载器 AppClassLoader**（最低端）：
    *   **加载内容：**负责加载类路径的所有类库，在大多数情况下，我们编写的 Java 程序都是由这个类加载器加载的。
    *   **可以被直接引用：**可以直接在代码中使用这个类加载器。

![](<assets/1740030351766.png>)

**双亲委派模型的工作过程：**

**工作过程：**

1.  **检查父类加载器是否已经加载过这个类**：JVM 会首先询问父类加载器是否已经加载了该类。如果已经加载过了，直接返回该类的 Class 对象。**如果没加载过，则：**
    
2.  **委派给父类加载器加载**：如果父类加载器没有加载过该类，那么 JVM 将委托给父类加载器进行加载。每一层都是这样继续委派，直到达到最顶层的启动类加载器。
    
3.  **尝试加载类**：如果父类加载器无法加载该类（即所有的父类加载器都无法加载），那么 JVM 将尝试使用自己的类加载器来加载类。
    

**实际流程：**

JVM 在加载一个类时，会调用应用程序类加载器的 loadClass() 方法来加载这个类，不过在这方法中，会先使用扩展类加载器的 loadClass() 方法来加载类，同样扩展类加载器的 loadClass() 方法中会先使用启动类加载器来加载类；

如果启动类加载器加载到了就直接成功，如果启动类加载器没有加载到，那扩展类加载器就会自己尝试加载该类，如果没有加载到，那么则会由应用程序类加载器来加载这个类。 

**双亲委派模型的作用：**

*   **避免类的重复加载：**无论哪一个类加载器要加载某类，最终都是委派最顶端的启动类加载器。
*   **防止核心 API 被篡改：**如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。

**JAVA_HOME\lib：**

是 JDK（Java Development Kit）安装目录下的一个子目录，其中包含了 Java 核心类库，包括一些 Java 的基础类和工具类等。这些类库是 Java 编程语言的基础，为 Java 程序的运行提供了必要的支持。

一些常见的在 JAVA_HOME\lib 目录下的重要文件包括：

*   **rt.jar：**Java 运行时的核心库，包含了 Java 核心类库的大部分内容，如 java.lang、java.util 等。
*   **charsets.jar：**包含了字符集支持的类库。
*   **jfxrt.jar：**JavaFX 运行时的核心库。
*   **tools.jar：**包含了一些 Java 开发工具的类库，如编译器、调试器等。
*   **dt.jar：**包含了 Java 开发工具包的类库，如图形界面工具等。

在编译和运行 Java 程序时，这些类库会被 JVM 的 Bootstrap ClassLoader 加载，以便程序能够使用 Java 核心类库提供的功能。

![](<assets/1740030352013.png>) 

**JAVA_HOME\lib\ext：**

是 JDK（Java Development Kit）安装目录下的一个子目录，用于存放 Java 的扩展类库。这些类库提供了一些 Java 平台的扩展功能，如 XML 解析、网络协议、加密解密等。

在 JAVA_HOME\lib\ext 目录下，通常会包含一些 JAR 文件，这些文件是扩展类库的实现。一些常见的扩展类库包括：

*   **dnsns.jar：**DNS 名称服务提供者实现。
*   **jaccess.jar：**Java 访问桥实现。
*   **ldapsec.jar：**LDAP 安全实现。
*   **sunjce_provider.jar：**Sun 的 JCE（Java Cryptography Extension）提供者实现。
*   **sunpkcs11.jar：**Sun 的 PKCS#11 提供者实现。

这些扩展类库提供了一些 Java 平台的高级功能，但并不是所有的 Java 运行时环境都会使用到。通常情况下，如果你需要使用这些扩展功能，你可以将相应的 JAR 文件添加到类路径中，以便 Java 程序能够访问到这些功能。

**类路径：**

**classpath：**类路径 classpath 是编译之后的 target 文件夹下的 WEB-INF/class 文件夹。内容等同于打包前的 src.main.java 和 src.main.resource 下的目录和文件

**classpath* ：**不仅包含 class 路径，还包括 jar 文件中 (class 路径) 进行查找. 

对于 JDK8 及其之前版本的 Java 应用，都会使用到以下 3 个系统提供的类加载器来进行加载：

**1. 启动类加载器**

这个类加载器负责加载存放在 `<java_home>\lib` 目录，或者被 - Xbootclasspath 参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的类库加载到虚拟机的内存中。注意，Java 虚拟机会按照文件名识别类库，例如 rt.jar、tools.jar，对于名字不符合的类库即使放在 lib 目录中也不会被加载。启动类加载器**无法被 Java 程序直接引用**，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器去处理，那直接使用 null 代替即可，即让 java.lang.ClassLoader.getClassLoader() 返回 null。

**2. 扩展类加载器**

这个类加载器是在类 sun.misc.Launcher$ExtClassLoader 中以 Java 代码的形式实现的。它负责加载 `<java_home>\lib\ext` 目录中，或者被 java.ext.dirs 系统变量所指定的路径中所有的类库。由于扩展类加载器是**由 Java 代码实现的**，开发者**可以直接在程序中使用扩展类加载器来加载 Class 文件**。

**3. 应用程序类加载器**

这个类加载器由 sun.misc.Launcher$AppClassLoader 来实现。它负责**加载用户类路径**（ClassPath）**上所有的类库**，开发者同样可以直接在代码中使用这个类加载器。

用户还可以加入自定义的类加载器来进行拓展，这些类加载器之间的协作关系 “通常” 如下图所示。图中展示的各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用组合关系来复用父加载器的代码。

![](<assets/1740030352319.png>)

**工作过程**

双亲委派模型的工作过程是，如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去完成加载。

**作用：避免类的重复加载、防止核心 API 被篡改**

使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，**无论哪一个类加载器要加载这个类，最终都是委派**给处于模型最顶端的**启动类加载器**进行加载，因此 Object 类在程序的各种类加载器环境中都能够**保证是同一个类**。

反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。

**加分回答 - 双亲委派模型的 3 次被破坏**

双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者们的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，双亲委派模型主要出现过 3 次较大规模的 “被破坏” 的情况。

1. 双亲委派模型的**第一次** “被破坏” 发生在双亲委派模型**出现之前**

双亲委派模型在 JDK1.2 之后才被引入，但是类加载器的概念和抽象类 ClassLoader 则在 Java 的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java 设计者们引入双亲委派模型时不得不做出一些妥协。为了兼容这些已有代码，只能在之后的 ClassLoader 中添加一个 protected 方法 findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在 loadClass() 中编写代码。双亲委派的具体逻辑就实现在这里面，按照 loadClass() 的逻辑，如果父类加载失败，会自动调用自己的 findClass() 来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器符合双亲委派规则。

2. 双亲委派模型的**第二次** “被破坏” 是由这个模型**自身的缺陷**导致的

双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题，基础类型之所以被称为 “基础”，是因为它们总是作为被用户代码继承、调用的 API 存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？

一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器来完成加载，肯定属于 Java 中很基础的类型了。但 JNDI 存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的 ClassPath 下的 JNDI 服务提供者接口的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？

为了解决这个困境，Java 的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 Thread 类的 setContextClassLoader() 方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

有了线程上下文类加载器，程序就可以做一些 “舞弊” 的事情了。JNDI 服务使用这个线程上下文类加载器去加载所需的 SPI 服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。

3. 双亲委派模型的**第三次** “被破坏” 是由于**用户对程序动态性的追求**而导致的

这里所说的 “动态性” 指的是一些非常 “热” 门的名词：代码热替换、模块热部署等。说白了就是希望 Java 应用程序能像我们的电脑外设那样，接上鼠标、U 盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。

早在 2008 年，在 Java 社区关于模块化规范的第一场战役里，由 Sun/Oracle 公司所提出的 JSR-294、JSR-277 规范提案就曾败给以 IBM 公司主导的 JSR-291（即 OSGi R4.2）提案。尽管 Sun/Oracle 并不甘心就此失去 Java 模块化的主导权，随即又再拿出 Jigsaw 项目迎战，但此时 OSGi 已经站稳脚跟，成为业界 “事实上” 的 Java 模块化标准。

OSGi 实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。</java_home></java_home>

### 6、说说 JVM 调优思路

JVM 调优三步骤、性能监控、性能分析、性能调优

**JVM 调优三步骤：**

1.  监控发现问题
2.  工具分析问题
3.  性能调优 

**监控发现问题：**看服务器有没有以下情况，有的话需要调优：

*   GC 频繁
*   CPU 负载过高
*   OOM
*   内存泄露
*   死锁
*   程序响应时间较长

**工具分析问题：**使用分析工具定位 oom、内存泄漏等问题

*   **调优依据：**吞吐量提高的代价是停顿时间拉长。如果应用程序跟用户基本不交互，就优先提升吞吐量。如果应用程序和用户频繁交互，就优先缩短停顿时间。
*   GC 日志：使用 GCViewer、VisualVM、GCeasy 等日志分析工具打印 GC 日志；
*   **JDK 自带的命令行调优工具：**
    *   **jps：**查看正在运行的 Java 进程。jps -v 查看进程启动时的 JVM 参数；
    *   **jstat：**查看指定进程的 JVM 统计信息。jstat -gc 查看堆各分区大小、YGC,FGC 次数和时长。如果服务器没有 GUI 图形界面，只提供了纯文本控制台环境，它是运行期定位虚拟机性能问题的首选工具。
    *   **jinfo：**实时查看和修改指定进程的 JVM 配置参数。jinfo -flag 查看和修改具体参数。
    *   **jstack：**打印指定进程此刻的线程快照。定位线程长时间停顿的原因，例如死锁、等待资源、阻塞。如果有死锁会打印线程的互相占用资源情况。
        *   **线程快照：**该进程内每条线程正在执行的方法堆栈的集合。
*   JDK 自带的可视化监控工具：例如 jconsole、Visual VM。Visual VM 可以监视应用程序的 CPU、GC、堆、方法区、线程快照，查看 JVM 进程、JVM 参数、系统属性。
*   **MAT：**解析 Heap Dump（堆转储）文件 dump.hprof，查看 GC Roots、引用链、对象信息、类信息、线程信息。可以快速生成内存泄漏报表。
*   MAT 下载地址（JDK8 对应 1.10.0 版本）：[Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation](https://eclipse.dev/mat/previousReleases.php "Eclipse Memory Analyzer Open Source Project | The Eclipse Foundation")
    *   **生成 dump 文件方式：**
        *   jmap：
            
            ```
            // 开启在出现 OOM 错误时生成堆转储文件
            -Xmx1024m
            -XX:+HeapDumpOnOutOfMemoryError
            // 将生成的堆转储文件保存到 /tmp 目录下，并以进程 ID 和时间戳作为文件名
            -XX:HeapDumpPath=/tmp/java_%p_%t.hprof
             
            // 在进行 Full GC 前生成堆转储文件
            // 注：如果没有开启自动 GC，则此参数无效。JDK 9 之后该参数已被删除。
            -XX:+HeapDumpBeforeFullGC
            ```
            
        *   JVM 参数：OOM 后生成、FGC 前生成
        *   Visual VM
        *   MAT 直接从 Java 进程导出 dump 文件

```
//调整内存大小
-XX:MetaspaceSize=128m（元空间默认大小）
-XX:MaxMetaspaceSize=128m（元空间最大大小）
-Xms1024m（堆最大大小）
-Xmx1024m（堆默认大小）
-Xmn256m（新生代大小）
-Xss256k（栈最大深度大小）
 
//调整内存比例
 //伊甸园:幸存区
-XX:SurvivorRatio=8（伊甸园:幸存区=8:2）
 //新生代和老年代的占比
 -XX:NewRatio=4  //表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2
 
//修改垃圾回收器
//设置Serial垃圾收集器（新生代）
//-XX:+UseSerialGC
 //设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器
//-XX:+UseParallelOldGC
 //CMS垃圾收集器（老年代）
//-XX:+UseConcMarkSweepGC
 //设置G1垃圾收集器
-XX:+UseG1GC
 
//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间
 -XX:MaxGCPauseMillis
 
 //进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，JDK8默认值15，JDK9默认值7
 -XX:InitialTenuringThreshold=7
 //新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。
  -XX:PretenureSizeThreshold=1000000
 
 //使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小
 -XX:CMSInitiatingOccupancyFraction 
 //G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%
 -XX:G1MixedGCLiveThresholdPercent=65
 
 //Heap Dump（堆转储）文件
 //当发生OutOfMemoryError错误时，自动生成堆转储文件。
-XX:+HeapDumpOnOutOfMemoryError 
 //错误输出地址
-XX:HeapDumpPath=/Users/a123/IdeaProjects/java-test/logs/dump.hprof
 
 //GC日志
-XX:+PrintGCDetails（打印详细GC日志）
-XX:+PrintGCTimeStamps：打印GC时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps：打印GC时间戳（以日期格式）
-Xlog:gc:（打印gc日志地址）
```

**性能调优：**

*   排查大对象和内存泄漏：使用 MAT 分析堆转储日志中的大对象，看是否合理。大对象会直接进入老年代，导致 Full GC 频繁。具体排查步骤看下面 OOM。
*   **调整 JVM 参数：**主要关注停顿时间和吞吐量，两者不可兼得，提高吞吐量会拉长停顿时间。
    *   **减少停顿时间：**垃圾收集器做垃圾回收中断应用执行的时间。 可以通过 - XX:MaxGCPauseMillis 参数进行设置，以毫秒为单位，至少大于 1
    *   **提高吞吐量：**吞吐量 = 运行时长 /(运行时长 + GC 时长)。通过 - XX:GCTimeRatio=n 参数进行设置，99 的话代表吞吐量为 99%， 一般吞吐量不能低于 95%。吞吐量太高会拉长停顿时间，造成用户体验下降。
    *   **调整堆内存大小：**根据程序运行时老年代存活对象大小（记为 x）进行调整，整个堆内存大小设置为 X 的 3~4 倍。年轻代占堆内存的 3/8。
        *   **-Xms：**初始堆内存大小。**默认：**物理内存小于 192MB 时，默认为物理内存的 1/2；物理内存大 192MB 且小于 128GB 时，默认为物理内存的 1/4；物理内存大于等于 128GB 时，都为 32GB。
        *   **-Xmx：**最大堆内存大小，建议保持和初始堆内存大小一样。因为从初始堆到最大堆的过程会有一定的性能开销，而且现在内存不是稀缺资源。
        *   **-Xmn：**年轻代大小。JDK 官方建议年轻代占整个堆大小空间的 3/8 左右。
    *   **调整堆内存比例：**调整伊甸园区和幸存区比例、新生代和老年代比例。Young GC 频繁时，我们提高新生代比例和伊甸园区比例。默认情况，伊甸园区: S0:S1=8:1:1，新生代: 老年代 = 1:2。
    *   **调整升老年代年龄：**JDK8 时 Young GC 默认把 15 岁的对象移动到老年代。JDK9 默认值改为 7。当 Full GC 频繁时，我们提高升老年龄，让年轻代的对象多在年轻代待一会，从而降低 Full GC 频率。JDK8 默认 Young GC 时将 15 岁的对象移动到老年代。
    *   **调整大对象阈值：**Young GC 时大对象会不顾年龄直接移动到老年代。当 Full GC 频繁时，我们关闭或提高大对象阈值，让老年代更迟填满。默认是 0，即大对象不会直接在 YGC 时移到老年代。
    *   **调整 GC 的触发条件：**
        *   **CMS 调整老年代触发回收比例：**CMS 的并发标记和并发清除阶段是用户线程和回收线程并发执行，如果老年代满了再回收会导致用户线程被强制暂停。所以我们修改回收条件为老年代的 60%，保证回收时预留足够空间放新对象。CMS 默认是老年代 68% 时触发回收机制。
        *   **G1 调整存活阈值：**超过存活阈值的 Region，其内对象会被混合回收到老年代。G1 回收时也要预留空间给新对象。存活阈值默认 85%，即当一个内存区块中存活对象所占比例超过 85% 时，这些对象就会通过 Mixed GC 内存整理并晋升至老年代内存区域。
*   **选择合适的垃圾回收器：**最有效的方式是升级，根据 CPU 核数，升级当前版本支持的最新回收器。
    *   CPU 单核，那么毫无疑问 Serial 垃圾收集器是你唯一的选择。
    *   CPU 多核，关注吞吐量 ，那么选择 Parallel Scavenge+Parallel Old 组合（JDK8 默认）。
    *   CPU 多核，关注用户停顿时间，JDK 版本 1.6 或者 1.7，那么选择 ParNew+CMS，吞吐量降低但是低停顿。
    *   CPU 多核，关注用户停顿时间，JDK1.8 及以上，JVM 可用内存 6G 以上，那么选择 G1。
*   **优化业务代码：**绝大部分问题都出自代码。要尽量减少非必要对象的创建，防止死循环创建对象，防止内存泄漏，有些情景下需要以时间换空间，控制内存使用
*   **增加机器：**增加机器，分散节点压力
*   **调整线程池参数：**合理设置线程池线程数量
*   **缓存、MQ 等中间件优化：**使用中间件提高程序效率，比如缓存、消息队列等

**JVM 参数：** 

```
# 1.查看进程号
jps
# 2.根据进程号导出
jmap -dump:format=b,file=D:\heapdump.hprof <pid>
```

### 7、项目中有没有实际的 JVM 调优经验？

#### **7.1 CPU 飙升** 

**原因：**CPU 利用率过高，大量线程并发执行任务导致 CPU 飙升。例如锁等待（例如 CAS 不断自旋）、**多线程都陷入死循环**、Redis 被攻击、网站被攻击、文件 IO、网络 IO。

**定位步骤：** 

1.  **定位进程 ID：**通过 top 命令查看当前服务 CPU 使用最高的进程，获取到对应的 pid（进程 ID）
2.  **定位线程 ID：**使用 top -Hp pid，显示指定进程下面的线程信息，找到消耗 CPU 最高的线程 id
3.  **线程 ID 转十六进制：**转十六进制是因为下一步 jstack 打印的线程快照（线程正在执行方法的堆栈集合）里线程 id 是十六进制。
4.  **定位代码：**使用 jstack pid | grep tid（十六进制），打印线程快照，找到线程执行的代码。一般如果有死锁的话就会显示线程互相占用情况。
5.  **解决问题：**优化代码、增加系统资源（增多服务器、增大内存）。

#### **7.2 GC 调优**

**最差情况下能接受的 GC 频率：**Young GC 频率 10s 一次，每次 500ms 以内。Full GC 频率 10min 一次，每次 1s 以内。

其实一小时一次 Full GC 已经算频繁了，一个不错的应用起码得控制一天一次 Full GC。

**监控发现问题：**上午 8 点是我们的业务高峰，一到高峰的时候，用户感觉到明显卡顿，监控工具（例如 Prometheus 和 Grafana）发现 TP99（99% 请求在多少 ms 内完成）时长明显变高，有明显的的毛刺；内存使用率也不稳定，会周期性增大再降低，于是怀疑是 GC 导致。

**命令行分析问题：**通过 jstat -gc 观察服务器的 GC 情况，发现 Young GC 频率提高成原来的 10 倍，Full GC 频率提高成原来的四倍。正常 YGC 10min 一次，FGC 10h 一次。异常 YGC 1min 一次，FGC 3h 一次；

所以主要问题是 Young GC 频繁，进而导致 Full GC 频繁。Full GC 频繁会触发 STW，导致 TP99 耗时上升。

**解决方案：**

*   排查内存泄漏、大对象、BUG；
*   **增大堆内存：**服务器加 8G 内存条，同时提高初始堆内存、最大堆内存。-Xms、-Xmx。
*   **提高新生代比例：**新生代和老年代默认比例是 1:2。-XX:NewRatio = 由 4 改为默认的 2
*   **降低升老年龄：**让存活对象更快进入老年代。-XX:InitialTenuringThreshold=15（JDK8 默认）改成 7（JDK9 默认）
*   **设置大对象阈值：**让大于 1M 的大对象直接进入老年代。-XX:PretenureSizeThreshold=0（默认）改为 1000000（单位是字节）
*   **垃圾回收器升级为 G1：**因为是 JDK8，所以直接由默认的 Parallel Scavenge+Parallel Old 组合，升级为低延时的 G1 回收器。如果是 JDK7 版本，不支持 G1，可以修改成 ParNew+CMS 或 Parallel Scavenge+CMS，以降低吞吐量为代价降低停顿时间。-XX:CMSInitiatingOccupancyFraction
*   **降低 G1 的存活阈值：**超过存活阈值的 Region，其内对象会被混合回收到老年代。降低存活阈值，更早进入老年代。-XX:G1MixedGCLiveThresholdPercent=90 设为默认的 85

**调优效果：**调优后我们重新进行了一次压测，发现 TP99 耗时较之前降低 60%。FullGC 耗时降低 80%，YoungGC 次数减少 30%。TP99 耗时基本持平，完全符台预期。

### 8、请你说说内存溢出

**得分点**

内存溢出、溢出原因、解决方案、mat 定位

**内存溢出：** 申请的内存大于系统能提供的内存。

**溢出原因：**

*   **本地直接内存溢出：**本地直接内存设的太小导致溢出。设置直接内存最大值 - XX：MaxDirectMemorySize，若不指定则默认与 Java 堆最大值一致。
*   **虚拟机栈和本地方法栈溢出：**如果虚拟机的栈内存允许动态扩展，并且方法递归层数太深时，导致扩展栈容量时无法申请到足够内存。
*   **方法区溢出：**运行时生成大量动态类时会内存溢出。
    *   **CGlib 动态代理：**CGlib 动态代理产生大量类填满了整个方法区（方法区存常量池、类信息、方法信息），直到溢出。CGlib 动态代理是在内存中构建子类对象实现对目标对象功能扩展，如果 enhancer.setUseCache(false);，即关闭用户缓存，那么每次创建代理对象都是一个新的实例，创建过多就会导致方法区溢出。注意 JDK 动态代理不会导致方法区溢出。
    *   **JSP：**大量 JSP 或动态产生 JSP 文件的应用（JSP 第一次运行时需要编译为 Java 类）。
*   **堆溢出：**
    *   死循环创建过多对象；
    *   集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；
    *   内存中加载的数据量过于庞大，如一次从数据库取出的数据集太大、第三方接口接口传输的大对象、接收的 MQ 消息太大；
    *   Tomcat 参数设置不当导致 OOM：Tomcat 会给每个线程创建两个默认 4M 大小的缓冲区，高并发情况下会导致缓冲区创建过多，导致 OOM。
*   程序计数器不会内存溢出。

**使用 JDK 自带的命令行调优工具 ，判断是否有 OOM：**

1.  使用 jsp 命令查看当前 Java 进程；
2.  使用 jstat 命令多次统计 GC，比较 GC 时长占运行时长的比例；
3.  如果比例超过 20%，就代表堆压力已经很大了；
4.  如果比例超过 98%，说明这段时期内几乎一直在 GC，堆里几乎没有可用空间，随时都可能抛出 OOM 异常。

**MAT 定位导致 OOM：**示例代码：写死循环创建对象，不断添加到 list 里，导致堆内存溢出；

1.  导出 dump 文件。
    1.  **方法一：OOM 时自动导出：**JVM 参数设置，内存溢出后生成 dump 文件，设置路径；-XX:+HeapDumpOnOutOfMemoryError、-XX:HeapDumpPath。
    2.  **方法二：**mat 选择线程后手动导出：
        
        ![](<assets/1740030352416.png>)
        
    3.  方法三：jmap 命令导出：
        
        ```
        //G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%
         -XX:G1MixedGCLiveThresholdPercent=65
        ```
        
2.  MAT 解析 dump 文件；
3.  **定位大对象：**点击直方图图标（Histogram），对象会按内存大小排序，查看内存占用最大的对象；右键 “List Objects” -> “with outgoing references”，找到特定实例，选择 “Path to GC Roots” -> “Exclude all phantom/weak/soft etc. references”。这将显示从垃圾收集根（GC Roots）到该对象的引用路径。找到路径上的类，分析源代码
    
    ![](<assets/1740030352627.png>)
    
4.  **这个对象被谁引用：**点击支配树（dominator tree），看大对象被哪个线程调用。这里可以看到是被主线程调用。
    
    ![](<assets/1740030352917.png>)
    
5.  **定位具体代码：**点击概述图标（thread_overview），看线程的方法调用链和堆栈信息，查看大对象所属类和第几行，定位到具体代码，解决问题。
    
    ![](<assets/1740030353182.png>)
    

**解决方案：**

1.  通过 jinfo 命令查看并修改 JVM 参数，直接增加内存。如 - Xmx256m
2.  检查错误日志，查看 “OutOfMemory” 错误前是否有其它异常或错误。
3.  对代码进行走查和分析，找出可能发生内存溢出的位置。
4.  使用内存查看工具动态查看内存使用情况。

**标准回答**

![](<assets/1740030353550.png>)

内存溢出，简单地说内存溢出就是指程序运行过程中**申请的内存大于系统能够提供的内存**，导致无法申请到足够的内存，于是就发生了**内存溢出**。

引起内存溢出的原因有很多种，常见的有以下几种：

1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；

2. 集合类中有对对象的引用，使用完后未清空，使得 JVM 不能回收；

3. 代码中存在死循环或循环产生过多重复的对象实体；

4. 使用的第三方软件中的 BUG；

5. 启动参数内存值设定的过小。

**加分回答**

**除了程序计数器外**，虚拟机内存的其他几个运行时区域**都有发生 OOM 异常的可能**。

**1. Java 堆溢出**

Java 堆用于储存对象实例，我们只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么随着**对象数量**的增加，总容量触及最大堆的容量限制后就会产生内存溢出异常。

**2. 虚拟机栈和本地方法栈溢出**

HotSpot 虚拟机中并不区分虚拟机栈和本地方法栈，如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出 OutOfMemoryError 异常。

**3. 方法区和运行时常量池溢出**

方法区溢出也是一种常见的内存溢出异常，在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。这类场景常见的包括：程序使用了 CGLib 字节码增强和动态语言、大量 JSP 或动态产生 JSP 文件的应用、基于 OSGi 的应用等。 在 JDK 6 或更早之前的 HotSpot 虚拟机中，常量池都是分配在永久代中，即常量池是方法区的一部分，所以上述问题在常量池中也同样会出现。而 HotSpot 从 JDK 7 开始逐步 “去永久代” 的计划，并在 JDK 8 中完全使用元空间来代替永久代，所以上述问题在 JDK 8 中会得到避免。

**4. 本地直接内存溢出**

直接内存的容量大小可通过 `-XX：MaxDirectMemorySize` 参数来指定，如果不去指定，则默认与 Java 堆最大值一致。如果直接通过反射获取 Unsafe 实例进行内存分配，并超出了上述的限制时，将会引发 OOM 异常。

### 9、请你说说内存泄漏

**得分点**

内存泄漏、内存泄露的 9 种情况、性能分析工具判断是否有内存泄漏、解决办法

**内存泄漏：** 不再使用的对象仍然被引用，导致 GC 无法回收；

**内存泄露的 9 种情况：**

*   **静态容器里的对象：**静态集合类的生命周期与 JVM 程序一致，容器里的对象引用也将一直被引用得不到 GC；Java 里不准静态方法引用非静态方法也是防止内存泄漏。
*   **单例对象引用的外部对象：**单例模式里，如果单例对象如果持有外部对象的引用，因为单例对象不会被回收，那么这个外部对象也不会被回收
*   **外部类跟随内部类被引用：**内部类持有外部类，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。
*   **数据库、网络、IO 等连接忘记关闭：**在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。如果对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
*   **变量作用域不合理：**例如一个变量只会在某个方法中使用，却声明为成员变量，并且被使用后没有被赋值为 null，将会导致这个变量明明已经没用了，生命周期却还跟对象一致。
*   **HashSet 中对象改变哈希值：**当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。否则对象哈希值改变，找不到对应的 value。
*   **缓存引用忘删除：**一旦你把对象引用放入到缓存中，他就很容易遗忘，缓存忘了删除，将导致引用一直存在。
*   **逻辑删除而不是真实删除：**监听器和其他回调：如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为 软 WeakHashMap 中的键。例如出栈只是移动了指针，而没有将出栈的位置赋值 null，导致已出栈的位置还存在引用。
*   **线程池时，ThreadLocal 忘记 remove()：**使用线程池的时候，ThreadLocal 需要在使用完线程中的线程变量手动 remove()，否则会内存泄漏。因为线程执行完后没有销毁而是被线程池回收，导致 ThreadLocal 中的对象不能被自动垃圾回收。 

**性能分析工具判断是否有内存泄漏：**

*   JDK 自带的命令行调优工具：
    *   每隔一段较长的时间通过 jstat 命令采样多组 OU（老年代内存量） 的最小值；
    *   如果这些最小值在上涨，说明无法回收对象在不断增加，可能是内存泄漏导致的。
*   **MAT 监视诊断内存泄漏：**
    *   **生成堆转储文件：**MAT 直接从 Java 进程导出 dump 文件
    *   **可疑点：**查看泄漏怀疑（Leak Suspects），找到内存泄漏可疑点
    *   **可疑线程：**可疑点查看详情（Details），找到可疑线程
    *   **定位代码：**查看线程调用栈（See stacktrace），找到问题代码的具体位置。
*   GC 详细日志：启动参数开启 GC 详细日志，设置日志地址；-XX:+PrintGCDetails；
*   编译器警告：查看 Eclipse 等编译器的内存泄漏警告；
*   Java 基准测试工具：分析代码性能； 

**解决办法：**

1.  牢记内存泄漏的场景，当一个对象不会被使用时，给它的所有引用赋值 null，堤防静态容器，记得关闭连接、别用逻辑删除，只要用到了引用，变量的作用域要合理。
2.  使用 java.lang.ref 包的弱引用 WeakReference，下次垃圾收集器工作时被回收。
3.  检查代码；

内存泄漏, 是指**不再使用的对象仍然被引用**, 导致垃圾收集器**无法回收**它们的内存。由于不再使用的对象仍然无法清理, 甚至这种情况可能会越积越多, 最终导致致命的 **OutOfMemoryError**。

可以按照如下的思路来分析和**解决内存泄漏问题：**

1. 启用分析器

Java 分析器是通过应用程序监视和诊断内存泄漏的工具，它可以分析我们的应用程序内部发生的事情，例如如何分配内存。使用分析器，我们可以比较不同的方法并找到可以最佳利用资源的方式。

2. 启用详细垃圾收集日志

通过启用详细垃圾收集日志，我们可以跟踪 GC 的详细进度。要启用该功能，我们需要将以下内容添加到 JVM 的配置当中：`-verbose：gc`。通过这个参数，我们可以看到 GC 内部发生的细节。

3. 使用引用对象

我们还可以借助 java.lang.ref 包内置的 Java 引用对象来规避问题，使用 java.lang.ref 包，而不是直接引用对象，即使用对象的特殊引用，使得它们可以轻松地被垃圾收集。

4. Eclipse 内存泄漏警告

对于 JDK1.5 以及更高的版本中，Eclipse 会在遇到明显的内存泄漏情况时显示警告和错误。因此，在 Eclipse 中开发时，我们可以定期地访问 “问题” 选项卡，并更加警惕内存泄漏警告。

5. 基准测试

我们可以通过执行基准测试来衡量和分析 Java 代码的性能。通过这种方式，我们可以比较执行相同任务的替代方法的性能。这可以帮助我们选择更好的方法，并可以帮助我们节约内存。

6. 代码审查

最后，我们总是采用经典的老方式来进行简单的代码演练。在某些情况下，即使这种看似微不足道的方法也有助于消除一些常见的内存泄漏问题。

**加分回答 - 没有一刀切的解决方案，具体问题具体分析**

通俗地说, 我们可以将内存泄漏视为一种疾病, 它通过**阻塞**重要的**内存资源**来**降低应用程序的性能**。和所有其他疾病一样, 如果不治愈, 随着时间的推移, 它可能导致致命的应用程序**崩溃**。

内存泄漏很难解决, 找到它们需要对 Java 语言有很深的理解并掌握复杂的命令。在处理内存泄漏时, **没有一刀切的解决方案**, 因为泄漏可能通过各种不同的事件发生。 但是, 如果我们采用最佳实践并定期执行严格的代码演练和分析, 那么我们就可以将应用程序中内存泄漏的风险降到最低。

### 10、JVM 中一次完整的 GC 流程是怎样的

堆分为哪几个区、GC 流程、注意大对象和年龄 15（JDK8）

1.  首先，任何新对象都分配到 eden 空间。两个幸存者空间开始时都是空的。
2.  当 eden 空间填满时，将触发一个 **Minor GC**(年轻代的垃圾回收，也称为 Young GC)，删除所有未引用的对象，**大对象**（需要大量连续内存空间的 Java 对象，如那种很长的字符串）直接进入老年代。
3.  所有被引用的对象作为存活对象，将移动到第一个幸存者空间 S0，并标记年龄为 1，即经历过一次 Minor GC。之后每经过一次 Minor GC，年龄 + 1。GC 分代年龄存储在对象头的 Mark Word 里。
4.  当 eden 空间再次被填满时，会执行第二次 Minor GC，将 Eden 和 S0 区中所有垃圾对象清除，并将存活对象复制到 S1 并年龄加 1，此时 S0 变为空。
5.  如此反复在 S0 和 S1 之间切换几次之后，还存活的**年龄等于 15 的对象**（JDK8 默认 15，JDK9 默认 7，-XX:InitialTenuringThreshold=7）在下一次 Minor GC 时将放到老年代中。 
6.  如果老年代内存不足够存储新对象，则会执行 Full GC（清空整个新生代和老年代）。
7.  当老年代满了时会触发 **Full GC 或者 Major GC**（老年代的垃圾回收，清理整个老年代空间）。具体是 Full GC 还是 Major GC 取决于用哪个垃圾回收器，传统垃圾回收器会 Full GC，G1（优先使用 **Mixed GC**，清空部分新生代和老年代）、ZGC（直接抛出内存溢出错误）等现代回收器会避免 Full GC。

![](<assets/1740030353796.png>)

### 11、如何避免 Full GC?

在触发以下条件时，JVM 会执行 Full GC， 将整个堆（包括整个新生代和老年代）内存清空。

**触发条件：**

*   **调用 System.gc()**：调用 System.gc() （用于请求 JVM 执行垃圾回收）时，JVM 会建议执行 Full GC（具体是否执行取决于垃圾回收器实现的 System.gc() 逻辑，例如 Parallel GC、CMS 等传统垃圾回收器该方法会 Full GC，而 G1、ZGC 等现代回收器不会 Full GC）。
*   **空间分配担保失败**：当对象从新生代晋升到老年代前，要检查老年代是否有足够空间容纳新对象，这叫做空间分配担保。如果空间不足，则空间分配担保失败，JVM 会执行 Full GC。
*   **老年代满了**：当老年代满了时会触发 **Full GC 或者 Major GC**（老年代的垃圾回收，清理整个老年代空间）。具体是 Full GC 还是 Major GC 取决于用哪个垃圾回收器，传统垃圾回收器会 Full GC，G1（优先使用 **Mixed GC**，清空部分新生代和老年代）、ZGC（直接抛出内存溢出错误）等现代回收器会避免 Full GC。
*   **方法区满了**：当方法区（Method Area）空间不足时，会触发 Full GC。。

**避免 Full GC：**

Full GC 的执行时间最长，也是 JVM 调优的重点。

*   调大老年代比例
*   增加整个堆内存
*   使用 G1、ZGC 等现代回收器。

### 12、说说 JVM 的垃圾回收机制

**得分点**

新生代收集、老年代收集、混合收集、整堆收集

依据分代假说理论, 垃圾回收可以分为： 新生代收集、老年代收集、混合收集、整堆收集

当前商业虚拟机的垃圾收集器, 大多数都遵循了 “分代收集” 的理论进行设计, 分代收集名为理论, 实质是一套符合大多数程序运行实际情况的经验法则。而分代收集理论, 建立在如下三个分代假说之上, 即弱分代假说、强分代假说、跨代引用假说。依据分代假说理论, 垃圾回收可以分为如下几类：

1. 新生代收集：目标为新生代的垃圾收集。

2. 老年代收集：目标为老年代的垃圾收集, 目前只有 CMS 收集器会有这种行为。

3. 混合收集：目标为整个新生代及部分老年代的垃圾收集, 目前只有 G1 收集器会有这种行为。

4. 整堆收集：目标为整个堆和方法区的垃圾收集。

**加分回答 - 垃圾收集器**

HotSpot 虚拟机内置了很多垃圾收集器, 其中针对新生代的垃圾收集器有 Serial、ParNew、Parallel Scavenge, 针对老年代的垃圾收集器有 CMS、Serial Old、Parallel Old。此外, HotSpot 还内置了面向整堆的 G1 收集器。

在上述收集器中, 常见的组合方式有：

1. Serial + Serial Old, 是客户端模式下常用的收集器。

2. ParNew + CMS, 是服务端模式下常用的收集器。

3. Parallel Scavenge + Parallel Old, 适用于后台运算而不需要太多交互的分析任务。

### 13、说说 GC 的可达性分析算法

**得分点**  
概念、GC Roots、引用链、非可达对象两次标记

**可达性分析算法：**

以根对象集合 (GC Roots) 的每个跟对象为起始点，根据引用关系向下搜索，将所有与 GC Roots 直接或间接有引用关系的对象在对象头的 Mark Word 里标记为可达对象，即不需要回收的有引用关系对象。搜索过程所走过的路径称为“引用链” 。

**GC Roots：**即 GC 根节点集合，是**一组**必须活跃的引用。可作为 GC Roots 的对象：

*   **栈引用的对象：**Java 方法栈、本地方法栈中的参数引用、局部变量引用、临时变量引用等。临时变量是方法里的中间操作结果。
*   **方法区中常量、静态变量引用的对象；**
*   **所有被同步锁持有的对象；**
*   **所有线程对象；**
*   所有跨代引用对象；
*   JVM 内部的引用：如基本数据类型对应的 Class 对象，常驻的异常对象，以及应用程序类类加载器； 

**非可达对象****被回收需要两次标记：**

1.  **第一次标记后筛选非可达对象：**第一次被标记后，会进行一次筛选，筛选的条件是此对象是否有必要执行 finalize() 方法，也就是是否有机会自救。假如对象没有覆盖或者已被 JVM 调用过 finalize() 方法，也就是说不想自救或已自救过，那么此对象需要被回收；假如对象覆盖并没被 JVM 调用过 finalize() 方法，该对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。
2.  **第二次标记 F-Queue** **里的未自救对象：**稍后，收集器将对 F-Queue 中的对象进行第二次小规模的标记。如果对象要在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个引用类型的类变量或者对象的成员变量，那在第二次标记时它将被移出 “即将回收” 的 F-Queue。如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

**finalize() 方法：** 

finalize() 方法是对象逃脱死亡命运的最后一次机会，需要注意的是，任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行。

另外，finalize() 方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。

当前主流的商用程序语言的内存管理子系统，都是通过可达性分析算法来**判定对象是否存活**的。

这个算法的基本思路就是通过一系列称为 “GC Roots” 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”，如果某个对象到 GC Roots 间没有任何引用链相连，或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。

![](<assets/1740030354046.png>)

​

**GC Roots 到底是什么东西呢，哪些对象可以作为 GC Root 呢？**

 是**一组必须活跃的引用**。在 Java 技术体系里面，固定可作为 GC Roots 的对象包括以下几种：

*   在虚拟机栈中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；
*   在方法区中类静态属性引用的对象，譬如 Java 类的引用类型静态变量；
*   在方法区中常量引用的对象，譬如字符串常量池里的引用；
*   在本地方法栈中引用的对象；
*   JVM 内部的引用，如基本数据类型对应的 Class 对象，常驻的异常对象，以及系统类加载器；
*   所有被同步锁持有的对象；
*   反映 Java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。

  
**加分回答 - 宣告对象死亡要经历两次标记**  
真正宣告一个对象死亡，至少要经历两次标记过程：  
**1. 第一次标记**  
如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行 finalize()方法。假如对象没有覆盖 finalize()方法，或者 finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为 “没有必要执行”。反之，该对象将会被放置在一个名为 F-Queue 的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。  
**2. 第二次标记**  
稍后，收集器将对 F-Queue 中的对象进行第二次小规模的标记。如果对象要在 finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出 “即将回收” 的集合。如果对象这时候还没有逃脱，那基本上它就真的要被回收了。  
    finalize() 方法是对象逃脱死亡命运的最后一次机会，需要注意的是，任何一个对象的 finalize() 方法都只会被系统自动调用一次，如果对象面临下一次回收，它的 finalize() 方法不会被再次执行。另外，finalize() 方法的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，如今已被官方明确声明为不推荐使用的语法。

### 14、说说 JVM 的垃圾回收算法

**得分点**

标记清除、标记复制、标记整理，比较优缺点（效率、空间浪费、调整引用、stw）、使用场景

标记清除算法、标记复制算法、标记整理算法。

**标记清除算法（Mark-Sweep）：**

*   **标记、清除：**当堆中有效内存空间被耗尽时，会 **STW**（stop the world，暂停其他所有工作线程），然后先标记，再清除。
*   **标记：**可达性分析法，从 GC Roots 开始遍历，找到可达对象，并在对象头中进行标记。
*   **清除：**堆内存内从头到尾进行线性遍历，“清除” 非可达对象。注意清除并不是真的置空，垃圾还在原来的位置。实际是把垃圾对象的地址维护在**空闲列表**，对象实例化的申请内存阶段会通过空闲列表找到合适大小的空闲内存分配给新对象。
*   **优点：**简单
*   **缺点：**
    *   **效率不高：**需要可达性遍历和线性遍历，效率差。
    *   **STW 导致用户体验差：**GC 时需要暂停其他所有工作线程，用户体验差。
    *   **有内存碎片，要维护空闲列表：**回收垃圾对象后没有整理，导致堆中出现一块块不连续的内存碎片。
*   **适用场景：**适合小型应用程序，内存空间不大的情况。应用程序越大越不适用这种回收算法。

**标记复制算法 (Copying) ：**

*   **标记、复制、清除：**将内存空间分为两块，每次只使用一块。在进行垃圾回收时，先可达性分析法标记可达对象，然后将可达对象**复制**到没有被使用的那个内存块中，最后再清除当前内存块中的所有对象。后续再按同样的流程来回复制和清除。
*   **优点：**
    *   **垃圾多时效率高：**只需可达性遍历，效率很高。
    *   **无内存碎片：**因为有移动操作，所以内存规整。
*   **缺点：**
    *   **内存利用率低，浪费内存：**始终有一半以上的空闲内存。
    *   **需要调整引用地址：**可达对象移动后，内存地址发生了变化，需要调整所有引用，指向移动后的地址。
    *   **垃圾少时效率相对差，但还是比其他算法强：**如果可达对象比较多，垃圾对象比较少，那么复制算法的效率就会比较低。只为了一点垃圾而移动所有对象未免有些小题大做。所以垃圾对象多的情况下，复制算法比较适合。
*   **适用场景：**适合垃圾对象多，可达对象少的情况，这样复制耗时短。非常适合**新生代**的垃圾回收，因为新生代要频繁地把可达对象从伊甸园区移动到幸存区，而且是新生代满了适合再 Minor GC，垃圾对象占比高，所以回收性价比非常高，一次通常可以回收 70-90% 的内存空间，现在的商业虚拟机都是用这种 GC 算法回收新生代。

**标记整理算法 (Mark-Compact) ：**

*   **标记、整理、清除：**首先可达性分析法标记可达对象，然后将可达对象按顺序整理到内存的一端，最后清理边界外的垃圾对象。相当于内存碎片优化版的标记清楚算法，不用维护空闲列表。
*   **优点：**
    *   无内存碎片：内存规整。
    *   内存利用率最高：内存既规整又不用浪费一般空间。
*   **缺点：**
    *   **效率最低：**效率比其他两种算法都低
    *   **需要调整引用地址：**可达对象移动后，内存地址发生了变化，需要调整所有引用，指向移动后的地址。
    *   **STW 导致用户体验差：**移动时需要暂停其他所有工作线程，用户体验差。

**分代收集算法：**将堆分为新生代、老年代不同生命周期的对象放在不同的代，采用不同的收集算法，以提高回收效率。

引用计数法

每个对象都保存一个引用计数器属性，用户**记录对象被引用的次数**。

**可达性分析法**

可达性分析法会以 GC Roots 作为起始点，然后一层一层找到所引用的对象，被找到的对象就是存活对象，那么其他不可达的对象就是垃圾对象。

**1. 标记清除算法**

算法分为 “标记” 和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。它主要有如下两个缺点： 第一个是执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。 第二个是内存空间碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当程序在运行过程中需要分配较大对象时无法找到足够的连续的内存而不得不提前触发另一次垃圾收集。

![](<assets/1740030354421.png>)

**2. 标记复制算法**

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。

这种复制回收算法的代价是**将可用内存缩小为了原来的一半**，**空间浪费**未免太多了一点。另外，如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销。所以，现在的商用 Java 虚拟机大多都优先采用了这种收集算法去回收新生代。

![](<assets/1740030354677.png>)

**3. 标记整理算法**

针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的 “标记 - 整理” 算法，其中的标记过程仍然与 “标记 - 清除” 算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。

如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，像这样的停顿被最初的虚拟机设计者形象地描述为 “Stop The World”。

![](<assets/1740030355158.png>)

**加分回答**

目前，新生代的垃圾回收采用标记复制算法比较多，老年代的垃圾回收采用标记整理算法比较多。而标记复制算法浪费一半内存的缺点长期以来被人诟病，所以业界也有人针对该算法给出了改进的方案。

IBM 公司曾有一项专门研究对新生代 “朝生夕灭” 的特点做了更量化的诠释——新生代中的对象有 98% 熬不过第一轮收集。因此并不需要按照 1∶1 的比例来划分新生代的内存空间。在 1989 年，Andrew

Appel 针对具备 “朝生夕灭” 特点的对象，提出了一种更优化的半区复制分代策略，现在称为“Appel 式回收”。

Appel 式回收的具体做法是把新生代分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾搜集时，将 Eden 和 Survivor 中仍然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间。

HotSpot 虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局。HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8：1：1，也即每次新生代中可用内存空间为整个新生代容量的 90%（Eden 的 80% 加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10% 的新生代是会被 “浪费” 的。

98% 的对象可被回收仅仅是 “普通场景” 下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此 Appel 式回收还有一个充当罕见情况的 “逃生门” 的安全设计，当 Survivor 空间不足以容纳一次 Minor

GC 之后存活的对象时，就需要依赖其他内存区域（实际上大多就是老年代）进行分配担保。

**对比三种垃圾回收算法：**

![](<assets/1740030355384.png>)

### 15、说说七个垃圾回收器

**得分点**  
Serial、Serial Old、PawNew、CMS、Parallel Scavenge、Parallel Old、G1

**各版本默认回收器：**JDK8 默认回收器是 Parallel+Parallel Old。

**各区域对应算法：** 

*   **新生代回收算法：**标记复制算法；
*   **老年代回收算法：**标记清除 / 整理算法
*   **整堆回收算法：**分区算法。

**Serial（串行收集器）：**

*   **介绍：**单线程、单处理器回收**新生代**，回收时会 STW。
*   **STW：**Stop The World，暂停其他所有工作线程直到收集结束。
*   **算法：**标记复制算法
*   **回收区域：**新生代
*   **优点：**简单、比其他单线程收集器效率高：单线程，不用线程切换，可以专心进行垃圾回收。
*   **应用场景：**适用于内存小的桌面应用，可以在较短时间完成收集。Serial GC 是最基础、历史最悠久的收集器，曾是 HotSpot 虚拟机新生代收集器的唯一选择。
*   **命令：**指定新生代用 Serial GC，老年代用 Serial Old GC：-XX:+UseSerialGC

**Serial Old（老年代串行收集器）：**

*   **介绍：**Serial 收集器的**老年代**版本。单线程、单处理器回收老年代，回收时会 STW。
*   **算法：**标记 - 整理算法

**ParNew（并行新生代收集器）：**Par 是 Parallel（并行，平行）的缩写，New: 只能处理的是新生代

*   **介绍：**Serial 收集器的多线程并行版本。多线程并行回收**新生代**，回收时会 STW。
*   **算法：**标记复制算法
*   **回收区域：**新生代
*   **优点：**多 CPU 场景下性能高，吞吐量大
*   **缺点：**单 CPU 场景下性能差，不如串行收集器
*   **应用场景：**多 CPU 场景下。

**Parallel Scavenge（并行收集器）：**

*   **介绍：**可控制高吞吐量，多线程并行回收**新生代**，回收时会 STW。比 ParNew 优秀，可以动态调整内存分配情况。
*   **算法：**标记复制算法
*   **回收区域：**新生代
*   **应用场景：**后台运算量大而不需要太多交互的任务。**JDK8 默认回收器是 Parallel+Parallel Old**

**Parallel Old（老年代并行收集器）：**

*   **介绍：**Parallel Scavenge 收集器的老年代版本。可控制高吞吐量，多线程并行回收**老生代**，回收时会 STW。
*   **算法：**标记整理算法
*   **回收区域：**老年代

**CMS（并发标记清除收集器）：**

*   **介绍：**以最短停顿时间为目标，JDK1.5 推出，第一次实现了垃圾收集线程和用户线程同时工作。多线程并行回收**老生代**，低 stw。初始标记和重新标记需要 stw，但耗时很短。
*   **算法：**标记清除算法。不使用标记整理算法是为了保证清除时不影响用户线程中的工作线程，如果使用标记整理算法的话工作线程引用指向的对象地址就都变了。
*   **回收区域：**老年代
*   **步骤：**
    *   **初始标记：**标记 GC Roots 直接关联的对象。单线程且停顿用户线程，速度很快。
    *   **并发标记：**从直接关联对象并发遍历整个图，标记可达对象。并发不停顿。
    *   **重新标记：**修正上一步用户线程变动的标记。并发停顿。速度远比并发标记阶段快。注意只能修正原有对象**不能修正新增对象**，即只能修正原有对象非可达变可达、可达变非可达。
    *   **并发清除：**并发线性遍历并清理未被标记的对象。并发不停顿。
*   **优点：**
    *   **并发速度快；**
    *   **低停顿：**用户线程和垃圾回收器同时执行，仅初始标记和重新标记阶段需要停顿，这两个阶段运行速度很快。
*   **缺点：**
    *   **并发占线程**
    *   **有内存碎片：**内存不规整，需要维护空闲列表。
    *   **无法处理浮动垃圾：**并发标记阶段会产生新对象，重新标记阶段又只能修正不能新增，所以会出现浮动垃圾。
    *   **回收时要确保用户线程有足够内存：**不能等老年代满了再回收，而是内存到达某个阈值后回收，防止用户线程在并发执行过程中新创建对象导致内存不够，导致虚拟机补偿使用 Serial Old 收集器进行回收并处理内存碎片，从而浪费更多时间。CMS 默认是老年代 68% 时触发回收机制。-XX:CMSInitiatingOccupancyFraction
*   **应用场景：**因为底层是标记清除算法，所以有内存碎片，适合小应用。

 **G1（Garbage-First，垃圾优先收集器）：**

*   **介绍：**以延迟可控并保证高吞吐量为目标，为了适应内存大小和处理器数量不断扩大而在 JDK7 推出的垃圾回收器。开创了收集器**面向局部收集**的设计思路和**基于 Region（区域）的内存布局**形式。JDK8 支持并发类卸载后被 Oracle 官方称为 “全功能的垃圾收集器”。并行低停顿，除了并发标记外需要 stw，但耗时很短（初始标记和最终标记是真短，筛选回收是有指定 STW）。
*   **实现机制：**不再把堆划分为连续的分代，而是将堆内存分割成 2048 个大小相等的 Region，各 Region 根据需要扮演伊甸园区、幸存区、老年代区、巨大区。垃圾优先收集器跟踪各 Region 里垃圾的**回收价值**（回收空间大小和预计回收时长），在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间，回收优先级最高的那些 Region，以达到垃圾优先的效果。
*   **设置最大停顿时间：**-XX:MaxGCPauseMillis = 默认 0.2s
*   **Humongous Region（巨大区）：**存储大小超过 Region 一半空间的大对象，如果大对象的内存大小超过了 Region 大小，将会被存在几个连续的巨大区里。G1 的大多数行为把巨大区看作老年代的一部分。
*   **算法：**分区收集算法（整体是标记整理算法、Region 之间标记复制算法）
*   **回收区域：整堆**。整堆里哪个 Region 垃圾最多，回收收益最大。
*   **步骤：**
    *   **初始标记：**标记 GC Roots 直接关联的可达对象。单线程且停顿用户线程，速度很快。
    *   **并发标记：**从直接关联对象并发遍历整个图，标记可达对象。并发不停顿。
    *   **最终标记：**重新标记所有存活的对象和上个阶段用户线程新产生的可达对象。并发停顿。采用 SATB 算法，效率比 CMS 重新标记高。并发停顿。
    *   **筛选回收：**根据优先级列表，回收价值高的一些 Region，将存活对象通过标记复制算法复制到同类型的空闲 Region。根据指定的最大停顿时间回收，因此可能来不及回收所有垃圾对象，但能保证回收到最高回收价值的垃圾。并发停顿。
*   **记忆集：**是一个抽象概念。每个 Region 都维护一个记忆集 Rset，用来记录其他 Region 对象对本 Region 对象的引用。本 Region 在回收后对象地址会改变，用记忆集就能直接知道直接找到对应引用修改指向的地址，从而不用全局扫描。
*   **卡表（CardTable）：**是记忆集的一种实现方式。卡表是一个字节数组，每个元素对应一个内存块，每个内存块大小都是 2^n 字节（Hotspot 是 2^9=512 字节）。
*   **写屏障：**当前对象被其他 Region 对象通过引用关系赋值时，赋值前后会插入写前屏障和写后屏障中断当前 Region 垃圾回收。
*   **CMS 的记忆集和写屏障：**其他回收器也用到了记忆集和写后屏障，用来防止回收导致位置改变时，不用为了更正引用地址而扫描整个堆。例如 CMS 记忆集记录老年代指向年轻代的引用。但只有 G1 用到了写前屏障。
*   **优点：**
    *   **无内存碎片：**因为整体和局部是整理和复制，都不会产生内存碎片。
    *   **无浮动垃圾：**最终标记阶段不但会修正，也会标记新增对象。
*   **缺点：**
    *   **比 CMS 更耗费内存和负载**。
    *   **可能来不及回收所有垃圾：**根据指定的 STW 时间（默认 0.2s）回收，因此可能来不及回收所有垃圾对象，但能保证回收到最高回收价值的垃圾。
    *   **比 CMS 更耗费内存和负载：**因为使用写前屏障和写后屏障维护记忆集，而 cms 只用写后屏障。
*   **应用场景：**适合多核 CPU 且内存大的大应用，小应用不及其他回收器，但未来会越来越适合。
*   ![](<assets/1740030355751.png>)
    

```
//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%
 -XX:G1MixedGCLiveThresholdPercent=65
```

**标准回答** 

《Java 虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。下图是 HotSpot 虚拟机中包含的垃圾收集器，图中展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。

![](<assets/1740030355983.png>)

​

![](<assets/1740030356513.png>)

**串行收集器 Serial**

Serial 收集器是最基础、历史最悠久的收集器，使用**复制算法**，曾经是 HotSpot 虚拟机新生代收集器的唯一选择。这个收集器是一个**单线程**工作的收集器，但它的 “单线程” 的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行**垃圾收集时，必须暂停其他所有工作线程**，直到它收集结束。也就是说它在进行垃圾收集时，会发生 “Stop The World”

**老年代串行收集器 Serial Old**  
Serial Old 是 Serial 收集器的老年代版本，它同样是一个**单线程**收集器，使用**标记 - 整理算法**，这个收集器的主要意义也是供客户端模式下的 HotSpot 虚拟机使用。

**ParNew 收集器**

ParNew 收集器实质上是 Serial 收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括 Serial 收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一致，在实现上这两种收集器也共用了相当多的代码。

**Parallel Scavenge 收集器**  
Parallel Scavenge 收集器也是一款新生代收集器，它同样是基于标记 - 复制算法实现的收集器，也是能够并行收集的多线程收集器。它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量。

**Parallel Old**

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，支持多线程并发收集，基于**标记 - 整理算法**实现。直到 Parallel Old 收集器出现后，“吞吐量优先” 收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器这个组合。

**CMS**  
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，从名字上就可以看出 CMS 收集器是基于标记 - 清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：初始标记、并发标记、重新标记、并发清除。

**G1**  
Garbage First（简称 G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于 Region 的内存布局形式。到了 JDK 8 Update 40 的时候，G1 提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的 G1 收集器才被 Oracle 官方称为 “全功能的垃圾收集器”。  
**加分回答**  
通常，Serial 收集器搭配 Serial Old 使用，ParNew 收集器搭配 CMS 使用，Parallel Scavenge 收集器搭配 Parallel Old 使用。此外，G1 是整堆收集器，它无需搭配其他的垃圾收集器。

### 16、请你讲下 CMS（并发标记清除）回收器

**得分点**

介绍、算法、回收区域、四个步骤、优缺点（并发、停顿、内存碎片、浮动垃圾、回收条件）、应用场景

**CMS（并发标记清除收集器）：**

*   **介绍：**以最短停顿时间为目标，JDK1.5 推出，第一次实现了垃圾收集线程和用户线程同时工作。多线程并行回收**老生代**，低 stw。初始标记和重新标记需要 stw，但耗时很短。
*   **算法：**标记清除算法。不使用标记整理算法是为了保证清除时不影响用户线程中的工作线程，如果使用标记整理算法的话工作线程引用指向的对象地址就都变了。
*   **回收区域：**老年代
*   **步骤：**
    *   **初始标记：**标记 GC Roots 直接关联的对象。单线程且停顿用户线程，速度很快。
    *   **并发标记：**从直接关联对象并发遍历整个图，标记可达对象。并发不停顿。
    *   **重新标记：**修正上一步用户线程变动的标记。并发停顿。速度远比并发标记阶段快。注意只能修正原有对象**不能修正新增对象**，即只能修正原有对象非可达变可达、可达变非可达。
    *   **并发清除：**并发线性遍历并清理未被标记的对象。并发不停顿。
*   **优点：**
    *   **并发速度快；**
    *   **低停顿：**用户线程和垃圾回收器同时执行，仅初始标记和重新标记阶段需要停顿，这两个阶段运行速度很快。
*   **缺点：**
    *   **并发占线程拖慢速度**
    *   **有内存碎片：**内存不规整，需要维护空闲列表。
    *   **无法处理浮动垃圾：**并发标记阶段会产生新对象，重新标记阶段又只能修正不能新增，所以会出现浮动垃圾。
    *   **回收时要确保用户线程有足够内存：**不能等老年代满了再回收，而是内存到达某个阈值后回收，防止用户线程在并发执行过程中新创建对象导致内存不够，导致虚拟机补偿使用 Serial Old 收集器进行回收并处理内存碎片，从而浪费更多时间。CMS 默认是老年代 68% 时触发回收机制。-XX:CMSInitiatingOccupancyFraction
*   **应用场景：**因为底层是标记清除算法，所以有内存碎片，适合小应用。

 ![](<assets/1740030357027.png>)

 CMS 收集器是一种以**获取最短回收停顿时间**为目标的收集器，从名字上就可以看出 CMS 收集器是基于**标记清除算法**实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：**初始标记、并发标记、重新标记、并发清除**。其中初始标记、重新标记这两个步骤仍然需要 “Stop The World”。 

**STW：**Stop-The-World 是在垃圾回收算法执行过程中, 将 jvm 内存冻结, 停顿的一种状态。即暂停用户线程。

 1. 初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快。

 2. 并发标记阶段就是从 GC Roots 的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

 3. 重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。

 4. 并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

**指定老年代使用 CMS GC：**

```
-XX:+UseConcMarkSweepGC
```

**加分回答 - 优缺点**

CMS 是一款优秀的收集器，它最主要的优点在名字上已经体现出来：**并发收集、低停顿（单位时间内占用用户线程的时间更少了）**，一些官方公开文档里面也称之为 “**并发低停顿收集器”**。

CMS 收集器是 HotSpot 虚拟机追求低停顿的第一次成功尝试，但是它还远达不到完美的程度，至少有以下三个明显的**缺点：**

 1. 并发阶段，它虽然不会导致用户线程停顿，却因为**占用一部分线程**而导致应用程序变慢，降低总吞吐量。

 2. 它**无法处理 “浮动垃圾”**，有可能会出现 “并发失败” 进而导致另一次 Full GC 的发生。

 3. 它是一款基于标记清除算法实现的收集器，这意味着收集结束时会有**大量内存碎片**产生。

### 17、请你讲下 G1 垃圾优先回收器

**得分点**

整堆、Region、标记整理、四个步骤

 **G1（Garbage-First，垃圾优先收集器）：**

*   **介绍：**以延迟可控并保证高吞吐量为目标，为了适应内存大小和处理器数量不断扩大而在 JDK7 推出的垃圾回收器。开创了收集器**面向局部收集**的设计思路和**基于 Region（区域）的内存布局**形式。JDK8 支持并发类卸载后被 Oracle 官方称为 “全功能的垃圾收集器”。并行低停顿，除了并发标记外需要 stw，但耗时很短（初始标记和最终标记是真短，筛选回收是有指定 STW）。
*   **实现机制：**不再把堆划分为连续的分代，而是将堆内存分割成 2048 个大小相等的 Region，各 Region 根据需要扮演伊甸园区、幸存区、老年代区、巨大区。垃圾优先收集器跟踪各 Region 里垃圾的**回收价值**（回收空间大小和预计回收时长），在后台维护一个**优先级列表**，每次根据用户设定允许的收集停顿时间，回收优先级最高的那些 Region，以达到垃圾优先的效果。
*   **设置最大停顿时间：**-XX:MaxGCPauseMillis = 默认 0.2s
*   **Humongous Region（巨大区）：**存储大小超过 Region 一半空间的大对象，如果大对象的内存大小超过了 Region 大小，将会被存在几个连续的巨大区里。G1 的大多数行为把巨大区看作老年代的一部分。
*   **算法：**分区收集算法（整体是标记整理算法、Region 之间标记复制算法）
*   **回收区域：整堆**。整堆里哪个 Region 垃圾最多，回收收益最大。
*   **步骤：**
    *   **初始标记：**标记 GC Roots 直接关联的可达对象。单线程且停顿用户线程，速度很快。
    *   **并发标记：**从直接关联对象并发遍历整个图，标记可达对象。并发不停顿。
    *   **最终标记：**重新标记所有存活的对象。并发停顿。采用 SATB 算法，效率比 CMS 重新标记高。并发停顿。
    *   **筛选回收：**根据优先级列表，回收价值高的一些 Region，将存活对象通过标记复制算法复制到同类型的空闲 Region。根据指定的最大停顿时间回收，因此可能来不及回收所有垃圾对象，但能保证回收到最高回收价值的垃圾。并发停顿。
*   **记忆集：**是一个抽象概念。每个 Region 都维护一个记忆集 Rset，用来记录其他 Region 对象对本 Region 对象的引用。本 Region 在回收后对象地址会改变，用记忆集就能直接知道直接找到对应引用修改指向的地址，从而不用全局扫描。
*   **卡表（CardTable）：**是记忆集的一种实现方式。卡表是一个字节数组，每个元素对应一个内存块，每个内存块大小都是 2^n 字节（Hotspot 是 2^9=512 字节）。
*   **写屏障：**当前对象被其他 Region 对象通过引用关系赋值时，赋值前后会插入写前屏障和写后屏障中断当前 Region 垃圾回收。
*   **CMS 的记忆集和写屏障：**其他回收器也用了记忆集和写后屏障，用来防止回收导致位置改变时，不用为了更正引用地址而扫描整个堆。例如 CMS 记忆集记录老年代指向年轻代的引用。但只有 G1 用到了写前屏障。
*   **优点：**
    *   **无内存碎片：**因为整体和局部是整理和复制，都不会产生内存碎片。
    *   **无浮动垃圾：**最终标记阶段不但会修正，也会标记新增对象。
*   **缺点：**
    *   **比 CMS 更耗费内存和负载**。
    *   **可能来不及回收所有垃圾：**根据指定的 STW 时间（默认 0.2s）回收，因此可能来不及回收所有垃圾对象，但能保证回收到最高回收价值的垃圾。
    *   **比 CMS 更耗费内存和负载：**因为使用写前屏障和写后屏障维护记忆集，而 cms 只用写后屏障。
*   **应用场景：**适合多核 CPU 且内存大的大应用，小应用不及其他回收器，但未来会越来越适合。
*   ![](<assets/1740030357305.png>)
    

```
//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%
 -XX:G1MixedGCLiveThresholdPercent=65
```

![](<assets/1740030357509.png>)

Garbage First（G1）垃圾优先收集器开创了**收集器面向局部收集**的设计思路和基于 **Region** 的内存布局形式。在 G1 收集器出现之前的所有其他收集器，垃圾收集的目标范围要么是整个新生代，要么就是整个老年代，再要么就是整个 Java 堆。而 G1 跳出了这个限制，它可以**面向堆内存任何部分**来组成**回收集**进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的**垃圾数量**最多，**回收收益**最大，这就是 G1 收集器的 **Mixed GC 模式。**

![](<assets/1740030357825.png>)

G1 也仍是遵循**分代收集理论**设计的，但其堆内存的布局与其他收集器有非常明显的差异：G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个**大小相等**的独立区域**（Region）**，每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。

**巨大区**：此外，还有一类专门用来存储大对象的特殊区域（Humongous Region）。G1 认为只要超过了 Region 一半的对象即可判定为大对象。而对于那些超过了整个 Region 容量的超级大对象，将会被存放在 N 个连续的 Humongous Region 之中，G1 的大多数行为都把 Humongous Region 作为老年代的一部分来进行看待。

更具体的处理思路是，让 G1 收集器去**跟踪**各个 Region 里面的垃圾堆积的 **“价值” 大小（垃圾数量）**，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据**用户设定**允许的**收集停顿时间**，**优先处理回收价值收益最大的那些 Region**，这也就是 “Garbage First” 名字的由来。

G1 收集器的运作过程大致可划分为以下四个步骤：初始标记、并发标记、最终标记、筛选回收。其中，初始标记和最终标记阶段仍然需要停顿所有的线程，但是耗时很短。

**加分回答 - G1 与 CMS 的对比：**

G1 从**整体**来看是基于**标记整理算法**实现的收集器，但从**局部**上看又是基于**标记复制算法**实现。无论如何，这两种算法都意味着 G1 运作期间**不会产生内存空间碎片**，垃圾收集完成之后能提供规整的可用内比起 CM 存。S，G1 的弱项也可以列举出不少。例如在用户程序运行过程中，G1 无论是为了垃圾收集产生的**内存占用**还是程序运行时的**额外执行负载**都要比 CMS 要**高**。

G1 与 CMS 的选择：

目前在小内存应用上 CMS 的表现大概率仍然要会优于 G1，而在**大内存应用上 G1** 则大多能发挥其优势，这个优劣势的 Java 堆容量平衡点通常在 6GB 至 8GB 之间。以上这些也仅是经验之谈，随着 HotSpot 的开发者对 G1 的不断优化，也会让对比结果继续向 G1 倾斜。

**G1 比 CMS 更耗费内存和负载：**因为使用写前屏障和写后屏障维护记忆集，而 cms 只用写后屏障。

![](<assets/1740030357990.png>)