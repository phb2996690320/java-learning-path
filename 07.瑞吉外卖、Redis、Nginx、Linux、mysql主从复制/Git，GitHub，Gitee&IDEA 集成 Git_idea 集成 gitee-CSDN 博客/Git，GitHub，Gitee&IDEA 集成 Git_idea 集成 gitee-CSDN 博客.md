---
url: https://blog.csdn.net/qq_40991313/article/details/126251168?spm=1001.2014.3001.5501
title: Git，GitHub，Gitee&IDEA 集成 Git_idea 集成 gitee-CSDN 博客
date: 2025-02-20 09:49:15
tag: 
summary: 
---
 **导航：**

[【Java 笔记 + 踩坑汇总】Java 基础 + JavaWeb+SSM+SpringBoot+SpringCloud + 瑞吉外卖 / 谷粒商城 / 学成在线 + 设计模式 + 面试题汇总 + 性能调优 / 架构设计 + 源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126646289%22%2C%22source%22%3A%22qq_40991313%22%7D "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[0、提交项目到 GitHub 简洁版](#t0)

[1、Git 介绍](#t1)

[1.1、概述](#t2)

[1.2、版本控制](#t3)

[1.3、版本控制工具](#t4)

[1.4、Git 简史](#t5)

[1.5、Git 工作机制](#t6)

[1.6、Git 和代码托管中心](#t7)

[2、Git 安装](#t8)

[3、Git 常用命令](#t9)

[3.1、设置用户签名](#t10)

[3.2、初始化本地库](#t11)

[3.3、查看本地库状态](#t12)

[3.3.1、概述](#t13)

[3.3.2、新增文件](#t14)

[3.4、添加暂存区](#t15)

[3.5、提交本地库](#t16)

[3.6、修改文件并二次提交本地库（vim 编辑器）](#t17)

[3.7、历史版本](#t18)

[3.7.1、查看历史版本](#t19)

[3.7.2、版本穿梭](#t20)

[3.8、切换版本原理](#t21)

[3.9、高级操作](#t22)

[3.9.1、清除本地 git 缓存，解决 push 后子文件夹名带 @+ 数字问题](#t23)

[3.9.2、解决上传. ignore 不生效问题](#t24)

[3.9.3、批量修改提交记录](#t25)

[4、Git 分支](#t26)

[4.1、什么是分支](#t27)

[4.2、分支的好处](#t28)

[4.3、分支的操作](#t29)

[4.3.1、查看分支](#t30)

[4.3.2、创建分支](#t31)

[4.3.3、切换分支](#t32)

[4.3.4、修改分支](#t33)

[4.3.5、合并分支](#t34)

[4.4、创建分支和切换分支原理](#t35)

[4.5 git clone(克隆) 与 git pull（拉取)](#t36) 

[5、Git 团队协作机制](#t37)

[5.1、团队内协作](#t38)

[5.2、跨团队协作](#t39)

[6、Github 和 Gitee](#t40)

[6.1、创建远程仓库](#t41)

[6.1.1、Github 远程仓库](#t42)

[6.1.2、Gitee 远程仓库](#t43)

[6.2、远程仓库操作](#t44)

[6.2.1、创建远程仓库别名](#t45)

[6.2.2、推送本地分支到远程仓库](#t46)

[6.2.3、拉取远程库分支到本地库](#t47)

[6.2.3、克隆远程仓库到本地](#t48)

[6.3、邀请加入团队](#t49)

[6.3.1、Gitee](#t50)

[6.3.2、Github](#t51)

[6.4、跨团队协作](#t52)

[6.4.1、Gitee](#t53)

[6.4.2、Github](#t54)

[6.5、SSH 免密登录](#t55)

[6.5.0、基本介绍](#t56)

[6.5.1、Gitee](#t57)

[6.5.2、Github](#t58)

[7、【重要】IDEA 集成 Git](#t59)

[7.1、配置 Git 忽略文件](#t60)

[7.1.5 关闭代码检查](#t61)

[7.2、IDEA 初始化本地库](#t62)

[7.3、切换版本](#t63)

[7.4、创建分支](#t64)

[7.5、切换分支](#t65)

[7.5.1、概述](#t66)

[7.5.2、切换分支导致代码丢失问题](#t67) 

[7.6、合并分支](#t68)

[7.7、合并分支冲突](#t69)

[8、IDEA 集成 Github](#t70)

[8.0、登录配置](#t71)

[8.0.1、密码登录](#t72)

[8.0.2、token（令牌）登录](#t73)

[8.1、分享项目到 Github](#t74)

[8.2、push 推送本地库到远程库](#t75)

[8.3、pull 拉取远程库到本地库](#t76)

[8.3.1、拉取的实现步骤](#t77)

[8.3.2、更新项目](#t78)

[8.3.3、update 和 pull 的区别](#t79)

[8.3.4、merge（推荐）和 rebase 的区别](#t80)

[8.3.5、拉取和克隆区别](#t81)

[8.4、clone 克隆远程库到本地库](#t82)

[9、IDEA 集成 Gitee](#t83)

[9.1、IDEA 安装码云插件](#t84)

[9.2、分享项目到 Gitee](#t85)

[9.2、push 推送到码云远程库](#t86)

[9.3、pull 拉取远程库到本地库](#t87)

[9.4、clone 克隆远程库到本地库](#t88)

[10、码云复制 Github 项目](#t89)

[11、使用 Gogs](#t90)

[11.1、搭建 Gogs](#t91)

[11.2、Gogs 的基本使用方法](#t92)

[创建组织](#t93) 

[组织内团队](#t94)

[团队里创建成员账号](#t95) 

[组织内创建仓库](#t96) 

[添加协作者（使用仓库的人员）](#t97)

## **0、提交项目到 GitHub 简洁版**

**0. 克隆项目**

在本地没有版本库的时候, 从远程服务器克隆整个版本库到本地, 是一个本地从无到有的过程。

```
git clone -b [分支名] [远程仓库地址]

``` 

1. 点进已有项目文件夹，右键 git bash，**设置用户签名**（仅用于区分提交者，跟 GitHub 账户邮箱没关系）：

```
git config --global user.name 用户名
git config --global user.email 邮箱
```

**2. 初始化本地仓库**

```
git init

```

 **3. 添加暂存区**

```
git add 文件名

```

添加所有变化到暂存区：

```
git add .

``` 

**4. 提交本地库**

```
git commit -m "日志信息"

```

5.GitHub **创建远程仓库** new repository

**6. 创建远程仓库别名：**

```
git remote add 远程主机名/即别名/如origin 远程地址                

```

![](<assets/1740016155528.png>)

查看远程库信息：

```
git remote -v

```

![](<assets/1740016155653.png>)

修改远程库信息：

```
git remote set-url origin <new-url>
#git remote set-url origin git@github.com:vincewm/xxxg.git
```

![](<assets/1740016155761.png>)

**7. 推送本地分支到远程仓库**

查看当前分支

```
git branch -v

```

**7.5. 拉取** 

多人协作开发时，先**拉取**（拉取 pull = 获取 fetch + 合并 merge）再执行下一步

```
git pull origin master

```

**如果有冲突：**

下面是远程库被其他人提交过，本地提前前需要处理冲突的场景：

![](<assets/1740016155859.png>)

 删掉 << 和 ==、版本号符号，然后再添加暂存区、提交本地库（这里就是合并的版本）、推送远程库。

**8. 推送本地分支**

```
git push 别名 分支如master

```

**9. 登录浏览器**，完成。 

![](<assets/1740016155988.png>)

## **1、Git 介绍**

### **1.1、概述**

*   Git 是一个免费的、开源的分布式版本控制系统 ，可以快速高效地处理从小型到大型的各种项目
    
*   Git 易于学习，占地面积小，性能 极快 。 它具有廉价的本地 库 ，方便的暂存区域和多个工作  
    流分支等特性。 其性能优于 Subversion、 CVS、 Perforce 和 ClearCase 等 版本控制 工具。
    
*   官网地址：[Git](http://git-scm.com/ "Git")
    

![](<assets/1740016156104.png>)

### 1.2、版本控制

*   版本控制是一种**记录文件内容变化**，以便将来查阅特定版本修订情况的系统。
    
*   版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看**历史版本**，方便版本切换
    

**比较容易理解版本控制思想：**

写毕业论文时候，需要多个版本进行存储，以防止修改错误后找不到以前的版本：

![](<assets/1740016156196.png>)

注意：git 控制版本不是上图这种，上图仅供理解版本控制思想，实际上 git 是通过指针控制版本的：

![](<assets/1740016156289.png>)

  
first、second、second 分别代表三个版本

### 1.3、版本控制工具

*   **集中式版本控制工具**
    *   CVS、SVN、VSS
    *   集中化的版本控制系统诸如 CVS、SVN 等，都有一个单一的**集中管理的服务器**，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。
    *   这种做法带来了许多**好处**，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以**轻松掌控每个开发者的权限**，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松**容易**。
    *   事分两面，有好有坏。这么做显而易见的**缺点**是中央服务器的**单点故障**。如果服务器宕机一小时，那么在这一小时内，**谁都无法提交更新**，也就无法协同工作。

![](<assets/1740016156392.png>)

*   [分布式](https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F&spm=1001.2101.3001.7020 "分布式")**版本控制工具**
    
    *   Git、Mercurial、…
    *   像 Git 这种分布式版本控制工具 ，客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来 (本地库) 。这 样 任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行 恢复。因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份 。
*   分布式的版本控制系统出现之后, 解决了集中式版本控制系统的缺陷 :
    
    *   服务器**断网的情况下也可以进行开发**，因为版本控制是在本地进行的
    *   **每个客户端**保存的也都是整个**完整的项目** ，包含历史记录 更加安全

![](<assets/1740016156493.png>)

### 1.4、Git 简史

![](<assets/1740016156588.png>)

### 1.5、Git 工作机制

![](<assets/1740016156678.png>)

 代码提交到本地库，才是历史版本，就删不掉了。

### 1.6、Git 和代码托管中心

代码托管中心是基于网络服务器的**远程代码仓库**，一般我们简单称为远程库。

➢   **局域网**

GitLab

➢   **互联网**

GitHub（外网）

Gitee 码云（国内网站）

## 2、Git 安装

查看当前 git 版本：

```
git version

```

![](<assets/1740016156816.png>)

*   官网地址：[Git](http://git-scm.com/ "Git")

![](<assets/1740016156912.png>)

![](<assets/1740016157005.png>)

最好安装在自己电脑开发或者环境目录下

![](<assets/1740016157115.png>)

Git 安装目录名，不用修改，直接点击下一步。

![](<assets/1740016157237.png>)

Git 的默认编辑器，建议使用默认的 Vim 编辑器，然后点击下一步。

![](<assets/1740016157333.png>)

默认分支名设置，选择让 Git 决定，分支名默认为 master，下一步。

![](<assets/1740016157429.png>)

修改 Git 的环境变量，选第一个，不修改环境变量，只在 Git Bash 里使用 Git。

![](<assets/1740016157522.png>)

选择后台客户端连接协议，选默认值 OpenSSL，然后下一步。

![](<assets/1740016157611.png>)

配置 Git 文件的行末换行符， Windows 使用 CRLF Linux 使用 LF，选择第一个自动转换，然后继续下一步。

![](<assets/1740016157701.png>)

选择 Git 终端类型，选择默认的 Git Bash 终端，然后继续下一步。

![](<assets/1740016157920.png>)

选择 Git pull 合并的模式，选择默认，然后下一步。

![](<assets/1740016158019.png>)

选择 Git 的凭据管理器，选择默认 的跨平台的凭据管理器 ，然后下一步 。

![](<assets/1740016158115.png>)

其他配置，选择默认设置，然后下一步。

![](<assets/1740016158212.png>)

实验室功能，技术还不成熟， 有已知的 bug，不要勾选，然后点击右下角的 Install 按钮，开始安装 Git

![](<assets/1740016158309.png>)

点击 Finsh 按钮， Git 安装成功！

![](<assets/1740016158399.png>)

右键任意位置，在右键菜单里选择 Git Bash Here 即可打开 Git Bash 命令行终端。在 Git Bash 终端里输入 `git --version`查看 git 版本，如图所示，说明 Git 安装成功。

![](<assets/1740016158492.png>)

## 3、Git 常用命令

<table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git config --global user.name 用户名</td><td>设置用户签名</td></tr><tr><td>git config --global user.email 邮箱</td><td>设置用户签名</td></tr><tr><td><strong>git init</strong></td><td><strong>初始化本地库</strong></td></tr><tr><td><strong>git status</strong></td><td><strong>查看本地库状态</strong></td></tr><tr><td><strong>git add 文件名</strong></td><td><strong>添加到暂存区</strong></td></tr><tr><td><strong>git commit m "日志信息" 文件名</strong></td><td><strong>提交到本地库</strong></td></tr><tr><td><strong>git reflog</strong></td><td><strong>查看历史记录</strong></td></tr><tr><td><strong>git reset hard 版本号</strong></td><td><strong>版本穿梭</strong></td></tr></tbody></table>

git 可以 tab 键代码补全，例如输入 con 按 tab 补全成 config。 

### 3.1、设置用户签名

查看当前签名：

```
git config --global user.name
git config --global user.email
```

![](<assets/1740016158579.png>) 

基本语法

```
git config --global user.name 用户名
git config --global user.email 邮箱
```

![](<assets/1740016158678.png>)

 **检查设置好的签名：**

在自己 `C:\Users\xxx`（xxx 是电脑账户名）下有个 `.gitconfig` 文件，打开里面就是我们设置的用户签名

![](<assets/1740016158779.png>)

 

![](<assets/1740016158875.png>)

**签名的作用：**

签名的作用是区分不同操作者身份。

用户的签名信息在每一个版本的提交信息中能够看到，以此确认本次提交是谁做的。Git 首次安装必须设置一下用户签名，否则无法提交代码。

**注意：**这里设置**用户签名**和将来登录 GitHub（或其他代码托管中心）的账号没有任何关系。

### 3.2、初始化本地库

**基本语法：**

```
git init

```

初始化生成的. git 是隐藏目录，要先开启：

![](<assets/1740016158972.png>)

![](<assets/1740016159079.png>)

**初始化后生成的. git 隐藏文件的内容：** 

![](<assets/1740016159176.png>)

### 3.3、查看本地库状态

#### 3.3.1、概述

**基本语法：**

```
git status

```

*   首次查看时，工作区没有任何文件

![](<assets/1740016159281.png>)

#### 3.3.2、新增文件

使用 vim 文本编辑器新增文件，再次查看本地库状态，会发现文件名是红色，表明此文件只存在于工作区，git 还没有追踪过此文件，要使用 git add 添加到暂存区（追踪文件）：

![](<assets/1740016159437.png>)

### 3.4、添加暂存区

**基本语法：**

```
git add 文件名

```

![](<assets/1740016159542.png>)

 **添加到暂存区后警告：**LF 替换成 CRLF，即换行替换成 windows 换行。

**CRLF** 是 carriage return line feed 的缩写，中文意思是回车换行。“\r\n”, **windows** 系统环境下的换行方式  
**LF** 是 line feed 的缩写，中文意思也是换行。“\n”, **Linux** 系统环境下的换行方式

再次**查看本地库状态**，会发现文件名变绿色，表面文件已保存到暂存区： 

![](<assets/1740016159637.png>)

如果想**删除暂存区的文件：**

![](<assets/1740016159720.png>)

 注意：该指令只是删除暂存区文件，工作区文件依然存在。

![](<assets/1740016159815.png>)

### 3.5、提交本地库

**将暂存区的文件提交到本地库**

```
git commit -m "日志信息"

```

![](<assets/1740016159906.png>)

**此时本地库状态是干净的：**没有东西需要提交

![](<assets/1740016159990.png>)

**对比之前暂存区状态**：还没有提交 

![](<assets/1740016160078.png>)

 **查看引用日志信息：**

```
git reflog

```

示例：

![](<assets/1740016160168.png>)

引用日志信息表明：前七位版本号，指针指向 master 信息，提交日志是 first commit 。

**查看详细日志命令：**

```
git log

```

示例： 

![](<assets/1740016160260.png>)

日志信息表明：完整版本号、作者、日期、提交日志信息。

### 3.6、修改文件并二次提交本地库（vim 编辑器）

使用 vim 编辑器修改文件、再提交暂存区、提交本地库。 

![](<assets/1740016160357.png>)

 查看引用日志信息：

![](<assets/1740016160447.png>)

发现指针指向第二次提交版本。 

### 3.7、历史版本

#### 3.7.1、查看历史版本

**基本语法：**

```
git reflog #查看版本变更信息，能看到所有回退前后的版本号


```

![](<assets/1740016160533.png>)

```
git log #查看版本详细信息，只能看到当前和以前的版本

```

![](<assets/1740016160620.png>)

虽然版本很多，但是我们工作区的 hello.txt 始终只有一个文件存在

![](<assets/1740016160711.png>)

#### 3.7.2、版本穿梭

语法：

```
git reset --hard 版本号    #这里版本号7位简短版和40位完整版都可以

```

版本穿梭后强制提交：

```
git push -f -u 别名 分支名

```

示例：

![](<assets/1740016160801.png>)

 此时文件内容展示的也是切换后版本内容：

![](<assets/1740016160888.png>)

### 3.8、切换版本原理

Git 切换版本，底层其实是移动的 HEAD 指针，具体原理如下图所示

HEAD 指针指向 master 分支，master 分支指向 first 版本，

![](<assets/1740016160977.png>)

之后有了 second 版本，master 指针指向 second 版本

![](<assets/1740016161067.png>)

之后有了 third 版本，master 指针指向 third 版本

![](<assets/1740016161161.png>)

如果我们想穿越回去，只需要让 master 指针指向 first 版本或者 second 版本

### 3.9、高级操作

#### 3.9.1、清除本地 git 缓存，解决 push 后子文件夹名带 @+ 数字问题

**问题：** 

如果推送后出现子模块文件夹后面跟 @+ 数字，那就是因为子**模块文件夹也有个. git。**

@后面的数字是[哈希](https://so.csdn.net/so/search?q=%E5%93%88%E5%B8%8C&spm=1001.2101.3001.7020 "哈希")值，用于确定唯一的提交状态。

文件 push 时会压缩，然后上传同时生成一串检验[字符串](https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&spm=1001.2101.3001.7020 "字符串")，@后面的数字就是检验字符串的前面部分。

**解决：**

在出问题子文件夹目录下删除. git 文件，然后右键 git bash，**清除本地 git 缓存：**

```
git rm -r --cached .

```

然后再 add、commit、push 就可以了。

#### 3.9.2、解决上传. ignore 不生效问题

​  
1. 删除本地缓存

```
git rm -rf --cached .

```

2. 提交

```
git add .

```

3. 更新

```
git commit -m 'update .gitignore'

```

#### 3.9.3、批量修改提交记录

**1.git 执行以下命令：**

请替换 "旧的邮箱 @example.com"、"新的作者信息" 和 "新的邮箱 @example.com" 为你的实际信息。 

```
git filter-branch -f --env-filter '
OLD_EMAIL="旧的邮箱@example.com"
CORRECT_NAME="新的作者信息"
CORRECT_EMAIL="新的邮箱@example.com"
if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_COMMITTER_NAME="$CORRECT_NAME"
    export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"
fi
if [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]
then
    export GIT_AUTHOR_NAME="$CORRECT_NAME"
    export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"
fi
' --tag-name-filter cat -- --branches --tags
```

**2. 强制推送更改到远程仓库**

```
git push --force --tags origin 'refs/heads/*'


```

![](<assets/1740016161249.png>)

## 4、Git 分支

### 4.1、什么是分支

*   在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支
*   使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行
*   对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本

### 4.2、分支的好处

*   **同时并行推进多个功能开发**，提高开发效率。
*   各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。

### 4.3、分支的操作

<table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git branch 分支名</td><td>创建分支</td></tr><tr><td>git branch -v</td><td>查看分支</td></tr><tr><td>git checkout 分支名</td><td>切换分支</td></tr><tr><td>git merge 分支名</td><td>把指定的分支合并到当前分支上</td></tr></tbody></table>

#### 4.3.1、查看分支

基本语法：

```
git branch -v

```

![](<assets/1740016161345.png>)

#### 4.3.2、创建分支

**基本语法：**

```
git branch 分支名

```

![](<assets/1740016161440.png>)

**创建并切换分支：**

```
git checkout -b <新分支名>

```

#### 4.3.3、切换分支

基本语法:`git checkout 分支名`

![](<assets/1740016161531.png>)

#### 4.3.4、修改分支

![](<assets/1740016161627.png>)

#### 4.3.5、合并分支

**基本语法：**

```
git merge 分支名

```

**注意：**

*   合并次分支到主分支时，目前分支是主分支，git merge 次分支。 
*   合并后主分支成为合并后的内容，而次分支不变。

①正常合并不冲突

![](<assets/1740016161726.png>)

**②合并产生冲突**

冲突产生的原因：

*   合并分支时，两个分支在同一个文件的同一个位置有两套完全**不同的修改**。
*   有两套完全不同的修改。 Git 无法替我们决定使用哪一个。必须 人为决定新代码内容。

例如，我们首先在 master 分支的倒数第二行进行修改，并将其添加到暂存区，再提交到本地库

![](<assets/1740016161828.png>)

接着，我们去 hot-fix 分支的倒数第一行进行修改，并将其添加到暂存区，再提交到本地库

![](<assets/1740016161923.png>)

之后我们在 master 分支上合并 hot-fix 分支，发现产生冲突

![](<assets/1740016162016.png>)

**解决冲突**

1.**vim** 编辑有冲突的文件，删除特殊符号，**决定要使用的内容**

特殊符号：`<<<<<< HEAD` 当前分支的代码 `=======` 合并过来的代码 `>>>>>>>hot-fix`

![](<assets/1740016162110.png>)

![](<assets/1740016162206.png>)

2. 删除完成之后保存，再次添加到暂存区，并**再次提交到本地库**

(**注意：**此时使用 git commit 命令时候**不能带文件名**，否则会报错)

![](<assets/1740016162294.png>)

### 4.4、创建分支和切换分支原理

![](<assets/1740016162381.png>)

master、hot-fix 其实都是指向具体版本记录的指针。当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针。

*   HEAD 如果指向 master，那么我们现在就在 master 分支上。
*   HEAD 如果执行 hotfix，那么我们现在就在 hotfix 分支上。 

所以切换分支的本质就是移动 HEAD 指针。

### 4.5 git clone(克隆) 与 git pull（拉取) 

**git clone(克隆):** 从远程获取代码并合并本地的版本。

是在本地没有版本库的时候, 从远程服务器克隆整个版本库到本地, 是一个本地从无到有的过程。**git pull** 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。

```
git clone -b [分支名] [远程仓库地址]

```

**git pull（拉取) :** 在本地有版本库的情况下, 从远程库获取最新 commit 数据 (如果有的话), 并 merge(合并) 到本地。 建议在每次 push 前先 pull 更新代码。

```
#合并本分支的版本：
#git pull <远程主机名> <本地分支名>
#远程分支是与当前分支合并merge
git pull origin master
 
 
#合并分支
#git pull <远程主机名> <远程分支名>:<本地分支名>
#将远程主机 origin 的 master 分支拉取过来，与本地的 brantest 分支合并。
#git pull origin master:brantest
```

**如果有冲突：**

下面是远程库被其他人提交过，本地提前前需要处理冲突的场景：

![](<assets/1740016162477.png>)

 删掉 << 和 ==、版本号符号，然后再添加暂存区、提交本地库（这里就是合并的版本）、推送远程库。

## 5、Git 团队协作机制

### 5.1、团队内协作

![](<assets/1740016162563.png>)

举个例子：岳不群首先用 git 初始化自己的本地库，写了一套华山剑法，利用  
push 命令将自己的本地库推送到代码托管中心 (Github、Gitee)，大弟子令狐  
冲通过 clone 克隆命令完整的复制到自己的本地库，令狐冲修改两招之后将  
自己的本地库再次 push 到代码托管中心，这样岳不群就可以通过 pull 命令  
拉取令狐冲修改的代码 来更新自己的本地库。

### 5.2、跨团队协作

![](<assets/1740016162648.png>)

令狐冲请东方不败改代码，东方不败通过 fork 命令从岳不群的的远程库中拿取代码，再通过 clone 克隆命令到自己的本地库，修改完成后使用 push 推送到在自己的远程库，使用 Pull request 拉取请求给岳不群，岳不群审核完成后使用 merge 命令合并对方的代码到自己的远程库中，再通过 pull 命令到自己的本地库中，这样修改过后的华山剑法岳不群和令狐冲就都可以使用了。

## 6、Github 和 Gitee

### 6.1、创建远程仓库

#### 6.1.1、Github 远程仓库

repository 译为仓库，资源库。

![](<assets/1740016162753.png>)

![](<assets/1740016162873.png>)

#### 6.1.2、Gitee 远程仓库

![](<assets/1740016162992.png>)

![](<assets/1740016163130.png>)

![](<assets/1740016163261.png>)

### 6.2、远程仓库操作

<table><thead><tr><th>命令名称</th><th>作用</th></tr></thead><tbody><tr><td>git remote -v</td><td>查看当前所有远程地址别名</td></tr><tr><td>git remote add 别名 远程地址</td><td>起别名</td></tr><tr><td><strong>git push 别名 分支</strong></td><td><strong>推送本地分支上的内容克隆到本地</strong></td></tr><tr><td><strong>git clone 远程地址</strong></td><td><strong>将远程仓库的内容克隆到本地</strong></td></tr><tr><td><strong>git pull 远程库地址别名 远程分支名</strong></td><td><strong>将远程仓库对于分支最新内容拉下来后与当前本地分支直接合并</strong></td></tr></tbody></table>

#### 6.2.1、创建远程仓库别名

创建远程仓库是为了在 push 和 pull 时候，可以直接用别名拉取，不用输入很长的一段链接地址。

**建议别名和库名一致**。

**①、Gihub**

**基本语法：**

```
git remote -v                               查看当前所有远程地址别名
git remote add 别名 远程地址                 起别名
```

删除远程库别名：

```
git remote remove 远程库别名


```

修改远程库别名：

```
git remote set-url origin https://github.com/username/reponame.git


``` 

**示例：** 

![](<assets/1740016163384.png>)

![](<assets/1740016163502.png>)

fetch 译为拉取，拿来。代表 pull 和 clone。

注意：起的别名最好和本地库的名称一致

**②、Gitee**

![](<assets/1740016163588.png>)

#### 6.2.2、推送本地分支到远程仓库

**基本语法：**

```
git push 别名 分支

```

**强制提交：**

```
git push -f -u 远程名/别名 分支名

``` 

**报错尝试：**由 https 换成 ssh 连接。

**解决方法：**

![](<assets/1740016163695.png>)

#### 6.2.3、拉取远程库分支到本地库

**使用情况：** 

手动在 GitHub 修改了代码，或者由其他成员在 GitHub 更新了项目，此时需要拉取远程库到本地库。

**语法：**

```
git pull 别名 分支

```

我们在远程库进行 hello.txt 的文件修改

![](<assets/1740016163808.png>)

然后在本地库将远程库的代码 拉取

![](<assets/1740016163897.png>)

#### 6.2.3、克隆远程仓库到本地

基本语法：

```
git clone 远程地址

```

我们另一台用户需要克隆我们的远程仓库到他的本地库，由于是使用一台电脑模拟，所以在克隆之前需要在 凭据管理器下删除我们之前的凭据

![](<assets/1740016163983.png>)

我们新建一个文件夹 git-clone，然后在此文件夹下右键 git bash here，之后进行克隆

![](<assets/1740016164082.png>)

![](<assets/1740016164166.png>)

克隆会自动初始化本地仓库，并起别名为 **origin**。 

### 6.3、邀请加入团队

#### 6.3.1、Gitee

我们在 git-clone(假设这是大弟子令狐冲) 文件夹里面进行代码修改，修改完后添加到暂存区，再提交到本地库，之后 push 到我们的远程库

![](<assets/1740016164254.png>)

![](<assets/1740016164351.png>)

我们在 git-demo 仓库点击管理 -> 仓库成员管理 -> 添加仓库成员 -> 邀请用户

![](<assets/1740016164449.png>)

我们在第二哥 gitee 账号里面可以接收到如下图：

![](<assets/1740016164537.png>)

令狐成成为仓库开发者被拉入团队后，我们再次在令狐冲文件夹使用进行 push

![](<assets/1740016164616.png>)

push 到远程库成功，我们在远程库查看

![](<assets/1740016164715.png>)

#### 6.3.2、Github

![](<assets/1740016164822.png>)

填入想要合作的人

![](<assets/1740016164926.png>)

复制邀请地址并发给该用户

![](<assets/1740016165019.png>)

在 atguigulinghuchong 这个账号中的地址栏复制收到邀请的链接 ，点击接受邀请。

![](<assets/1740016165107.png>)

![](<assets/1740016165197.png>)

### 6.4、跨团队协作

#### 6.4.1、Gitee

将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。

![](<assets/1740016165284.png>)

在东方不败的 Gitee 账号里的地址栏复制收到的链接，然后点击 Fork 将项目叉到自己的本地仓库

![](<assets/1740016165369.png>)

![](<assets/1740016165453.png>)

接下来点击上方的 Pull Requests 请求，并创建一个新的请求 。

![](<assets/1740016165543.png>)

![](<assets/1740016165632.png>)

合并之后我们在岳不群的 git-demo 下就可以看到东方不败的代码

![](<assets/1740016165726.png>)

#### 6.4.2、Github

将远程仓库的地址复制发给邀请跨团队协作的人，比如东方不败。

![](<assets/1740016165814.png>)

在东方不败的 GitHub 账号里的地址栏复制收到的链接，然后点击 Fork 将项目叉到自己的本地仓库

![](<assets/1740016165907.png>)

东方不败就可以在线编辑叉取过来的文件。编辑完毕后，填写描述信息并点击左下角绿色按钮提交。

![](<assets/1740016166011.png>)

### 6.5、SSH 免密登录

#### 6.5.0、基本介绍

**问题 1：为什么要 SSH 登录？**

如果没有配置过 SSH 免密登录，clone、push 时候依然可以用正常的 HTTPS，只是每次需要账号密码登录一下。

使用免密登录后，你可以在本地直接使用 ssh 链接 clone、push，而不需要再登录。

**SSH 协议：**

（Secure Shell）是一种用于远程登录和其他网络服务的安全协议。它通过加密通信来确保数据传输的安全性和保密性。

**主要作用：**

*   **远程命令执行**：用户可以通过 SSH 在远程服务器上执行命令，就像在本地机器上一样。例如我们有云服务器时，可以用 finalshell 进行远程连接，这就是 SSH 协议的应用内；
*   **认证**：SSH 支持多种认证方式，包括密码、公共密钥和双因素认证，确保只有授权用户才能访问系统。在我们 Git 远程协作时，就是基于 SSH 协议，在本地生成一个公钥，配置到 GitHub、Gitee、GitLab 上，从而支持**免密登录**这几个网站。
*   **文件传输**：SSH 协议支持安全的文件传输

**问题 2：怎么判断自己有没有配置过 SSH 免密登录？**

**方法 1：**如果克隆时提示 “You don't have any public SSH keys in your GitHub account. You can add a new public key, or try cloning this repository via HTTPS.”，则没有免密登录过：

![](<assets/1740016166132.png>)

**方法 2：**进入设置，如果没有密钥，则是没添加过：

![](<assets/1740016166253.png>)

如果 SSH keys 有密钥了，则是已经添加过了。

![](<assets/1740016166385.png>)

#### 6.5.1、Gitee

在 C 盘 User 自己的账户下右键 git bash here，`ssh-keygen -t rsa -C 自己的邮箱签名`

![](<assets/1740016166513.png>)

这样就会生成 .ssh 文件夹，里面有私钥和公钥

![](<assets/1740016166631.png>)

之后在 gitee 上添加公钥

![](<assets/1740016166723.png>)

这样我们可以借助 ssh 链接来拉取和推送代码，并且不需要进行登录

#### 6.5.2、Github

**为什么要 SSH 登录？**

如果没有配置过 SSH 免密登录，clone、push 时候依然可以用正常的 HTTPS，只是每次需要账号密码登录一下。

使用免密登录后，你可以在本地直接使用 ssh 链接 clone、push，而不需要再登录。

**怎么判断自己有没有配置过 SSH 免密登录？**

方法 1：如果克隆时提示 “You don't have any public SSH keys in your GitHub account. You can add a new public key, or try cloning this repository via HTTPS.”，则没有免密登录过：

![](<assets/1740016166813.png>)

**方法 2：**进入设置，如果没有密钥，则是没添加过：

![](<assets/1740016166896.png>)

如果 SSH keys 有密钥了，则是已经添加过了。

![](<assets/1740016166985.png>)

**1. 本地生成密钥**

打开本地文件夹，在 “C/Users / 你电脑用户名” 处 git-bash，输入下面代码后三次回车

```
ssh-keygen -t rsa -C 自己的邮箱签名

```

![](<assets/1740016167078.png>)

如果提示 “Enter file in which to save the key” ，则代表你本地已经生成过了，直接关闭 git 窗口即可。

此时该路径已经生成了. ssh 文件夹

![](<assets/1740016167170.png>)

**2. 复制公钥**

打开 id_rsa.pub，即公钥，然后复制：

![](<assets/1740016167293.png>)

![](<assets/1740016167386.png>)

**3. 粘贴到 GitHub**

![](<assets/1740016167485.png>)

![](<assets/1740016167575.png>)

![](<assets/1740016167680.png>)

添加公钥成功状态：

![](<assets/1740016167770.png>)

4. 修改已拉过项目的 url

因为在配置 ssh 之前，我们都是通过 HTTPS 克隆的代码，所以需要把这些 ur 改一下。

进入项目目录的. git 文件夹，修改 config 里 url 为 ssh 链接，相当于替换了起别名的链接，以后就可以通过别名＋ssh 提交了：

![](<assets/1740016167854.png>)

![](<assets/1740016167946.png>)

5. 其他电脑想再添加 SSH 免密登录，还是按上面操作做就行了，生成 SSH、添加到 GitHub。

## 7、【重要】IDEA 集成 Git

### 7.1、配置 Git 忽略文件

我们的 [Eclipse](https://so.csdn.net/so/search?q=Eclipse&spm=1001.2101.3001.7020 "Eclipse") 、IDEA 都会生成一些无关文件需要忽略，如图

![](<assets/1740016168032.png>)

![](<assets/1740016168126.png>)

![](<assets/1740016168215.png>)

我们之所以要忽略他们，是因为他们**与项目的实际功能无关**，不参与服务器上部署运行。

**忽略无关文件方法：**

1. 在用户家目录 (C/User / 用户名) 下创建 `git.ignore`

```
# Compiled class file
*.class
 
# Log file
*.log
 
# BlueJ files
*.ctxt
 
# Mobile Tools for Java (J2ME)
.mtj.tmp/# Package Files #
*.jar
*.war
*.nar
*.ear
*.zip
*.tar.gz
*.rar
 
hs_err_pid*
 
.classpath
.project
.settings
target
.idea
*.iml
```

![](<assets/1740016168309.png>)

2. 在 .gitconfig 文件中引用忽略配置文件 (.gitconfig 在家目录中，在上面 3.1 设置用户签名时创建的)

**注意：【user】是自己的签名，用于区分上传者身份，跟 github 账号名无关。core 修改成自己的电脑用户名，要用正斜杠。**

```
[user]
    name = Augenestern
    email = .....@qq.com
[core]
    excludesfile = C:/Users/Augenestern/git.ignore
```

![](<assets/1740016168398.png>)

3. 在 IDEA 里面定位

**注意先关闭项目再设置，否则是仅此项目内有效。**

![](<assets/1740016168484.png>)

### 7.1.5 关闭代码检查

**如果有需要的话，在设置里取消检查**（如果需要全局设置请关闭项目再设置，然后再项目内设置）：

例如我提交项目时候发现前端页面有报错和 todo，但我想忽略它们，可以这样设置。

![](<assets/1740016168569.png>)

![](<assets/1740016168691.png>)

### 7.2、IDEA 初始化本地库

1. 创建 git 本地库。vcs 就是版本控制工具的缩写。 

![](<assets/1740016168770.png>)

可以看到项目根目录下多了. git 隐藏目录，idea 很多文件变红（变红就是未被追踪，即只存在于工作区），说明 git 已接管了本目录：

![](<assets/1740016168855.png>)

![](<assets/1740016168945.png>)

 **2. 添加项目到暂存区**

![](<assets/1740016169035.png>)

**3. 提交到本地库**

![](<assets/1740016169131.png>)

提交后类和 pom.xml 边黑色，代表此时本地库状态是干净的，不需要再提交了：

![](<assets/1740016169218.png>)

修改一下代码，就又变蓝了，说明文件被 git 追踪过（添加到过暂存区）、又被修改了：

![](<assets/1740016169309.png>)

### 7.3、切换版本

切换版本后正常 push 会失败，要**强制提交：**

```
git push -f -u 远程名/别名 分支名

```

只要不删除. git 文件夹，不管怎么穿梭版本，版本都能 git reflog 看到。

**1. 提交版本 2 到本地库**。我们修改 GitTest 中的代码，文件变蓝文件被 git 追踪过（添加到过暂存区），再次提交到本地库

![](<assets/1740016169396.png>)

**2. 查看当前版本。**点击左下角 git。

![](<assets/1740016169484.png>)

如图，**黄色指针代表 head 指针（当前版本），绿色指针是当前分支指针（当前分支最新版本）**。

**3. 切换版本**

**方式一：签出版本。此时黄色 head 指针移到目标版本，绿色分支指针留在原版本，不能 push，不能强制 push，实际文件还是原版本**。

在 IDEA 的左下角，点击 Git，然后点击 Log 查看版本，右键选择要切换的版本，然后在菜单里点击 Checkout Revision，译作签出版本。**此时推送会提示游离的 head。**

![](<assets/1740016169574.png>)

**方式二：重置版本。此时黄绿指针同时指向目标版本，可以强制 push**

重置版本前如果黄绿指针不重合，则会只移动黄 head 指针，push 会失败。只有黄绿重合时才能 push。

![](<assets/1740016169664.png>)

 

![](<assets/1740016169755.png>)

例如：1.0.0 版本 “1.txt” 内容是“1.0.0”；1.0.1 版本内容是“1.0.1”；修改 1.0.1 版本后未提交的内容是“1.0.2”。现在要回退到 1.0.0 版本：

*   **软：**文件不会更改，差异将暂存以进行提交。回退到 1.0.0，并展示暂存未提交的 “1.0.2”；
*   **混合（默认）：**文件不会更改，差异也不进行暂存。回退到 1.0.0，并展示未暂存的 “1.0.2”；
*   **硬：**文件将还原为所选提交的状态，任何本地变更都将丢失。回退到 1.0.0，并展示 1.0.0 版本的 “1.0.0”；
*   **保留：**文件将还原为所选提交的状态但本地变更将保持不变。回退到 1.0.0，并展示未提交的 “1.0.2”； 

**注意：**如果黄（HEAD，指向当前版本）绿（指向分支最新版本）指针不在一起，回退版本将失败。

![](<assets/1740016169846.png>)

**重置版本后找回：**

回退版本也可以选择重置，从版本 2 重置到版本 1 后，版本 2 就看不到了，但其实还是可以从命令行 git reflog 找到对应版本号，通过 git reset --hard 版本号，回到版本 2 的。

### 7.4、创建分支

![](<assets/1740016169931.png>)

或者右下角

![](<assets/1740016170037.png>)

或者

![](<assets/1740016170135.png>)

**填写分支名称**（签出译作 checkout，切换分支）：

![](<assets/1740016170227.png>)

然后再 IDEA 的右下角看到 hot-fix，说明分支创建成功，并且当前已经切换成 hot-fix 分  
支

![](<assets/1740016170346.png>)

### 7.5、切换分支

#### 7.5.1、概述

在 IDEA 窗口的右下角，切换到 master 分支 。

![](<assets/1740016170434.png>)

#### 7.5.2、切换分支导致代码丢失问题 

​在修改文件、暂存未提交时，后切换分支会提示冲突，这时可以选择三种签出方案：

*   Force Checkout（强制签出，直接覆盖掉你修改的代码）
*   Smart Checkout（智能签出，会弹出框，让你合并代码）
*   Don't Checkout（不签出，取消的意思）

​建议要么取消暂存，要么提交，然后再切换分支。

如果选择了强制签出，这时再切换回来，会导致修改的文件恢复未修改时的样子，也就是丢失代码了，找回方法是项目右键，查看历史记录，在历史记录里找版本进行恢复。

![](<assets/1740016170524.png>)

![](<assets/1740016170618.png>)

### 7.6、合并分支

**合并 hot-fix 到 master。**先 checkout 签出到 master 分支，然后 在 IDEA 窗口的右下角，将 hot-fix 分支合并到当前 master 分支。

![](<assets/1740016170720.png>)

如果代码没有冲突，分支直接合并成功，分支合并成功以后，代码自动提交，无需手动提交本地库

### 7.7、合并分支冲突

**合并分支冲突出现情况：** 

如图所示，如果 master 分支和 hot-fix 分支都修改了代码，在合并分支的时候就会发生冲突。

![](<assets/1740016170810.png>)

![](<assets/1740016170913.png>)

![](<assets/1740016171019.png>)

我们现在站在 master 分支上合并 hot-fix 分支，就会发生代码冲突。

![](<assets/1740016171113.png>)

**合并代码冲突：**

可以分别选择接收 master 分支和 hotfix 分支的变更。这里我们点击 Conflicts 框里的 Merge 按钮，进行手动合并代码：

![](<assets/1740016171202.png>)

手动合并完代码以后，点击右下角的 Apply 按钮。代码冲突解决，自动提交本地库，文件颜色变正常：

![](<assets/1740016171293.png>)

## 8、IDEA 集成 Github

### 8.0、登录配置

#### **8.0.1、密码登录**

idea 账号有登录的话，选择账号密码登录会跳转到浏览器，授权 git 登录输入密码即可登录成功。

![](<assets/1740016171401.png>)

![](<assets/1740016171498.png>)

#### **8.0.2、token（令牌）登录**

![](<assets/1740016171611.png>)

**注意：一定要点击左下角，使用 ssh 克隆 git 仓库，否则上传 GitHub 时会报错：**

![](<assets/1740016171708.png>)

Token 在哪呢？我们在 Github 点击 Settings -> Develop Settings，重新输入密码：

![](<assets/1740016171833.png>)

![](<assets/1740016171948.png>)

点击 Generate token，口令只显示一次，刷新就没了，最好将 token 复制到记事本：

![](<assets/1740016172070.png>)

![](<assets/1740016172208.png>)

### 8.1、分享项目到 Github

![](<assets/1740016172334.png>)

这其实就是创建远程库，remote 远程即别名，是否私有，描述等

![](<assets/1740016172432.png>)

### 8.2、push 推送本地库到远程库

**1. 提交本地库。**首先修改项目，提交暂存区、提交本地库 

**2.push。**

方法一：点击导航栏 git - 推送 push：

![](<assets/1740016172541.png>)

方法二：右键点击项目，可以将当前分支的内容 push 到 GitHub 的远程仓库中 。

![](<assets/1740016172630.png>)

**3. 自定义远程为 ssh 链接。**因为 https 链接没有 ssh 快。点击远程 remote，点击自定义远程，远程就是别名，填入 GitHub 项目的 ssh 链接：

如果之前有勾选使用 ssh 克隆 git 仓库可不用这一步：

![](<assets/1740016172729.png>)

![](<assets/1740016172823.png>)

![](<assets/1740016172932.png>)

如果远程设置错误，可以管理远程，重定义：

![](<assets/1740016173043.png>)

### 8.3、pull 拉取远程库到本地库

#### 8.3.1、拉取的实现步骤

**注意：**

push 是将本地库代码推送到远程库，如果本地库代码跟远程库代码版本不一致，push 的操作是会被拒绝的。也就是说， 要想 push 成功，一定要保证本地库的版本要比远程库的版本高（可能其他成员已经提交了新版本，如果低于远程库就要检查加拉取）！

因此一个成熟的程序员在动手改本地代码之前，一定会**先检查下远程库跟本地代码的区别**！如果本地的代码版本已经落后，切记要先 pull 拉取一下远程库的代码，将本地代码更新到最新以后，然后再修改，提交，推送！

**好习惯：**

1. **在远程库版本高于本地库时候才需要拉取**

2. 改本地代码前，先 pull。push 前，先 pull，保证提交时没有冲突。

3.pull 前，确保本地文件是正常色，没有修改。

*   先修改 GitHub 端项目里代码并在 GitHub 提交，使远程库版本高于本地库
    
    ![](<assets/1740016173132.png>)
    
*   右键点击项目，可以将远程仓库的内容 pull 到本地仓库 。

![](<assets/1740016173234.png>)

![](<assets/1740016173332.png>)

**注意：**

*   pull 是拉取远端仓库代码到本地，如果远程库代码和本地库代码不一致，会自动合并，如果自动合并失败，还会涉及到手动解决冲突的问题。

#### 8.3.2、更新项目

![](<assets/1740016173426.png>)

选择合并或变基： 

![](<assets/1740016173538.png>)

如果选择合并，则处理冲突：

![](<assets/1740016173654.png>)

选择性接收：

![](<assets/1740016173747.png>)

#### 8.3.3、update 和 pull 的区别

*   git pul：git 自带命令。相当于拉取 + 合并，即 fetch+merge。
*   git update：idea 命令。相当于拉取 + 自己选择合并 / 变基，即 fetch+merge/rebase

#### 8.3.4、merge（推荐）和 rebase 的区别

**合并（推荐）：**将多个分支合并到一个新创建的提交中，该提交包含了两个分支的所有更改。

合并后分支图谱不好看，一堆线交错，但合并有冲突的话，只要解一次就行了

![](<assets/1740016173837.png>)

**变基：**将一系列的提交从一个分支应用到另一个分支上。

合并后分支图谱好看，一条线，但合并过程中出现冲突的话，比较麻烦（rebase 过程中，一个 commit 出现冲突，下一个 commit 也极有可能出现冲突，一次 rebase 可能要解决多次冲突）；

![](<assets/1740016173925.png>)

#### 8.3.5、拉取和克隆区别

**相同点：** 

git clone 和 git pull 都是从远程服务器拉取代码到本地。

**不同点：** 

**git clone** 是在**本地没有版本库**的情况下拉取，是一个本地从无到有的过程。

**git pull=git fetch + git merge**。每次从本地仓库 push 到远程仓库之前要先进行 git pull 操作，保证 git push 到远程仓库时没有版本冲突。

### 8.4、clone 克隆远程库到本地库

1. 先关闭当前项目，因为在没有项目的时候需要克隆。这里我直接把当前项目删除。

![](<assets/1740016174029.png>)

或者在另一个项目内点击 git-clone

![](<assets/1740016174130.png>)

2. 选择 GitHub 里项目登录，或者填写 ssh 链接，修改项目目录 

![](<assets/1740016174231.png>)

## 9、IDEA 集成 Gitee

码云和 GitHub 很多操作类似，根本的区别是码云在国内，建议 HTTPS 链接，而 GitHub 在国外用 ssh

### 9.1、IDEA 安装码云插件

Idea 默认不带码云插件，我们第一步要安装 Gitee 插件。

![](<assets/1740016174333.png>)

安装完成重启 IDEA 即可

Idea 连接码云和连接 GitHub 几乎一样，首先在 Idea 里面创建一个工程，初始化 git 工程，然后将代码添加到暂存区，提交到本地库。

![](<assets/1740016174428.png>)

### 9.2、分享项目到 Gitee

![](<assets/1740016174522.png>)

### 9.2、push 推送到码云远程库

当然我们也可以自己在码云 Gitee 上创建远程库，然后获取到远程库的 HTTPS/SSH 链接，将我们的代码 push 即可

自定义远程库链接： Define remote，给远程库链接定义个 name，然后再 URL 里面填入码云远程库的 HTTPS 链接即可，码云服务器在国内，用 HTTPS 链接即可，没必要用 SSH 免密链接

![](<assets/1740016174608.png>)

### 9.3、pull 拉取远程库到本地库

我们在远程库修改代码，然后使用本地库 pull 拉取远程库的代码

![](<assets/1740016174699.png>)

![](<assets/1740016174798.png>)

![](<assets/1740016174956.png>)

### 9.4、clone 克隆远程库到本地库

![](<assets/1740016175042.png>)

![](<assets/1740016175130.png>)

## 10、码云复制 Github 项目

码云提供了直接复制 GitHub 项目的功能，方便我们做项目的迁移和下载 。

![](<assets/1740016175221.png>)

将 GitHub 的远程库 HTTPS 链接复制过来，点击创建按钮即可。

![](<assets/1740016175309.png>)

如果 GitHub 项目更新了以后，在码云项目端可以手动重新同步，进行更新！

## 11、**使用 Gogs**

Gogs 和 GitHub、GitLab 都是 Git 托管平台，Gogs 相比它们两者更轻量。

Gogs 的官网地址：[Gogs: A painless self-hosted Git service](https://gogs.io/ "Gogs: A painless self-hosted Git service")

### **11.1、搭建 Gogs**

略。 

### **11.2、Gogs 的基本使用方法**

进入 Gogs：[http://192.168.101.65:10880](http://192.168.101.65:10880/gogs/xuecheng-plus "http://192.168.101.65:10880") 

账号 / 密码：gogs/gogs

#### 创建组织 

 1、首先创建一个组织

![](<assets/1740016175403.png>)

该组织通常以项目名命名，填写组织名称。

![](<assets/1740016175503.png>)

创建成功，进入管理面板修改组织信息

![](<assets/1740016175589.png>)

点击编辑，填写组织名称。

![](<assets/1740016175678.png>)

修改成功，进入首页点击组织名称

![](<assets/1740016175758.png>)

#### 组织内团队

进入组织首页

![](<assets/1740016175846.png>)

下边开始创建团队

![](<assets/1740016175945.png>)

假如创建研发团队，填写团队名称

![](<assets/1740016176040.png>)

选择权限等级，注意：这里即使选择了权限等级也需要在仓库管理中去管理协作者的权限。

 团队创建成功

![](<assets/1740016176125.png>)

#### 团队里创建成员账号 

团队创建成功下边开始创建成员账号 。

首先在用户管理中添加账号分配给成员。

![](<assets/1740016176215.png>)

然后在下边的界面 中向团队添加成员

![](<assets/1740016176305.png>)

#### 组织内创建仓库 

团队和组织创建完成，下边创建仓库，进入组织，创建仓库。

![](<assets/1740016176402.png>)

填写仓库信息

![](<assets/1740016176494.png>)

创建成功，仓库地址：[http://192.168.101.65:10880/xuecheng-plus-group1/xuecheng-plus-group1.git](http://192.168.101.65:10880/xuecheng-plus-group1/xuecheng-plus-group1.git "http://192.168.101.65:10880/xuecheng-plus-group1/xuecheng-plus-group1.git")，如下

![](<assets/1740016176586.png>)

#### 添加协作者（使用仓库的人员）

点击 “仓库设置”，

![](<assets/1740016176681.png>)

添加协作者，将团队成员的账号添加为协作者。

添加完成注意分配权限，如下图，通常测试人员为读取权限，开发人员为读写权限。

![](<assets/1740016176777.png>)

团队 Leader 需要将初始代码上传至 Git 仓库，团队成员通过 Idea 克隆一份项目代码，通过此仓库进行协作开发。