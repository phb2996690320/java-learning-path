---
url: https://blog.csdn.net/qq_40991313/article/details/134742377?spm=1001.2014.3001.5501
title: 什么是 JVM 的内存模型？详细阐述 Java 中局部变量、常量、类名等信息在 JVM 中的存储位置_jvm 内存模型 - CSDN 博客
date: 2025-02-20 13:55:49
tag: 
summary: 
---
**导航：**

[【Java 笔记 + 踩坑汇总】Java 基础 + JavaWeb+SSM+SpringBoot+SpringCloud + 瑞吉外卖 / 谷粒商城 / 学成在线 + 设计模式 + 面试题汇总 + 性能调优 / 架构设计 + 源码解析](https://blog.csdn.net/qq_40991313/article/details/126646289 "【Java笔记+踩坑汇总】Java基础+JavaWeb+SSM+SpringBoot+SpringCloud+瑞吉外卖/谷粒商城/学成在线+设计模式+面试题汇总+性能调优/架构设计+源码解析")

**目录**

[一、JVM 基本介绍](#t0)

[二、JVM 内存模型](#t1)

[2.0 概述](#t2)

[2.1 类加载子系统](#t3)

[2.2 运行时数据区](#t4)

[2.2.0 基本介绍](#t5)

[2.2.1 本地方法栈：由 C 语言实现](#t6)

[2.2.2 Java 方法栈（虚拟机栈）](#t7)

[2.2.3 方法区](#t8)

[2.2.3.1 基本概念](#2.2.3.1%C2%A0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%C2%A0) 

[2.2.3.2 实现方式：永久代和元空间](#2.2.3.2%20%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%B0%B8%E4%B9%85%E4%BB%A3%E5%92%8C%E5%85%83%E7%A9%BA%E9%97%B4)

[2.2.3.3 组成元素：类常量池、运行时常量池、字符串常量池](#2.2.3.3%20%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0%EF%BC%9A%E7%B1%BB%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0)

[2.2.4 堆](#t9)

[2.2.5 程序计数器（PC 寄存器）](#t10)

[2.3 执行引擎](#t11)

## 一、JVM 基本介绍

我们经常说 Java 是一个跨平台的语言，因为它是运行在 Java 虚拟机上（JVM）的。

在 Java 程序的实际编译、运行过程中，编译器将 Java 源代码编译成字节码文件后，JVM 将字节码翻译成特定平台的机器码运行程序。

实际上，Java 是跨平台的，JVM 不是跨平台的，我们在 Linux、windows 等系统中安装对应版本的 JVM 后，同一个 Java 代码在这些 JVM 上运行，从而起到跨平台的效果。

**JDK、JRE、JVM、Java 的区别：**

JVM 是 Java 虚拟机，JRE 是 Java 运行环境，JDK 是个 Java 开发的工具包，Java 是门编程语言。 

*   **JVM（Java Virtual Machine）：**是 Java 虚拟机，是 Java 程序运行的基础，它将 Java 程序编译后的字节码解释执行，并将其转换为机器码运行。
*   **JRE（Java Runtime Environment）：**是 Java 运行环境，包括了 JVM 以及 Java 程序运行所需的类库等。
*   **JDK：**Java 开发工具包，包括了 JRE 以及用于 Java 开发的工具，如编译器（javac）、调试器（jdb）、打包工具（jar）等。

![](<assets/1740030949431.png>)

## 二、JVM 内存模型

### 2.0 概述

**JVM 由三大部分组成：**类加载子系统、运行时数据区、执行引擎。

![](<assets/1740030949736.png>)

### 2.1 **类加载子系统**

**类加载子系统：**通过类加载机制加载类的 class 文件，如果该类是第一次加载，会执行加载、验证、解析。只负责 class 文件的加载，至于是否可运行，则由执行引擎决定。

JVM 中，类加载过程是在类加载子系统完成的。

**类加载过程：**加载 --> 链接（验证 --> 准备 --> 解析） --> 初始化

![](<assets/1740030949837.png>)

**类加载过程：**加载、链接（验证、准备、解析）、初始化。这个过程是在类加载子系统完成的。

**加载：**生成类的 Class 对象。

1.  通过一个类的全限定名获取定义此类的二进制字节流（即编译时生成的类的 class 字节码文件）
2.  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。包括创建运行时常量池，将类常量池的部分符号引用放入运行时常量池。
3.  在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类各种数据的访问入口。注意类的 class 对象是运行时生成的，类的 class 字节码文件是编译时生成的。

**链接：**将类的二进制数据合并到 JRE 中。该过程分为以下 3 个阶段：

*   **验证：**确保代码符合 JAVA 虚拟机规范和安全约束。包括文件格式验证、元数据验证、字节码验证、符号引用验证。
    *   **文件格式验证：**验证字节码文件是否符合规范。
        *   **魔数：**是否魔数 0xCAFEBABE 开头
        *   **版本号：**版本号是否在 JVM 兼容范围
        *   **常量类型：**类常量池里常量类型是否合法
        *   **索引值：**索引值是否指向不存在或不符合类型的常量。
    *   **元数据验证：**元数据是字节码里类的全名、方法信息、字段信息、继承关系等。
        *   **标识符：**验证类名接口名标识符有没有符合规范
        *   **接口实现方法：**有没有实现接口的所有方法
        *   **抽象类实现方法：**有没有实现抽象类的所有抽象方法
        *   **final 类：**是不是继承了 final 类。
    *   **指令验证：**主要校验类的方法体，通过数据流和控制流分析，保证方法在运行时不会危害虚拟机安全。
        *   **类型转换：**保证方法体中的类型转换是否有效。例如把某个类强转成没继承关系的类
        *   **跳转指令：**保证跳转指令不会跳转到方法体以外的字节码指令上；
        *   保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
    *   **符号引用验证：**确保后面解析阶段能正常执行。
        *   **类全限定名地址：**验证类全限定名是否能找到对应的类字节码文件
        *   **引用地址：**引用指向地址是否存在实例
        *   **引用权限：**是否有权引用
*   **准备：**为类变量（即 static 变量）分配内存并赋零值。
*   **解析：**将方法区 - 运行时常量池内的符号引用（类的名字、成员名、标识符）转为直接引用（实际内存地址，不包含任何抽象信息，因此可以直接使用）。

**初始化：**类变量赋初值、执行静态语句块。

### 2.2 **运行时数据区**

#### **2.2.0 基本介绍**

**运行时数据区：**在程序运行时，存储程序的内容（例如字节码、对象、参数、返回值等）。

运行时数据区包括本地方法栈、虚拟机栈、方法区、堆、程序计数器。

在运行时数据区中，只有方法区和堆是各线程共享的进程内存区域，其他运行区都是每个线程可以独立拥有的。

**图示：**

![](<assets/1740030949930.png>)

#### **2.2.1 本地方法栈：由 C 语言实现**

**本地方法栈：**存放本地方法调用过程中的栈帧。

本地方法栈用于管理本地方法的调用，本地方法是 **C 语言**写的**，**被编译为基于本机硬件和操作系统的程序。

**注意：**不是所有虚拟机都支持本地方法栈，例如 Hotspot 虚拟机（HotSpot 是 Sun/OracleJDK 和 OpenJDK 中的默认 Java 虚拟机）就是将本地方法栈和虚拟机栈合二为一。栈解决程序的运行问题，即程序如何执行、如何处理数据。

**栈帧：**栈帧是栈的元素，由三部分组成，即局部变量表（存方法参数和**局部变量**）、操作数栈（存方法执行过程中的中间结果，或者其他暂存数据）和帧数据区（存方法返回地址、线程引用等附加信息）。

#### **2.2.2 Java 方法栈（虚拟机栈）**

存放 Java 方法调用过程中的栈帧。用于管理 Java 方法的调用。

Java 方法是我们**开发时写的 Java 方法**。

![](<assets/1740030950034.png>)

#### **2.2.3 方法区**

##### **2.2.3.1** 基本概念 

**方法区：**可以看作是一块独立于 Java 堆的内存空间，方法区是各线程共享的内存区域。

![](<assets/1740030950356.png>)

##### **2.2.3.2 实现方式：**永久代和元空间

方法区有两种实现方式，分别是：永久代和元空间。

**永久代：**属于 JVM 方法区的内存，用来存储**类的元数据**，如类名、方法信息、字段信息等一些静态的数据。

**永久代的特点：**

*   JDK7 及之前方法区也叫永久代。
*   永久代的缺点是内存大小固定，容易出现 oom 问题。
*   可以通过 - XX:PermSize 设置永久代大小。永久代对象只能通过 Major GC（又称 Full GC）进行垃圾回收。

**元空间：**是 Hotspot 在 JDK8 引入的，用于取代永久代。

元空间属于本地内存，由操作系统直接管理，不再受 JVM 管理。

同时内存空间可以自动扩容，避免内存溢出。默认情况下元空间可以无限使用本地内存，也可以通过 - XX:MetaspaceSize 限制内存大小。

**方法区和永久代、元空间的关系：**方法区是一个抽象概念，永久代和元空间是方法区的实现方式。

##### **2.2.3.3 组成元素：类常量池、运行时常量池、字符串常量池**

**常量池：**就是一张表，JVM 根据这张常量表找到要执行的类信息和方法信息

*   **类常量池：**是. class 字节码文件中的资源仓库，主要存放字面量（表示字符串值和数值，例如字符串值 "abc"、**final 常量、静态变量**）和符号引用（类和接口的全限定名、字段名、方法名）。
*   **运行时常量池：**类加载的 “加载” 阶段会创建运行时常量池，统一存放各个类常量池去重后的符号引用。在类加载的 “解析” 阶段 JVM 会把运行时常量池的这些符号引用转为直接引用。类常量池。类常量池在字节码文件中的，运行时常量池在内存中。
*   **字符串常量池：**专门针对 String 类型设计的常量池。是当前应用程序里所有线程共享的，每个 jvm 只有一个字符串常量池。存储字符串对象的引用。在创建 String 对象时，JVM 会先在字符串常量池寻找是否已存在相同字符串的引用，如果有的话就直接返回引用，没的话就在堆中创建一个对象，然后常量池保存这个引用并返回引用。

#### **2.2.4 堆**

**堆：**存放对象实例、**实例变量**、数组，包括新生代（伊甸园区、幸存区 S0 和 S1）和老年代。

堆是垃圾收集器管理的内存区域。

堆解决的是数据存储的问题，即数据怎么放、放在哪儿。堆实际内存空间可以不连续，大小可以选择固定大小或可扩展，堆是各线程共享的内存区域。

**堆的 GC 流程：**

1.   首先，任何新对象都分配到 eden 空间。两个幸存者空间开始时都是空的。
2.  当 eden 空间填满时，将触发一个 **Minor GC**(年轻代的垃圾回收，也称为 Young GC)，删除所有未引用的对象，**大对象**（需要大量连续内存空间的 Java 对象，如那种很长的字符串）直接进入老年代。
3.  所有被引用的对象作为存活对象，将移动到第一个幸存者空间 S0，并标记年龄为 1，即经历过一次 Minor GC。之后每经过一次 Minor GC，年龄 + 1。GC 分代年龄存储在对象头的 Mark Word 里。
4.  当 eden 空间再次被填满时，会执行第二次 Minor GC，将 Eden 和 S0 区中所有垃圾对象清除，并将存活对象复制到 S1 并年龄加 1，此时 S0 变为空。
5.  如此反复在 S0 和 S1 之间切换几次之后，还存活的**年龄等于 15 的对象**（JDK8 默认 15，JDK9 默认 7，-XX:InitialTenuringThreshold=7）在下一次 Minor GC 时将放到老年代中。 
6.  当老年代满了时会触发 **Major GC**（也称为 Full GC），Major GC 清理整个堆 – 包括年轻代和老年代。

![](<assets/1740030950594.png>)

#### **2.2.5 程序计数器（PC 寄存器）**

**程序计数器（PC 寄存器）：**存放下一条字节码指令的地址，由执行引擎读取下一条字节码指令并转为本地机器指令进行执行。是程序控制流（分支、循环、跳转、线程恢复）的指示器，只有它不会抛出 OutOfMemoryError。每个线程有自己独立的程序计数器，以便于线程在切换回来时能知道下一条指令是什么。程序计数器生命周期与线程一致。

![](<assets/1740030950698.png>)

### 2.3 **执行引擎**

**执行引擎：**将字节码指令解释 / 编译为对应平台上的本地机器指令。充当了将高级语言翻译为机器语言的译者。

执行引擎在执行过程中需要执行什么样的字节码指令依赖于 PC 寄存器。每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。

指令可以分为字节码指令和本地机器指令。

*   **字节码指令（JVM 指令）：**字节码文件中的指令，内部只包含一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息，不能够直接运行在操作系统之上。
*   **本地机器指令：**可以直接运行在操作系统之上。